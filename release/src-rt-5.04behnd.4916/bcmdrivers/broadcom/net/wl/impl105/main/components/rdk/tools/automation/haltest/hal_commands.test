#!/bin/env utf
# -*-tcl-*-

#
# UTF test script for HAL API iverfication
# $Id: hal_commands.test 33697 2022-06-07$
# $sj943186$
# $ Copyright Broadcom $
#
# Load help package before any other UTF packages.
# package require UTF::help

# Script help string
set hal_commands_help "\n\nBasic usage: Test/hal_commands.test <options>\
    \n\nThis Rate vs Range script will setup your testrig by loading the desired\
    \nbuilds, produce high level summary web pages and calls the script that does\
    \nthe lower level work, aci.test. The script aci.test is called for up to 4\
    \ndifferent channels. Each channel is tested for the upstream and downstream\
    \ntraffic directions.\

    \n\nYou can take complete control of the AP & STA initialization sequence by\
    \nspecifying the variables ::rvr_ap_init and ::rvr_sta_init in your config\
    \nfile. The defaults are defined in aci.test proc get_user_parms. Alternately,\
    \nlook in the RvR logfiles in the Setup AP & STA section to see the defaults.\
    \nFor SoftAP, you can specify the initialization in ::rvr_softap_init. SoftAP\
    \ndefaults to the values from ::rvr_sta_init.\
    \n\nSome people may have more complex initialization needs which depend on the\
    \nSTA talking to a real AP versus a SoftAP, and other variations. So this\
    \ninitialization variable heirarchy is available to allow customization\
    \nfor all devices in the testrig, as well as STA specific customizations:\
    \nFor STA to SoftAP ::rvr_sta_{STA}_to_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_softap_init ::rvr_sta_init\
    \nFor STA to AP     ::rvr_sta_{STA}_to_ap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_sta_to_ap_init ::rvr_sta_init\
    \nFor SoftAP        ::rvr_sta_{STA}_am_softap_init ::rvr_sta_{STA}_init\
    \n                  ::rvr_softap_init ::rvr_sta_init\
    \nFor AP            ::rvr_ap_{AP}_init ::rvr_ap_init\
    \nIn the above variables, {STA} & {AP} mean the UTF STA name.\
    \nWhen the script looks for the initialization, the list is searched from left\
    \nto right, with the STA specific variable having the highest priority.\
    \nBecause the script knows which AP & STA you are using, and if you specified\
    \nthe -softap option or not, the script can locate and use the appropriate\
    \ninitialization variables without any additional user intervention.\
    \n\nIf you want to use the -warmup option, you can override the default 5Mb/s pass\
    \ncriteria by specifying:\
    \n    set ::rvr_warmup nn\
    \n    Set this parameter to 0 or -1 if you dont want a pass criteria.\
    \n\nTo keep tests from running away for hours at a time, the aci.test script has a\
    \ntime limit of 90 minutes for each rampdown/rampup test. If you want to override\
    \nthe default 90 minute per test timeout value, then specify:\
    \n    set ::rvr_overall_timeout_min mm\
    \n    Set this parameter to 0 or -1 for no timeout, unlimited test run time.\
    \n\nBy default the script will try 1 time to rejoin the AP and STA. This default\
    \ncan be changed in your config file:\
    \n    set ::rvr_rejoin_tries ii\
    \n    The minimum value for this parameter is 1.\
    \n\nBy default, the script will wait 10 seconds after a rejoin attempt. This\
    \ndefault can be changed in your config file:\
    \n    set ::rvr_rejoin_wait_sec jj\
    \n    The minimum value for this parameter is 5.\
    \n\nBy default, the script will perform 3 progressive recovery attempts during the\
    \ntests if things go wrong. This default can be changed in your config file:\
    \n    set ::recovery_max kk\
    \n    Set this parameter to 0 or -1 for no recovery actions.\
    \n\nBy default, the script will stop the rampdown portion of the test after 3\
    \nconsecutive attenuator steps with no beacons. This default can be changed in\
    \nyour config file:\
    \n    set ::rvr_rampdown_nobeacons bb\
    \n    Set this parameter to 0 or -1 to disable this feature.\
    \n\nThe optional -stopslowrampup algorithm is controlled by two parameters, whose\
    \ndefaults are 10 & 1 respectively. These defaults can be changed in your config file:\
    \n    set ::rvr_slowrampup_cnt cc\
    \n    set ::rvr_slowrampup_tput tt\
    \n\nThere may be times that a specific STA needs the router to do something\
    \nspecifically for that STA. You can add STA specific variables to set the\
    \nrouter nvram accordingly in your config file. Dont forget to turn these\
    \nsettings back for theSTAs.\
    \n    set ::mc351_4319USB_rtr_nvram {antswitch=3}\
    \n    set ::mc356_43326USB_rtr_nvram {antswitch=0}\
    \n\nAfter each occasional repeated error attenuator occurs, the attenuator\
    \nrecovery is attempted. If you choose to specify the variable shown below in\
    \nyour config file, your attenuator will be power cycled for you, and the\
    \ncommand retried after the power cycle:\
    \n    set ::rvr_attn_power \"mcxxwsy 1\"\
    \nAfter 3 repeated attenuator errors, the aci.test is halted. Should you\
    \nwish to alter the default 3 attenuator error limit, you may specify the\
    \nvariable shown below in your config file:\
    \n    set ::rvr_attn_max_errors N\
    \n    Set this parameter to 0 or -1 to allow unlimited errors to occur.\
    \n\nThe optional fastrampup test will test 10 samples at the final attenuator\
    \nvalue. You can alter this value by specifying ::rvr_fastrampup_cnt in your\
    \nconfig file. Variable ::rvr_fastrampup_tput controls the thruput at which\
    \nthe fastrampup is made, default is 1 Mb/s.\
    \n\nFor SoftAP tests, the RF wiring on the attenuator needs to be set up to\
    \nattenuate the RF path between the SoftAP and the STA being tested. Most\
    \ntestrigs need to be modified for this to work, as they tend to have a real\
    \nAP connected to the attenuator, not a SoftAP.\
    \n\nFor SoftAP tests, you need to ensure the SoftAP and STAs will get IP\
    \naddresses. A real AP has a built-in DHCP server. If the SoftAP is running\
    \non Linux, you can run dhcpd on the Linux host. You will still need to\
    \nconfigure a static IP address for the SoftAP itself. If the SoftAP does\
    \nnot provide dhcpd, then you must configure static IP addresses for the\
    \nSTA that will be tested. See examples in utfconf/pb4a.tcl & mc49.tcl.\
    \n\nThe AP connect time check looks for drops of 30 seconds or more as\
    \nan indicator of issues. The variable ::rvr_connect_time_drop can be used\
    \nto alter this threshold. Set to -1 to turn off this test.\
    \n\nTrenderrors looks at how many consecutive errors occur as well as total\
    \nerrors in the test. Initially most controlchart tests are shown as PASS,\
    \nexcept for major errors like assert or ping fail. Then, at the end of the\
    \ntests, the trend errors analysis is done and the overall PASS/FAIL criteria\
    \nis determined. Config file variable ::rvr_trend_error_length defaults to 6,\
    \nand is the minimum number of consecutive errors needed to trigger a trend\
    \nerror FAIL. Variable ::rvr_trend_error_max defaults to 18, and is the total\
    \nnumber of errors that can occur, consecutive or not, without causing a FAIL.\
    \n\nValid options are:\
    \n -utfconf path        Config file to use, default is ~/.utfconf.tcl"

# Command line options string
set hal_commands_getopts {
	{sta.arg "4325sdio" "sta name"}
	{ap.arg "4704/4318"
	    "AP name.  For simultaneous dualband routers, use a pair '2g 5g'"}
	{suite.arg "P1" "Other"}
	{trx.arg "" "Router trx"}
	{ap2.arg "" "2nd AP.  May be used for MultiSTA tests, etc"}
	{trx2.arg "" "2nd AP image"}
	{tag.arg "" "Router release tag"}
	{statag.arg "" "STA release tag"}
	{bin.arg "" "STA dongle image"}
	{email.arg "" "Email Address"}
	{noapload "Don't load images"}
	{nostaload "Don't reload STA drivers"}
	{nostaunload "Don't unload STA drivers at the end of the tests"}
	{nostareload "Don't even reload STA drivers"}
	{stadate.arg "" "STA Image date"}
	{stasecurity.arg "" "STA security"}
	{norestore "Don't reset to defaults"}
	{nojoin "(obsolete)"}
	{nochannels "DEPRECATED: use -nochan"}
	{nosetup "No Setup"}
	{nobtests "Disable Bangalore tests"}
	{nopingtimes "Disable PingTimes test"}
	{norts "Disable RTS tests"}
	{nobeaconratio "Disable BeaconRatio test"}
	{date.arg "" "Image date"}
	{apdate.arg "" "AP Image date"}
	{ap2date.arg "" "AP2 Image date"}
        {history.arg 30 "History size for control charts"}
	{perfloop.arg 1 "Performance test loops"}
	{loop.arg 1 "Main test loops"}
	{nounload "Don't unload driver after test"}
	{nocache "Don't update performance cache"}
	{nowep "No WEP security"}
	{noshared "No shared security"}
	{notkip "No TKIP security"}
	{noaes "No AES security"}
	{noopen "No Open security TCP perf tests"}
	{nobx "No Bidirectional Performance tests"}
	{symmetric "Don't need to test both directions"}
	{notdls "No TDLS tests"}
	{nointerrupts "No Interrupt tests"}
	{title.arg "" "Title"}
	{branch.arg "auto" "Branch override"}
        {logdir.arg "" "Log directory override"}
	{chanspec.arg "" "Override perfchans"}
	{nosetuptestbed "Don't run Setup Testbed hooks"}
	{noposttesthook "Don't run Post Test hooks"}
	{nocpu "No CPU tests"}
	{nochanswitch "No Chan Switch Times test"}
	{paironly "Only run tests involving two STAs"}
	{dual.nonly "Symmetric Dualband tests"}
	{chan.nonly "Channelsweep tests"}
	{custom.nonly "custom tests"}
	{perf.nonly "Performance tests"}
	{rate.nonly "Fixed Rate tests"}
	{rvr.nonly "RvR tests"}
	{security.arg "open"}
	{pm.nonly "Power Management tests"}
	{ibss.nonly "IBSS tests"}
	{bighammer.nonly "BigHammer tests"}
	{scan.nonly "scan tests"}
	{frag.nonly "fragmentation tests"}
	{cal.nonly "calibration tests"}
	{udp.nonly "UDP performance tests (UDP may still be used for rates/rvr if configured)"}
	{kpps.nonly "KPPS tests"}
	{titleap    "Use AP name in report & graph titles, default is STA name"}

}

# Setup online help info.
#UTF::setup_help $hal_commands_help $hal_commands_getopts

# Keep pkg_mkIndex happy
if {[info command __package_orig] != ""} {
    set ::argv ""
}

package require UTF
package require UTF::Test::APConfigureSecurity
package require UTF::Test::ChannelSweep
package require UTF::Test::ConnectAPSTA
package require UTF::Test::APChanspec



package provide UTF::Test::hal_commands 2.0

proc wifi_apply_test_suite {Router} {
    $Router wifi_api wifi_apply
}

proc convert_radio_idx_to_ap_idx {Router radio_idx} {

    if {$radio_idx < 2} {
        set ap_idx_return $radio_idx
    } elseif {$radio_idx == 2} {
        set ap_idx_return 16
    } else {
        set ap_idx_return 24
    }
    UTF::Message LOG "" "Index to return is $ap_idx_return"
    return $ap_idx_return
}

proc convert_ap_idx_to_radio_idx {Router ap_idx} {

    if {$ap_idx < 16} {
        set radio_idx_return [expr $ap_idx & 1]
    } else {
        set radio_idx_return [expr $ap_idx / 8]
    }
    UTF::Message LOG "" "Index to return is $radio_idx_return"
    return $radio_idx_return
}

proc retrieve_apidx_from_name {Router ap_name} {

    if {[string match -nocase "*wl0*" $ap_name]} {
	if {[string match -nocase "*wl0.*" $ap_name]} {
	    set name_int_temp [split $ap_name "."]
	    UTF::Message LOG "" "split temp is $name_int_temp"
	    set name_int_op [lindex [split $name_int_temp] end]

	    UTF::Message LOG "" "split output is $name_int_op"
	    set ap_idx_val [expr [name_int_op * 2]]
	} else {
	    set ap_idx_val 0
	}
    } elseif {[string match -nocase "*wl1*" $ap_name]} {
	if {[string match -nocase "*wl1.*" $ap_name]} {
	    set name_int_temp [split $ap_name "."]
	    UTF::Message LOG "" "split temp is $name_int_temp"
	    set name_int_op [lindex [split $name_int_temp] end]

	    UTF::Message LOG "" "split output is $name_int_op"
	    set ap_idx_val [expr [[name_int_op * 2] + 1]]
	} else {
	    set ap_idx_val 1
	}
    } elseif {[string match -nocase "*wl2*" $ap_name]} {
	if {[string match -nocase "*wl2.*" $ap_name]} {
	    set name_int_temp [split $ap_name "."]
	    UTF::Message LOG "" "split temp is $name_int_temp"
	    set name_int_op [lindex [split $name_int_temp] end]

	    UTF::Message LOG "" "split output is $name_int_op"
	    set ap_idx_val [expr 16 + $name_int_op]
	} else {
	    set ap_idx_val 16
	}
    } else {
	error "Interface name is not valid"
    }

    UTF::Message LOG "" "index value to be returned is $ap_idx_val"
    return $ap_idx_val
}

proc retrieve_ssid_from_name {Router ap_name} {

    if {[string match -nocase "*wl0*" $ap_name]} {
        if {[string match -nocase "*wl0.*" $ap_name]} {
            set name_int_temp [split $ap_name "."]
            UTF::Message LOG "" "split temp is $name_int_temp"
            set name_int_op [lindex [split $name_int_temp] end]

            UTF::Message LOG "" "split output is $name_int_op"
            set ap_idx_val [expr [name_int_op * 2]]
        } else {
            set ap_idx_val 0
        }
    } elseif {[string match -nocase "*wl1*" $ap_name]} {
        if {[string match -nocase "*wl1.*" $ap_name]} {
            set name_int_temp [split $ap_name "."]
            UTF::Message LOG "" "split temp is $name_int_temp"
            set name_int_op [lindex [split $name_int_temp] end]

            UTF::Message LOG "" "split output is $name_int_op"
            set ap_idx_val [expr [[name_int_op * 2] + 1]]
        } else {
            set ap_idx_val 1
        }
    } elseif {[string match -nocase "*wl2*" $ap_name]} {
        if {[string match -nocase "*wl2.*" $ap_name]} {
            set name_int_temp [split $ap_name "."]
            UTF::Message LOG "" "split temp is $name_int_temp"
            set name_int_op [lindex [split $name_int_temp] end]

            UTF::Message LOG "" "split output is $name_int_op"
            set ap_idx_val [expr 16 + $name_int_op]
        } else {
            set ap_idx_val 16
        }
    } else {
        error "Interface name is not valid"
    }

    set ssid_name [$Router wifi_api wifi_getSSIDName $ap_idx_val]
    UTF::Message LOG "" "index value to be returned is $ssid_name"
    return $ssid_name
}

proc extract_api_output {str_to_ext str_to_comp no_of_chars no_of_chars} {

    if {[string match -nocase *$str_to_comp* $str_to_ext]} {

        UTF::Message LOG "" "Comparision string matches extract string"
        set first_index [string first $str_to_comp $str_to_ext]
        set comp_str_len [string length $str_to_comp]

        set ext_start_index [expr $first_index + $comp_str_len]
        UTF::Message LOG "" "Index of the string to extract is $ext_start_index"

	if {$no_of_chars == 0} {
	    UTF::Message LOG "" "Read till end of line"
	    set return_op [lindex [split $lt] end]
	} else {
	    set return_op [string range $str_to_ext $ext_start_index [expr $ext_start_index + $no_of_chars]]
	}
	UTF::Message LOG "" "string to output is $return_op"
	return $return_op
    } else {
	error "Comparision string does not exist in output string"
    }

}


proc extract_wl_counter_output {wl_counters_op str_to_search num_chars} {

    if {[string match -nocase *$str_to_search* $wl_counters_op]} {

        UTF::Message LOG "" "Comparision string matches extract string"
        set first_index [string first $str_to_search $wl_counters_op]
        set comp_str_len [string length $str_to_search]

        set ext_start_index [expr $first_index + $comp_str_len]
        UTF::Message LOG "" "Index of the string to extract is $ext_start_index"

	set no_of_chars $num_chars

        if {$no_of_chars == 0} {
            UTF::Message LOG "" "Read till end of line"
            set return_op [lindex [split $lt] end]
        } else {
            set return_op [string range $wl_counters_op $ext_start_index [expr $ext_start_index + $no_of_chars]]
        }
        UTF::Message LOG "" "string to output is $return_op"
        return $return_op
    } else {
        error "Comparision string does not exist in output string"
    }
}

proc wifi_applyRadioSettingsHaltest {Radio idx} {
	UTF::Message LOG "" "wifi_applyRadioSettingsHaltest to execute $Radio $idx"
	$Radio wifi_applyRadioSettings $idx
	UTF::Sleep 2
}

proc extract_config_from_file {filename str_to_search} {

    set filedata [open $filename]

    while {[lgets $filedata line] >= 0} {

	if {[string match -nocase "*$str_to_search*" $line]} {

	    #UTF::Message LOG "" "FOUND matching $line"

            set first_index [string first $str_to_search $line]
            set file_data_len [string length $line]
	    #UTF::Message LOG "" "File data total length is $file_data_len first_index matched is $first_index"

	    set srch_str_len [string length $str_to_search]

            set ext_start_index [expr $first_index + $srch_str_len + 1]
            #UTF::Message LOG "" "Index of the string to extract is $ext_start_index"

	    set return_op [string range $line $ext_start_index $file_data_len]

	    return $return_op
	}
    }
    close $filedata
}

proc extract_value_from_string {str_orig to_search} {

    if {[string match -nocase "*$to_search*" $str_orig]} {

	UTF::Message LOG "" "FOUND matching parameter"

	set first_index [string first $to_search $str_orig]
	set string_len [string length $str_orig]
	UTF::Message LOG "" "File data total length is $string_len first_index matched is $first_index"

	#delimiter should be used and search the sapce
	set srch_str_len [string length $to_search]

	set ext_start_index [expr $first_index + $srch_str_len + 1]
	UTF::Message LOG "" "Index of the string to extract is $ext_start_index"

	set return_op [string range $str_orig $ext_start_index $file_data_len]

	UTF::Message LOG "" "return value is $return_op"
	return $return_op
    }
}

proc extract_value_from_nvram {filename str_to_search} {

    set filedata $filename

    while {[lgets $filedata line] >= 0} {

	if {[string match -nocase "*$str_to_search*" $line]} {

	    #UTF::Message LOG "" "FOUND matching $line"

            set first_index [string first $str_to_search $line]
            set file_data_len [string length $line]
	    #UTF::Message LOG "" "File data total length is $file_data_len first_index matched is $first_index"

	    set srch_str_len [string length $str_to_search]

            set ext_start_index [expr $first_index + $srch_str_len + 1]
            #UTF::Message LOG "" "Index of the string to extract is $ext_start_index"

	    set return_op [string range $line $ext_start_index $file_data_len]

	    return $return_op
	}
    }
}

proc intf_down_up_restart {Router intf_name intf_idx} {

    $Router wl -i $intf_name down
    UTF::Sleep 2
    $Router wl -i $intf_name radio on
    UTF::Sleep 2
    $Router wl -i $intf_name up
    UTF::Sleep 2

    set to_exec [convert_radio_idx_to_ap_idx $Router $intf_idx]
    set ssid_status_temp [$Router wifi_api wifi_getSSIDName $to_exec]

    set ssid_status_out [lindex [split $ssid_status_temp] end]

    UTF::Message LOG "" "intf_down_up_restart setting SSID $ssid_status_out"
    $Router wl -i $intf_name ssid $ssid_status_out
    UTF::Sleep 100
}

proc test_p2_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts

    puts "JST3:inside test_p2_commands "

    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(ap) 0]
    }

    UTF::Message LOG "" "JST4: Trying to execute P2 commands"

    set kk [$Router wifi_api wifi_getRadioNumberOfEntries]

    set num_radios [string index $kk end]

    puts "mum radios: $num_radios"

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    set acs_ver [extract_config_from_file $file_name "acs_ver"]

    if {$num_radios > 3} {
        UTF::Message ERROR "" "num_radios is not correct $num_radios"
        return
    }

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        UTF::Message LOG "" "Radio index: $idx"

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        } elseif {$idx == 2} {
                set radio_intf "6g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        }
#P2ADD#

#INT wifi_setBandSteeringEnable(BOOL enable)
UTF::Try "wifi_setBandSteeringEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bandsteer_en"]

    UTF::Message LOG "" "wifi_setBandSteeringEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringEnable $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set band_steer_en_temp [$Router wifi_api wifi_getBandSteeringEnable $idx]
    set wl_op [lindex [split $band_steer_en_temp] end]

    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#nvram show|grep bsd_ifnames
#bsd_ifnames=wl0 wl1
#nvram set bsd_role=1
#wifi_api wifi_getBandSteeringApGroup
#wifi_api wifi_getBandSteeringEnable
#wifi_api wifi_setBandSteeringEnable 1
#INT wifi_setBandSteeringBandUtilizationThreshold (INT radioIndex, INT buThreshold)
UTF::Try "wifi_setBandSteeringBandUtilizationThreshold_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bandsteer_util_thresh"]

    UTF::Message LOG "" "wifi_setBandSteeringBandUtilizationThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringBandUtilizationThreshold $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set bs_util_thresh_temp [$Router wifi_api wifi_getBandSteeringBandUtilizationThreshold $idx]
    set wl_op [lindex [split $bs_util_thresh_temp] end]

    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setBandSteeringRSSIThreshold (INT radioIndex, INT rssiThreshold)
UTF::Try "wifi_setBandSteeringRSSIThreshold_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bandsteer_rssi"]

    UTF::Message LOG "" "wifi_setBandSteeringRSSIThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringRSSIThreshold $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set bs_rssi_thresh_temp [$Router wifi_api wifi_getBandSteeringRSSIThreshold $idx]
    set wl_op [lindex [split $bs_rssi_thresh_temp] end]

    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

UTF::Try "wifi_getRadioPercentageTransmitPower_$radio_intf" {
    set wl_txpwr1_op_1 [$Router wl -i $if_name txpwr1]

    set txpwr_toset_q [lindex [split $wl_txpwr1_op_1 " "] 3]
    set txpwr_toset_d [lindex [split $wl_txpwr1_op_1 " "] 5]
    UTF::Message LOG "" "original value is $txpwr_toset_q $txpwr_toset_d"

    set radio_tx_pwr_op_1 [$Router wifi_api wifi_getRadioPercentageTransmitPower $idx]

    UTF::Message LOG "" "wifi_getRadioPercentageTransmitPower output is $radio_tx_pwr_op_1"

    if {[string match -nocase "*127*" $wl_txpwr1_op_1]} {

	$Router wl -i $if_name txpwr1 -q 110 -d 30
	set radio_tx_pwr_op_2 [$Router wifi_api wifi_getRadioPercentageTransmitPower $idx]

	if {$radio_tx_pwr_op_2 < $radio_tx_pwr_op_1} {
	    UTF::Message LOG "" "Matched values from wifi_getRadioPercentageTransmitPower"
	} else {
	    error "Not matching values from wifi_getRadioPercentageTransmitPower output $radio_tx_pwr_op_2"
	}
    } else {
	$Router wl -i $if_name txpwr1 -q 127 -d 31.75

	set radio_tx_pwr_op_2 [$Router wifi_api wifi_getRadioPercentageTransmitPower $idx]

	if {[string match -nocase "*127*" $radio_tx_pwr_op_2]} {
	    UTF::Message LOG "" "Matched values from wifi_getRadioPercentageTransmitPower"
	} else {
	    error "Not matching values from wifi_getRadioPercentageTransmitPower output $radio_tx_pwr_op_2"
	}
    }

    #reset
    $Router wl -i $if_name txpwr1 -q $txpwr_toset_q -d $txpwr_toset_d
}

#STUB FUNCTION
#INT wifi_setApAssociatedDevicesHighWatermarkThreshold(INT apIndex, UINT Threshold)
UTF::Try "wifi_setApAssociatedDevicesHighWatermarkThreshold_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "assoc_high_mark"]

    UTF::Message LOG "" "wifi_setApAssociatedDevicesHighWatermarkThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setApAssociatedDevicesHighWatermarkThreshold $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

#    set wl_op [$Router wifi_api wifi_getApAssociatedDevicesHighWatermarkThreshold $idx]
#    UTF::Message LOG "" "wl output is $wl_op"
    set wl_temp [$Router wl -i $if_name bss_maxassoc]
    set wl_op [lindex [split $wl_temp] 0]

    if {$radio_cnf >= $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    }

}

UTF::Try "wifi_getSSIDStatus_$radio_intf" {
    set ssid_status_temp [$Router wifi_api wifi_getSSIDStatus $idx]

    set ssid_status_out [lindex [split $ssid_status_temp] end]

    UTF::Message LOG "" "total output string length $ssid_status_out"

    set ssid_check [lindex [$Router wl -i $if_name ssid] end]

    if {[string match $ssid_status_out "Enabled"]} {

	if {[string match $ssid_check ""]} {
	    error "SSID NOT Matching output $ssid_status_out wl check is $ssid_check"
	} else {
	    UTF::Message LOG "" "SSID Matching strings $ssid_status_out"
	}
    } elseif {[string match $ssid_status_out "Up"]} {
	if {[string match $ssid_check ""]} {
	    error "SSID is disabled but wl shows $ssid_check"
	} else {
	    UTF::Message LOG "" "SSID is disabled"
	}
    } else {
	if {[string match $ssid_check ""]} {
	    UTF::Message LOG "" "SSID is disabled"
	} else {
	    error "SSID is disabled but wl shows $ssid_check"
	}
    }
}

UTF::Try "wifi_removeApSecVaribles_$radio_intf" {
    set remove_ap_sec_temp [$Router wifi_api wifi_removeApSecVaribles $idx]
    UTF::Sleep 120

    set remove_ap_sec_op [lindex [split $remove_ap_sec_temp] end]

    UTF::Message LOG "" "total output string length $remove_ap_sec_op"

    set wpa_auth [lindex [$Router wl -i $if_name wpa_auth] end]
# check wl0_akm=None
# check wl_akm=None

    if {[string match "*Disabled*" $wpa_auth]} {
	UTF::Message LOG "" "Authentication is reset to NULL"
    } else {
	#error "wpa_auth is not disabled $wpa_auth"
	UTF::Message LOG "" "STUB FUNCTION"
    }
}

if {$idx == 0} {
#hapd_conf 0 stop
#hapd_conf 0 start
#to stop HOST APD
UTF::Try "wifi_stopHostApd_$radio_intf" {
	$Router wifi_api wifi_stopHostApd
	UTF::Sleep 10
	#check against hostapd process
	## ps | grep hapd
	# 9089 admin     6096 S    hostapd -B /tmp/wl0_hapd.conf
	#  9206 admin     6096 S    hostapd -B /tmp/wl1_hapd.conf

	set apd_file_name "$path_info/Test/stop_hostapd_log"
	UTF::Message LOG "" "File name is $apd_file_name"
	set nvram_show [$Router nvram show]

	set nvram_show_file "$path_info/nvram_show.txt"
	set fp [open "nvram_show.txt" w+]
	puts $fp $nvram_show
	close $fp

	set chdir [$Router cd /rdklogs/logs]
	$Router pwd
	$Router ls
	if {[string match -nocase "*No such file or directory*" $chdir]} {
	    set chdir [$Router cd /data/rdklogs/logs]
	    if {[string match -nocase "*No such file or directory*" $chdir]} {
		#error "No logs directory exist to verify hostapd"
		 UTF::Message LOG "" "STUB FUNCTION"
	    }
	}
        if {$idx == 0} {
            set hapd_file /tmp/wl0_hapd.conf
        } elseif {$idx == 1} {
            set hapd_file /tmp/wl1_hapd.conf
        } elseif {$idx == 2} {
            set hapd_file /tmp/wl2_hapd.conf
        }
	set hapd_stop_temp [$Router cat $hapd_file]
	UTF::Message LOG "" "HAPD stop log $hapd_stop_temp"
	#check with  hapd_conf 0 start
	if {[string match -nocase "*hapd_conf $idx stop*" $hapd_stop_temp]} {
	    UTF::Message LOG "" "wl is up"
	} else {
	    #error "wl is not up"
	    UTF::Message LOG "" "STUB FUNCTION"
	}
}

#to start HOST APD
UTF::Try "wifi_startHostApd_$radio_intf" {
	$Router wifi_api wifi_startHostApd
	UTF::Sleep 10
	#check against hostapd process
	## ps | grep hapd
	# 9089 admin     6096 S    hostapd -B /tmp/wl0_hapd.conf
	#  9206 admin     6096 S    hostapd -B /tmp/wl1_hapd.conf

        set chdir [$Router cd /rdklogs/logs]
        if {[string match -nocase "*No such file or directory*" $chdir]} {
            set chdir [$Router cd /data/rdklogs/logs]
            if {[string match -nocase "*No such file or directory*" $chdir]} {
                error "No logs directory exist to verify hostapd"
            }
        }

        if {$idx == 0} {
            set hapd_file /tmp/wl0_hapd.conf
        } elseif {$idx == 1} {
            set hapd_file /tmp/wl1_hapd.conf
        } elseif {$idx == 2} {
            set hapd_file /tmp/wl2_hapd.conf
        }

        set hapd_start_temp [$Router cat $hapd_file]
	UTF::Message LOG "" "HAPD start log $hapd_start_temp"
	#check with  hapd_conf 0 start
	if {[string match -nocase "*driver*80211*" $hapd_start_temp]} {
	    UTF::Message LOG "" "wl is up"
	} else {
	    error "wl is not up"
	}
}

#INT wifi_createHostApdConfig(INT apIndex, BOOL createWpsCfg)
UTF::Try "wifi_createHostApdConfig_$radio_intf" {
	$Router wifi_api wifi_createHostApdConfig $idx

        set chdir [$Router cd /rdklogs/logs]
        if {[string match -nocase "*No such file or directory*" $chdir]} {
            set chdir [$Router cd /data/rdklogs/logs]
            if {[string match -nocase "*No such file or directory*" $chdir]} {
                #error "No logs directory exist to verify hostapd"
		UTF::Message LOG "" "STUB FUNCTION"
            }
        }

	if {$idx == 0} {
	    set hapd_file /tmp/wl0_hapd.conf
	} elseif {$idx == 1} {
            set hapd_file /tmp/wl1_hapd.conf
        } elseif {$idx == 2} {
            set hapd_file /tmp/wl2_hapd.conf
        }

	set hapd_start_temp [$Router cat $hapd_file]
	UTF::Message LOG "" "HAPD start log $hapd_start_temp"
	#check with  hapd_conf 0 start
	if {[string match -nocase "*hapd_conf $idx start*" $hapd_start_temp]} {
	    UTF::Message LOG "" "wl is up"
	} else {
	    #error "wl is not up"
	    UTF::Message LOG "" "STUB FUNCTION"
	}
}
}

#wifi_getApSecurityRadiusServer
UTF::Try "wifi_getApSecurityRadiusServer_$radio_intf" {

    set ap_sec_rad_ser_temp [$Router wifi_api wifi_getApSecurityRadiusServer  $idx]
    set ap_se_rad_ser_op [lindex [split $ap_sec_rad_ser_temp] end]
    UTF::Message LOG "" "wifi_getApSecurityRadiusServer is $ap_se_rad_ser_op"

    if {[string match -nocase "Radius server IP Address:0.0.0.0" $ap_sec_rad_ser_temp]} {
	error "Radius server has all IP Address:0.0.0.0"
    } else {
	 UTF::Message LOG "" "Radius server is up and running"
    }
}

#wifi_setRadioMode
#root@brcm93390smwvg2:~# wifi_api wifi_setRadioMode 1 "11ACVHT20" 0 0 1
#root@brcm93390smwvg2:~# wifi_api wifi_getRadioMode 1
#standards=ax pureMode=0x0
UTF::Try "wifi_setRadioMode_$radio_intf" {
    set radio_mode_cnf [extract_config_from_file $file_name "radio_mode_en"]

    set wl_temp [$Router wifi_api wifi_getRadioMode $idx]

    if {$idx == 0} {
        set band_cnf [extract_config_from_file $file_name "band_2g"]
    } elseif {$idx == 1} {
        set band_cnf [extract_config_from_file $file_name "band_5g"]
    } elseif {$idx == 2} {
        set band_cnf [extract_config_from_file $file_name "band_6g"]
    }

    if {[string match -nocase "*standards=n*" $wl_temp]} {
	set 11g_en 0
	set 11n_en 0
	set 11ac_en 1
	set band_cnf "11ACVHT20"
	set 11ax_en 0
    } elseif {[string match -nocase "*standards=ac*" $wl_temp]} {
	set 11g_en 0
	set 11ac_en 0
	if {$idx < 2} {
	    set 11ax_en 0
	    set 11n_en 1
	    set band_cnf "11NHT20"
	} elseif {$idx == 2} {
	    set 11ax_en 1
	    set 11n_en 0
	    set band_cnf "11AXVHT80"
	}
    } elseif {[string match -nocase "*standards=ax*" $wl_temp]} {
	set 11g_en 0
	set 11n_en 0
	set 11ac_en 1
	set band_cnf "11ACVHT20"
	set 11ax_en 0
    }

    UTF::Message LOG "" "wifi_setRadioMode is about to set $radio_mode_cnf"
    $Router wifi_api wifi_setRadioMode $idx $band_cnf $11g_en $11n_en $11ac_en $11ax_en
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_op [$Router wifi_api wifi_getRadioMode $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_mode_cnf == 1} {
	if {[string match -nocase "*pureMode=0x1*" $wl_op]} {
	    UTF::Message LOG "" "output from wifi_setRadioMode and wl matching"
	} elseif {[string match -nocase "*pureMode=0x4*" $wl_op]} {
            UTF::Message LOG "" "output from wifi_setRadioMode and wl matching"
	} elseif {[string match -nocase "*pureMode=0x0*" $wl_op]} {
            UTF::Message LOG "" "output from wifi_setRadioMode and wl matching"
        } else {
            error "output from wifi_setRadioMode and wl is not matching $radio_mode_cnf"
	}
    } else {
	if {[string match -nocase "*pureMode=0x0*" $wl_op]} {
	    UTF::Message LOG "" "output from wifi_setRadioMode and wl matching"
	} else {
            error "output from wifi_setRadioMode and wl is not matching $radio_mode_cnf"
	}
    }

#reset

    if {[string match -nocase "*standards=n*" $wl_temp]} {
	set 11g_en 0
	set 11n_en 1
	set 11ac_en 0
	set band_cnf "11NVHT20"
	set 11ax_en 0
    } elseif {[string match -nocase "*standards=ac*" $wl_temp]} {
	set 11g_en 0
	set 11n_en 0
	set 11ac_en 1
	set 11ax_en 0
	set band_cnf "11ACVHT20"
    } elseif {[string match -nocase "*standards=ax*" $wl_temp]} {
	set 11g_en 0
	set 11n_en 0
	set 11ac_en 0
	set band_cnf "11AXVHT20"
	set 11ax_en 1
    }
    UTF::Message LOG "" "wifi_setRadioMode is about to Reset"
    if {$idx == 0} {
	$Router wl -i $if_name bw_cap 2g
    } elseif {$idx == 1} {
	$Router wl -i $if_name bw_cap 5g
    } elseif {$idx == 2} {
        $Router wl -i $if_name bw_cap 6g
    }

    $Router wifi_api wifi_setRadioMode $idx $band_cnf $11g_en $11n_en $11ac_en $11ax_en
    UTF::Sleep 20

    if {$idx == 0} {
        $Router wl -i $if_name bw_cap 2g
    } elseif {$idx == 1} {
        $Router wl -i $if_name bw_cap 5g
    } elseif {$idx == 2} {
        $Router wl -i $if_name bw_cap 6g
    }
}

UTF::Try "wifi_getSSIDTrafficStats_$radio_intf" {
    set ssid_trf_stats_op [$Router wifi_api wifi_getSSIDTrafficStats $idx]

    if {[string match -nocase "*Aggregated Packet Count:*" $ssid_trf_stats_op]} {
        UTF::Message LOG "" "output from wifi_getSSIDTrafficStats are expected format"
    } else {
        error "output from wifi_getSSIDTrafficStats is not in expected format"
    }
}

UTF::Try "wifi_getWifiTrafficStats_$radio_intf" {

    set wifi_trf_stats_op [$Router wifi_api wifi_getWifiTrafficStats $idx]

    if {[string match -nocase "*Unicast Packets Sent*" $wifi_trf_stats_op]} {
        UTF::Message LOG "" "output from wifi_getWifiTrafficStats are expected format"
    } else {
        error "output from wifi_getWifiTrafficStats is not in expected format"
    }
}

#INT wifi_getRadioAutoChannelSupported(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioAutoChannelSupported_$radio_intf" {
    set auto_chan_supp_temp [$Router wifi_api wifi_getRadioAutoChannelSupported $idx]
    set auto_chan_supp_op [lindex [split $auto_chan_supp_temp] end]
    UTF::Message LOG "" "wifi_getRadioAutoChannelSupported output parsed is $auto_chan_supp_op"

    set wl_autochan_op [$Router $acs_ver -i $if_name info]
    UTF::Message LOG "" "wl output is $wl_autochan_op"

#root@brcm93390smwvg2:~# acs_cli2 -i wl0 info
#time: Wed Aug 11 01:37:30 2021
#
#acsd version: 2
#acsd ticks: 148830
#acsd poll_interval: 1 seconds
#ifname: wl0.1, mode: auto
#ifname: wl2, mode: auto
#
#
    if {$auto_chan_supp_op == 1} {
        if {[string match -nocase "*mode*monitor*" $wl_autochan_op]} {
            UTF::Message LOG "" "and wl output is matching as montiored"
        } else {
            error "and wl output is not matching with monitor"
        }
    } elseif {$auto_chan_supp_op == 0} {
        if {![string match -nocase "*mode*auto*" $wl_autochan_op]} {
            UTF::Message LOG "" "and wl output is matching not monitored"
        } else {
            error "and wl output is not matching with auto"
        }
    }
    if {$idx == 0} {
        $Router wl -i $if_name bw_cap 2g
    } elseif {$idx == 1} {
        $Router wl -i $if_name bw_cap 5g
    }  elseif {$idx == 2} {
        $Router wl -i $if_name bw_cap 6g
    }
}

#INT wifi_setRadioExtChannel(INT radioIndex, CHAR *string)
UTF::Try "wifi_setRadioExtChannel_$radio_intf" {


if {$idx == 0} {
    set act_channel_val [$Router wifi_api wifi_getRadioExtChannel $idx]

    set op_bw_actual [$Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx]

    set bw_cap_actual [$Router wl -i $if_name bw_cap 2g]
    set chan_to_set 0

    if {$act_channel_val <= 4 || $act_channel_val >= 10} {
        set chan_to_set 6

        $Router wifi_api wifi_setRadioChannel $idx $chan_to_set
	wifi_apply_test_suite $Router
        UTF::Sleep 10
    }

    if {[string match -nocase "*20MHz*" $op_bw_actual]} {
	set toset_op_bw_actual "40MHz"
	$Router wifi_api wifi_setRadioOperatingChannelBandwidth $idx $toset_op_bw_actual
	wifi_apply_test_suite $Router
	UTF::Sleep 10
    }

    $Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx
    set act_channel_val [$Router wifi_api wifi_getRadioChannel $idx]

    set act_val_change [$Router wifi_api wifi_getRadioExtChannel $idx]
    UTF::Message LOG "" "value after channel changes $act_val_change"

    if {[string match -nocase "*AboveControlChannel*" $act_val_change]} {
        set to_try_ext "BelowControlChannel"
    } elseif {[string match -nocase "*BelowControlChannel*" $act_val_change]} {
         set to_try_ext "AboveControlChannel"
    } else {
        error "Not a valid value $act_val_change"
    }

    UTF::Message LOG "" "wifi_setRadioExtChannel is about to set $to_try_ext"
    $Router wifi_api wifi_setRadioExtChannel $idx $to_try_ext
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set api_op [$Router wifi_api wifi_getRadioExtChannel $idx]
    if {[string match -nocase $api_op $to_try_ext]} {
        UTF::Message LOG "" "wifi_setRadioExtChannel and wl output is matching Above"
    } else {
        error "wifi_setRadioExtChannel and wl output is not matching $api_op"
    }


    $Router wifi_api wifi_getRadioChannel $idx

    #reset
    if {[string match -nocase "*20MHz*" $op_bw_actual]} {
        $Router wifi_api wifi_setRadioOperatingChannelBandwidth $idx $op_bw_actual
        UTF::Sleep 10
    }
    if {$chan_to_set != 0} {
	$Router wifi_api wifi_setRadioChannel $idx $act_channel_val
	UTF::Sleep 10
    }

    $Router wifi_api wifi_setRadioExtChannel $idx $act_val_change
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}
}

#INT wifi_setRadioGuardInterval(INT radioIndex, CHAR *string)
UTF::Try "wifi_setRadioGuardInterval_$radio_intf" {
    #trying to set 800nsec and reset to auto
    set radio_cnf [extract_config_from_file $file_name "sgi_tx"]

    set act_val [$Router wifi_api wifi_getRadioGuardInterval $idx]
    UTF::Message LOG "" "wifi_setRadioGuardInterval is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioGuardInterval $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

#root@brcm93390smwvg2:~# wl -i wl0 sgi_tx 0
#root@brcm93390smwvg2:~# wifi_api wifi_getRadioGuardInterval 0
#800nsec

    set wl_op [$Router wl -i $if_name sgi_tx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 0} {
	if {[string match -nocase "*3*" $wl_op]} {
	    UTF::Message LOG "" "and wl output is matching"
	} else {
	    error "and wl output is not matching more than 2"
	}
    }

    #reset
    if {[string match -nocase "Auto" $act_val]} {
	set wl_op [$Router wl -i $if_name sgi_tx -1]
	UTF::Sleep 2
    }
}

#INT wifi_setRadioCtsProtectionEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setRadioCtsProtectionEnable_$radio_intf" {

    set wl_actual [$Router wl -i $if_name nmode_protection_override]

    if {$wl_actual == 0} {
	set radio_cnf 1
    } else {
	set radio_cnf 0
    }
    UTF::Message LOG "" "wifi_setRadioCtsProtectionEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioCtsProtectionEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name nmode_protection_override]
    #set wl_op [$Router wl -i $if_name gmode_protection_cts] - Not SUPPORTED
    UTF::Message LOG "" "wl output is $wl_op"

#root@brcm93390smwvg2:~# wl -i wl0 nmode_protection_override
#-1
#root@brcm93390smwvg2:~# wifi_api wifi_setRadioCtsProtectionEnable 0 0
#root@brcm93390smwvg2:~# wl -i wl0 nmode_protection_override
#0
    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioCtsProtectionEnable and wl output is matching"
    } else {
	if {$wl_op == -1} {
            UTF::Message LOG "" "wifi_setRadioCtsProtectionEnable and wl output is matching AUTO"
	} else {
            error "wifi_setRadioCtsProtectionEnable and wl output is not matching"
	}
    }

    if {$wl_actual == -1} {
	set wl_actual 1
    }

    $Router wifi_api wifi_setRadioCtsProtectionEnable $idx $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_setRadioSTBCEnable(INT radioIndex, BOOL STBC_Enable)
UTF::Try "wifi_setRadioSTBCEnable_$radio_intf" {

if {$idx < 2} {
    set radio_cnf [extract_config_from_file $file_name "stbc_tx"]

    set wl_actual [$Router wl -i $if_name stbc_tx]

    UTF::Message LOG "" "wifi_setRadioSTBCEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioSTBCEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name stbc_tx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 1} {
        if {$wl_op != 0} {
            UTF::Message LOG "" "wifi_setRadioSTBCEnable and wl output is matching on"
        } else {
            error "wifi_setRadioSTBCEnable and wl output is not matching and 0"
        }
    } elseif {$radio_cnf == -1} {
        if {$wl_op != 0} {
            UTF::Message LOG "" "wifi_setRadioSTBCEnable and wl output is matching auto"
        } else {
            error "wifi_setRadioSTBCEnable and wl output is not matching and -1"
        }
    } else {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wifi_setRadioSTBCEnable and wl output is matching off"
        } else {
            error "wifi_setRadioSTBCEnable and wl output is not matching and 0"
        }
    }

    #reset
    if {$wl_actual == -1} {
	$Router wifi_api wifi_setRadioSTBCEnable $idx 1
    } else {
	$Router wifi_api wifi_setRadioSTBCEnable $idx 0
    }
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

}

#INT wifi_setRadioTxChainMask(INT radioIndex, INT numStreams)
UTF::Try "wifi_setRadioTxChainMask_$radio_intf" {

    set wl_actual_temp [$Router wl -i $if_name txchain]
    set wl_actual [lindex [split $wl_actual_temp] 0]

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "txchain_mask_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "txchain_mask_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "txchain_mask_6g"]
    }

    UTF::Message LOG "" "wifi_setRadioTxChainMask is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioTxChainMask $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5
    set wl_txchain_temp [$Router wl -i $if_name txchain]

    set wl_txchain_num [lindex [split $wl_txchain_temp] 0]

    set num_bits 0
    while {$wl_txchain_num} {

        set num_bits [expr $num_bits + [expr $wl_txchain_num & 1]]
        set temp $wl_txchain_num
        set wl_txchain_num [expr $temp >> 1]
    }

    UTF::Message LOG "" "output from num_bits is $num_bits"

    if {$num_bits == $radio_cnf} {
	UTF::Message LOG "" "output from wifi_setRadioTxChainMask is matching"
    } elseif {$num_bits == 3} {
	if {$radio_cnf == 7} {
            UTF::Message LOG "" "output from wifi_setRadioTxChainMask is matching"
	} else {
	    error "wifi_setRadioTxChainMask output and wl output is not matching"
	}
    } elseif {$num_bits == 2} {
        if {$radio_cnf == 3 || $radio_cnf == 5 || $radio_cnf == 6} {
            UTF::Message LOG "" "output from wifi_setRadioTxChainMask is matching"
        } else {
            error "wifi_setRadioTxChainMask output and wl output is not matching"
        }
    } elseif {$num_bits == 1} {
        if {$radio_cnf == 4 || $radio_cnf == 2 || $radio_cnf == 1} {
            UTF::Message LOG "" "output from wifi_setRadioTxChainMask is matching"
        } else {
            error "wifi_setRadioTxChainMask output and wl output is not matching"
        }
    } else {
	error "wifi_setRadioTxChainMask output and wl output is not matching"
    }

    $Router wl -i $if_name txchain $wl_actual
    UTF::Sleep 5
}

#INT wifi_setRadioRxChainMask(INT radioIndex, INT numStreams)
UTF::Try "wifi_setRadioRxChainMask_$radio_intf" {

    set wl_actual_temp [$Router wl -i $if_name rxchain]
    set wl_actual [lindex [split $wl_actual_temp] 0]

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "rxchain_mask_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "rxchain_mask_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "rxchain_mask_6g"]
    }

    set wl_rxchain_temp [$Router wl -i $if_name rxchain]

    set wl_rxchain_num [lindex [split $wl_rxchain_temp] 0]

    set num_bits_actual 0
    while {$wl_rxchain_num} {

        set num_bits_actual [expr $num_bits_actual + [expr $wl_rxchain_num & 1]]
        set temp $wl_rxchain_num
        set wl_rxchain_num [expr $temp >> 1]
    }

    if {$num_bits_actual == $radio_cnf} {
	UTF::Message LOG "" "wifi_setRadioRxChainMask radio_cnf and num bits are same"
	set radio_cnf [expr $num_bits_actual - 1]
    }
    UTF::Message LOG "" "wifi_setRadioRxChainMask is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioRxChainMask $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_rxchain_temp [$Router wl -i $if_name rxchain]

    set wl_rxchain_num [lindex [split $wl_rxchain_temp] 0]

    set num_bits 0
    while {$wl_rxchain_num} {

        set num_bits [expr $num_bits + [expr $wl_rxchain_num & 1]]
        set temp $wl_rxchain_num
        set wl_rxchain_num [expr $temp >> 1]
    }

    if {$num_bits == $radio_cnf} {
	UTF::Message LOG "" "output from wifi_setRadioRxChainMask is matching"
    } elseif {$num_bits == 3} {
        if {$radio_cnf == 7} {
            UTF::Message LOG "" "output from wifi_setRadioRxChainMask is matching"
        } else {
            error "wifi_setRadioRxChainMask output and wl output is not matching"
        }
    } elseif {$num_bits == 2} {
        if {$radio_cnf == 3 || $radio_cnf == 5 || $radio_cnf == 6} {
            UTF::Message LOG "" "output from wifi_setRadioRxChainMask is matching"
        } else {
            error "wifi_setRadioRxChainMask output and wl output is not matching"
        }
    } elseif {$num_bits == 1} {
        if {$radio_cnf == 4 || $radio_cnf == 2 || $radio_cnf == 1} {
            UTF::Message LOG "" "output from wifi_setRadioRxChainMask is matching"
        } else {
            error "wifi_setRadioRxChainMask output and wl output is not matching"
        }
    } else {
        error "wifi_setRadioRxChainMask output and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setRadioRxChainMask is about to set actual $wl_actual"
    $Router wifi_api wifi_setRadioRxChainMask $idx $num_bits_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_getRadio11nGreenfieldSupported(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadio11nGreenfieldSupported_$radio_intf" {
    set gf_supp_temp [$Router wifi_api wifi_getRadio11nGreenfieldSupported $idx]

    set gf_supp_op [lindex [split $gf_supp_temp] end]

    UTF::Message LOG "" "output from wifi_getRadio11nGreenfieldSupported is $gf_supp_op"

    set wl_mimo_preamble_op [$Router wl -i $if_name mimo_preamble]
    UTF::Message LOG "" "output from wl mimo_preamble is $wl_mimo_preamble_op"

    if {$gf_supp_op == $wl_mimo_preamble_op} {
	UTF::Message LOG "" "output from wifi_getRadio11nGreenfieldSupported and wl matching"
    } else {
	error "output from wifi_getRadio11nGreenfieldSupported and wl is not matching NOT SUPPORTED"
    }
}

#INT wifi_getRadio11nGreenfieldEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadio11nGreenfieldEnable_$radio_intf" {
    set gf_enable_temp [$Router wifi_api wifi_getRadio11nGreenfieldEnable $idx]

    set gf_enable_op [lindex [split $gf_enable_temp] end]

    UTF::Message LOG "" "output from wifi_getRadio11nGreenfieldEnable is $gf_enable_op"

    set wl_mimo_preamble_op [$Router wl -i $if_name mimo_preamble]
    UTF::Message LOG "" "output from wl mimo_preamble is $wl_mimo_preamble_op"

    if {$gf_enable_op == $wl_mimo_preamble_op} {
        UTF::Message LOG "" "output from wifi_getRadio11nGreenfieldEnable and wl matching"
    } elseif {$gf_enable_op == 0 && $wl_mimo_preamble_op == -1} {
        UTF::Message LOG "" "output from wifi_getRadio11nGreenfieldEnable 0 and wl Auto considered matching"
    } else {
	error "output from wifi_getRadio11nGreenfieldEnable and wl is not matching"
    }

}

#INT wifi_setRadio11nGreenfieldEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadio11nGreenfieldEnable_$radio_intf" {
    set gf_enable_temp [$Router wifi_api wifi_getRadio11nGreenfieldEnable $idx]

    set gf_enable_op [lindex [split $gf_enable_temp] end]

    if {$gf_enable_op == 0} {
	set radio_cnf "Enable"
    } else {
	set radio_cnf "Disable"
    }

    UTF::Message LOG "" "wifi_setRadio11nGreenfieldEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadio11nGreenfieldEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_op [$Router wifi_api wifi_getRadio11nGreenfieldEnable $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadio11nGreenfieldEnable and wl output is matching"
    }

    #reset
    $Router wifi_api wifi_setRadio11nGreenfieldEnable $idx $gf_enable_op
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}

#INT wifi_getIndexFromName(CHAR *inputSsidString, INT *ouput_int)
UTF::Try "wifi_getIndexFromName_$radio_intf" {

    set ap_idx_name_temp [$Router wifi_api wifi_getIndexFromName $if_name]
    set apd_idx_name_op [lindex [split $ap_idx_name_temp] end]

    set idx_cal [retrieve_apidx_from_name $Router $if_name]
    UTF::Message LOG "" "output from wifi_getIndexFromName is $apd_idx_name_op $idx_cal"

    if {$idx_cal == $apd_idx_name_op} {
        UTF::Message LOG "" "output from wifi_getIndexFromName and index matching"
    } else {
	error "output from wifi_getIndexFromName and index not matching"
    }
}

#INT wifi_setApRadioIndex(INT apIndex, INT radioIndex)
UTF::Try "wifi_setApRadioIndex_$radio_intf" {
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "ap_rad_idx_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "ap_rad_idx_5g"]
    } elseif {$ap_index == $to_exec} {
	set radio_cnf [extract_config_from_file $file_name "ap_rad_idx_6g"]
    }

    UTF::Message LOG "" "wifi_setApRadioIndex is about to set $radio_cnf"
    $Router wifi_api wifi_setApRadioIndex $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set get_api_temp [$Router wifi_api wifi_getApRadioIndex $ap_index]
    set get_api_op [convert_radio_idx_to_ap_idx $Router $get_api_temp]

    if {$radio_cnf == $get_api_op} {
	UTF::Message LOG "" "Index Matching"
    } else {
	error "Index NOT Matching"
    }
}

UTF::Try "wifi_getApMacAddressControlMode_$radio_intf" {

	set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
        set macmode_temp [$Router wifi_api wifi_getApMacAddressControlMode $to_exec]

        set macmode_output [lindex [split $macmode_temp] end]

        set macmode_check [lindex [$Router wl -i $if_name macmode] end]
        if {$macmode_output == 0} {
		if {$macmode_check == 0} {
		    UTF::Message LOG "" "wl output matching disabled"
		} else {
		    error "Radio macmode output mismatch $macmode_output $macmode_check"
		}
        } elseif {$macmode_output == 1} {
                if {$macmode_check == 2} {
                    UTF::Message LOG "" "wl output matching"
                } else {
		    error "Radio macmode output mismatch $macmode_output $macmode_check"
                }
        } elseif {$macmode_output == 2} {
                if {$macmode_check == 1} {
                    UTF::Message LOG "" "wl output matching disabled"
                } else {
		    error "Radio macmode output mismatch $macmode_output $macmode_check"
                }
        } else {
	    error "Radio macmode output mismatch $macmode_output $macmode_check"
	}
}

#INT wifi_pushApSsidAdvertisementEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_pushApSsidAdvertisementEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ssid_adv_en"]

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushApSsidAdvertisementEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_temp [$Router wifi_api wifi_getApSsidAdvertisementEnable $idx]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApMaxAssociatedDevices(INT apIndex, UINT number)
UTF::Try "wifi_setApMaxAssociatedDevices_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "max_assoc"]

    UTF::Message LOG "" "wifi_setApMaxAssociatedDevices is about to set $radio_cnf"
    $Router wifi_api wifi_setApMaxAssociatedDevices $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_max_assoc_temp [$Router wl -i $if_name bss_maxassoc]
    set wl_max_assoc [lindex [split $wl_max_assoc_temp] 0]
    UTF::Message LOG "" "bss_maxassoc value is $wl_max_assoc"

    if {$wl_max_assoc == $radio_cnf} {
        UTF::Message LOG "" "output from wl matching"
    }
#    else {
#        error "output from wifi_setApMaxAssociatedDevices and wl is not matching"
#    }
}

#INT wifi_setApSecurityRadiusServer(INT apIndex, CHAR *IPAddress, UINT port, CHAR *RadiusSecret)
#wifi_api wifi_setApSecurityRadiusServer 10 10.0.0.1 1 testing123-1' on xb7
UTF::Try "wifi_setApSecurityRadiusServer_$radio_intf" {
    set radious_ip_cnf [extract_config_from_file $file_name "radious_ip"]
    set radious_port_cnf [extract_config_from_file $file_name "radious_port"]
    set radious_sec_cnf [extract_config_from_file $file_name "radious_secret"]

    UTF::Message LOG "" "wifi_setApSecurityRadiusServer is about to set $radious_ip_cnf $radious_port_cnf $radious_sec_cnf"
    $Router wifi_api wifi_setApSecurityRadiusServer  $idx $radious_ip_cnf $radious_port_cnf $radious_sec_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set get_rad_api_op [$Router wifi_api wifi_getApSecurityRadiusServer  $idx]

    if {[string match -nocase "*$radious_ip_cnf*" $get_rad_api_op]} {
	UTF::Message LOG "" "output from wl matching"
    } else {
	error "output from wl not matching $get_rad_api_op"
    }

}

#INT wifi_setApSecuritySecondaryRadiusServer(INT apIndex, CHAR *IPAddress, UINT port, CHAR *RadiusSecret)
UTF::Try "wifi_setApSecuritySecondaryRadiusServer_$radio_intf" {
    set sec_radious_ip_cnf [extract_config_from_file $file_name "sec_radious_ip"]
    set sec_radious_port_cnf [extract_config_from_file $file_name "sec_radious_port"]
    set sec_radious_sec_cnf [extract_config_from_file $file_name "sec_radious_secret"]


    UTF::Message LOG "" "wifi_setApSecuritySecondaryRadiusServer is about to set $sec_radious_ip_cnf $sec_radious_port_cnf $sec_radious_sec_cnf"
    $Router wifi_api wifi_setApSecuritySecondaryRadiusServer $idx $sec_radious_ip_cnf $sec_radious_port_cnf $sec_radious_sec_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_op [$Router wl -i $if_name isup]
    UTF::Message LOG "" "wl output is $wl_op"

    set get_temp [$Router wifi_api wifi_getApSecuritySecondaryRadiusServer $idx]
#  Secondary Radius server IP Address:
#  Secondary Radius server Port:0
#  Secondary Radius server Secret Key:

    if {[string match -nocase "*$sec_radious_ip_cnf*" $get_temp]} {
        UTF::Message LOG "" "Get output is matching"
    } else {
        error "Get output is not matching"
    }
}

#INT wifi_getBandSteeringBandUtilizationThreshold (INT radioIndex, INT *pBuThreshold)
UTF::Try "wifi_getBandSteeringBandUtilizationThreshold_$radio_intf" {

    set bs_util_thresh_temp [$Router wifi_api wifi_getBandSteeringBandUtilizationThreshold $idx]
    set bs_util_thresh_op [lindex [split $bs_util_thresh_temp] end]

    UTF::Message LOG "" "output from wifi_getBandSteeringBandUtilizationThreshold is $bs_util_thresh_op"

    set wl_mesh_op [$Router wl -i $if_name bs_data]
#root@brcm93390smwvg2:/rdklogs/logs# wl -i wl0 bs_data
#  Station Address        PHY Mbps  Data Mbps    Air Use   Data Use    Retries   bw   mcs   Nss   ofdma mu-mimo
#  00:10:18:FB:D8:26        0.0        0.0       0.0%       0.0%       0.0%      -     -     -    0.0%    0.0%
#          (overall)          -        0.0       0.0%         -         -
#

    if {[string match -nocase "*No stations are currently associated*" $wl_mesh_op]} {
	UTF::Message LOG "" "No STA is associated"
    } else {
	if {$idx == 0} {
	    set assoc_sta [extract_config_from_file $file_name "rssi_MAC_2g"]
	} elseif {$idx == 1} {
            set assoc_sta [extract_config_from_file $file_name "rssi_MAC_5g"]
        } elseif {$idx == 2} {
            set assoc_sta [extract_config_from_file $file_name "rssi_MAC_6g"]
	}

	if {[string match -nocase "*$assoc_sta*" $wl_mesh_op]} {
	    UTF::Message LOG "" "output from wifi_getBandSteeringBandUtilizationThreshold and wl matching"
	} else {
	    error "output from wifi_getBandSteeringBandUtilizationThreshold and wl is not matching WL NOT SUPPORTED"
	}
    }

}

#INT wifi_getBandSteeringCapability(BOOL *support)
UTF::Try "wifi_getBandSteeringCapability_$radio_intf" {
    set band_steer_cap_temp [$Router wifi_api wifi_getBandSteeringCapability $idx]
    set band_steer_cap_op [lindex [split $band_steer_cap_temp] end]

    UTF::Message LOG "" "output from wifi_getBandSteeringCapability is $band_steer_cap_op"

    #set wl_mesh_op [$Router wl -i $if_name mesh]

    if {$band_steer_cap_op == 1} {
        UTF::Message LOG "" "output from wifi_getBandSteeringCapability and wl matching"
    } else {
        error "output from wifi_getBandSteeringCapability and wl is not matching"
    }

}

#INT wifi_getBandSteeringEnable(BOOL *enable)
UTF::Try "wifi_getBandSteeringEnable_$radio_intf" {
    set band_steer_en_temp [$Router wifi_api wifi_getBandSteeringEnable $idx]
    set band_steer_en_op [lindex [split $band_steer_en_temp] end]

    UTF::Message LOG "" "output from wifi_getBandSteeringEnable is $band_steer_en_op"

    if {$band_steer_en_op == 0} {
        UTF::Message LOG "" "output from wifi_getBandSteeringEnable and wl matching Disabled"
    } elseif {$band_steer_en_op == 1} {
        UTF::Message LOG "" "output from wifi_getBandSteeringEnable and wl matching Enabled"
    } else {
        UTF::Message LOG "" "output from wifi_getBandSteeringEnable and wl is not matching WL NOT SUPPORTED"
    }

}

#STUB FUNCTION
#INT wifi_getRadioDcsScanning(INT radioIndex)
UTF::Try "wifi_getRadioDcsScanning_$radio_intf" {

    set radio_dcs_scan_temp [$Router wifi_api wifi_getRadioDcsScanning $idx]
    set radio_dcs_scan_op [lindex [split $radio_dcs_scan_temp] end]
    UTF::Message LOG "" "wifi_getRadioDcsScanning is $radio_dcs_scan_op"

#    if {$radio_dcs_scan_op == 0} {
#        UTF::Message LOG "" "wl output is matching"
#    } else {
#        error "wl output is not matching"
#    }

}

#INT wifi_getBandSteeringPhyRateThreshold (INT radioIndex, INT *pPrThreshold)
UTF::Try "wifi_getBandSteeringPhyRateThreshold_$radio_intf" {
    set bs_phyrate_temp [$Router wifi_api wifi_getBandSteeringPhyRateThreshold $idx]
    set bs_phyrate_op [lindex [split $bs_phyrate_temp] end]

    UTF::Message LOG "" "output from wifi_getBandSteeringPhyRateThreshold is $bs_phyrate_op"

    set wl_mesh_op [$Router wl -i $if_name bs_data]
#root@brcm93390smwvg2:/rdklogs/logs# wl -i wl0 bs_data
#  Station Address        PHY Mbps  Data Mbps    Air Use   Data Use    Retries   bw   mcs   Nss   ofdma mu-mimo
#  00:10:18:FB:D8:26        0.0        0.0       0.0%       0.0%       0.0%      -     -     -    0.0%    0.0%
#          (overall)          -        0.0       0.0%         -         -
#

    if {[string match -nocase "No stations*" $wl_mesh_op]} {
	UTF::Message LOG "" "No STA is associated"
    } else {
	if {$idx == 0} {
	    set assoc_sta [extract_config_from_file $file_name "rssi_MAC_2g"]
	} elseif {$idx == 1} {
            set assoc_sta [extract_config_from_file $file_name "rssi_MAC_5g"]
        } elseif {$idx == 2} {
            set assoc_sta [extract_config_from_file $file_name "rssi_MAC_6g"]
	}

	if {[string match -nocase "*$assoc_sta*" $wl_mesh_op]} {
	    UTF::Message LOG "" "output from wifi_getBandSteeringPhyRateThreshold and wl matching"
	} else {
	    error "output from wifi_getBandSteeringPhyRateThreshold and wl is not matching WL NOT SUPPORTED $wl_op $assoc_sta"
	}
	UTF::Message LOG "" "No STA with MAC address $assoc_sta is associated"
    }

}

#INT wifi_getBandSteeringRSSIThreshold (INT radioIndex, INT *pRssiThreshold)
UTF::Try "wifi_getBandSteeringRSSIThreshold_$radio_intf" {
    set bs_rssi_thresh_temp [$Router wifi_api wifi_getBandSteeringRSSIThreshold $idx]
    set bs_rsssi_thresh_op [lindex [split $bs_rssi_thresh_temp] end]

    UTF::Message LOG "" "output from wifi_getBandSteeringRSSIThreshold is $bs_rsssi_thresh_op"

    set wl_mesh_op [$Router wl -i $if_name bs_data]
#root@brcm93390smwvg2:/rdklogs/logs# wl -i wl0 bs_data
#  Station Address        PHY Mbps  Data Mbps    Air Use   Data Use    Retries   bw   mcs   Nss   ofdma mu-mimo
#  00:10:18:FB:D8:26        0.0        0.0       0.0%       0.0%       0.0%      -     -     -    0.0%    0.0%
#          (overall)          -        0.0       0.0%         -         -
#

    if {[string match -nocase "No stations*" $wl_mesh_op]} {
	UTF::Message LOG "" "No STA is associated"
    } else {
	if {$idx == 0} {
	    set assoc_sta [extract_config_from_file $file_name "rssi_MAC_2g"]
	} elseif {$idx == 1} {
            set assoc_sta [extract_config_from_file $file_name "rssi_MAC_5g"]
        } elseif {$idx == 2} {
	    set assoc_sta [extract_config_from_file $file_name "rssi_MAC_6g"]
	}

	if {[string match -nocase "*$assoc_sta*" $wl_mesh_op]} {
	    UTF::Message LOG "" "output from wifi_getBandSteeringRSSIThreshold and wl matching"
	} else {
	    error "output from wifi_getBandSteeringRSSIThreshold and wl is not matching WL NOT SUPPORTED"
	}
    }

}

#INT wifi_getATMCapable(BOOL *output_bool)
UTF::Try "wifi_getATMCapable_$radio_intf" {
    set ap_atm_cap_temp [$Router wifi_api wifi_getATMCapable $idx]
    set ap_atm_cap_op [lindex [split $ap_atm_cap_temp] end]

    UTF::Message LOG "" "output from wifi_getATMCapable is $ap_atm_cap_op"

    #CHECK the right wl command
    set wl_atf_op [$Router wl -i $if_name atf]

    if {[string match -nocase "FALSE" $ap_atm_cap_op]} {
	if {$wl_atf_op == 0} {
            UTF::Message LOG "" "output from wifi_getATMCapable and wl matching"
	} else {
            #error "output from wifi_getATMCapable and wl is not matching"
	    UTF::Message LOG "" "STUB FUNCTION"
	}
    } else {
	if {$wl_atf_op >= 1} {
            UTF::Message LOG "" "output from wifi_getATMCapable and wl matching"
	} else {
	    UTF::Message LOG "" "STUB FUNCTION"
            #error "output from wifi_getATMCapable and wl is not matching"
	}
    }
}

#INT wifi_pushRadioChannel(INT radioIndex, UINT channel)
UTF::Try "wifi_pushRadioChannel_$radio_intf" {

    set wl_actual_temp [$Router wl -i $if_name channel]
    set wl_actual [lindex [split $wl_actual_temp] end]
    UTF::Message LOG "" "original value is $wl_actual"

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "push_channel_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "push_channel_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "push_channel_6g"]
    }

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushRadioChannel $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20
    intf_down_up_restart $Router $if_name $idx

    set wl_temp [$Router wl -i $if_name status]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*Primary channel: $radio_cnf*" $wl_temp]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

    #reset
    $Router wl -i $if_name channel
    UTF::Sleep 2
}

#INT wifi_pushRadioChannel2(INT radioIndex, UINT channel, UINT channel_width_MHz, UINT csa_beacon_count)
UTF::Try "wifi_pushRadioChannel2_$radio_intf" {

    set wl_actual_temp [$Router wl -i $if_name channel]
    set wl_actual [lindex [split $wl_actual_temp] end]
    UTF::Message LOG "" "original value is $wl_actual"

    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "push_channel2_2g"]
        set radio_cnf_bw [extract_config_from_file $file_name "push_channel2_bw_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "push_channel2_5g"]
        set radio_cnf_bw [extract_config_from_file $file_name "push_channel2_bw_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "push_channel2_6g"]
        set radio_cnf_bw [extract_config_from_file $file_name "push_channel2_bw_6g"]
    }

    set radio_cnf_bcn [extract_config_from_file $file_name "push_channel2_csa_bcn"]

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushRadioChannel2 $idx $radio_cnf $radio_cnf_bw $radio_cnf_bcn
    UTF::Sleep 5

    set wl_temp [$Router wl -i $if_name status]

    if {[string match -nocase "*Primary channel: $radio_cnf*" $wl_temp]} {
        UTF::Message LOG "" "wl output is matching"
    }

    #reset
    $Router wl -i $if_name channel
    UTF::Sleep 2
}

#INT wifi_getRadioDcsChannelMetrics(INT radioIndex, wifi_channelMetrics_t *input_output_channelMetrics_array, INT array_size)
UTF::Try "wifi_getRadioDcsChannelMetrics_$radio_intf" {
    set ap_dcs_chan_met_temp [$Router wifi_api wifi_api wifi_getRadioDcsChannelMetrics $idx]
    set ap_dcs_chan_met_op [lindex [split $ap_dcs_chan_met_temp] end]

    UTF::Message LOG "" "output from wifi_api wifi_getRadioDcsChannelMetrics is $ap_dcs_chan_met_op"

    set wl_dcs_dwell_op [$Router wl -i $if_name scan_passive_time]

    if {$ap_dcs_chan_met_op == $wl_dcs_dwell_op} {
        UTF::Message LOG "" "output from wifi_api wifi_getRadioDcsChannelMetrics and wl matching"
    } else {
	UTF::Message LOG "" "NOT SUPPORTED"
#        error "output from wifi_api wifi_getRadioDcsChannelMetrics and wl is not matching"
    }

}

#INT wifi_getRadioChannelStats(INT radioIndex, wifi_channelStats2_t *outputChannelStats2)
UTF::Try "wifi_getRadioChannelStats_$radio_intf" {
    set chan_stats_temp [$Router wifi_api wifi_getRadioChannelStats $idx]

    UTF::Message LOG "" "output from wifi_getRadioChannelStats is $chan_stats_temp"

#    set wl_chanim_stats_op [$Router wl -i $if_name chanim_stats]

    #TODEVELOP
    if {[string match -nocase "*channels with stats:*" $chan_stats_temp]} {
        UTF::Message LOG "" "output from wifi_getRadioChannelStats and wl matching"
    } else {
        error "output from wifi_getRadioChannelStats and wl is not matching"
    }

}

#INT wifi_getRadioChannelStats2(INT radioIndex, wifi_channelStats2_t *outputChannelStats2)
UTF::Try "wifi_getRadioChannelStats2_$radio_intf" {
    set chan_stats_temp [$Router wifi_api wifi_getRadioChannelStats2 $idx]

    UTF::Message LOG "" "output from wifi_getRadioChannelStats2 is $chan_stats_temp"

#    set wl_chanim_stats_op [$Router wl -i $if_name chanim_stats]

    #TODEVELOP
    if {[string match -nocase "*Center Frequency*" $chan_stats_temp]} {
        UTF::Message LOG "" "output from wifi_getRadioChannelStats and wl matching"
    } else {
        error "output from wifi_getRadioChannelStats and wl is not matching"
    }

}

UTF::Try "wifi_getApAssociatedDeviceRxStatsResult_$radio_intf" {

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_list]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceRxStatsResult $idx $radio_cnf]

	    if {[string match -nocase "*invalid argument*" $get_rssi_temp]} {
		error "wifi_getApAssociatedDeviceRxStatsResult invalid argument"
	    } else {
		set get_rssi_op [lindex [split $get_rssi_temp] end]

		set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

		if {[string match -nocase "*handle*" $get_rssi_temp]} {
		    UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceRxStatsResult wl output"
		} else {
		    error "wifi_getApAssociatedDeviceRxStatsResult output and get_rssi_op output is not matching"
		}
		UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
		#string to compare is
		set smooth_rssi_temp "rx data pkts:"
		UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
		#Need to verify against smoothed rssi value
		if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		    UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceRxStatsResult wl output"
		} else {
		    error "wifi_getApAssociatedDeviceRxStatsResult output and wl output is not matching"
		}
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {
	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceRxStatsResult $idx $radio_cnf]
        if {[string match -nocase "*invalid argument*" $get_rssi_temp]} {
            error "wifi_getApAssociatedDeviceRxStatsResult invalid argument"
        } else {
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    if {[string match -nocase "*handle*" $get_rssi_temp]} {
		UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceRxStatsResult wl output"
	    } else {
		error "wifi_getApAssociatedDeviceRxStatsResult output and get_rssi_op output is not matching"
	    }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "rx data pkts:"
	    UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceRxStatsResult wl output"
	    } else {
		error "wifi_getApAssociatedDeviceRxStatsResult output and wl output is not matching"
	    }
	}
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApAssociatedDeviceRxStatsResult no STA with $radio_cnf is in associated list"
    }
}

UTF::Try "wifi_getApAssociatedDeviceTxStatsResult_$radio_intf" {

#output_array_size: 5
#handle (x64) = 0x2
#[i bw nss mcs] flag byte msdu mpdu ppdu retr attempts
#0 20 0 0 0x2 0 1 0 0 0 0
#1 80 3 6 0x2 0 13 0 0 0 0
#2 80 3 7 0x2 0 9 0 0 0 0
#3 80 3 8 0x2 0 283 0 0 0 0
#4 80 3 9 0x2 0 614 0 0 0 0
#
#
#root@brcm93390smwvg2:~# wl -i wl0 sta_info 00:10:18:F8:F0:54
#[VER 8] STA 00:10:18:F8:F0:54:
#         chanspec 1 (0x1001)
#         aid:16
#         rateset [ 1 2 5.5 6 9 11 12 18 24 36 48 54 ]
#         idle 0 seconds
#         in network 0 seconds
#         state: AUTHENTICATED ASSOCIATED
#         connection: SECURED
#         auth: WPA2-PSK
#         crypto: NONE
#         flags 0x1e01b: BRCM WME N_CAP AMPDU AMSDU
#         HT caps 0x9bc:  GF SGI20 STBC-Tx STBC-Rx
#         tx total pkts: 7
#         tx total bytes: 564
#         tx ucast pkts: 0
#         tx ucast bytes: 0
#         tx mcast/bcast pkts: 7
#         tx mcast/bcast bytes: 564
#         tx failures: 0
#         rx data pkts: 0
#         rx data bytes: 0
#         rx data dur: 0
#         rx ucast pkts: 0
#         rx ucast bytes: 0
#         rx mcast/bcast pkts: 0
#         rx mcast/bcast bytes: 0
#         rate of last tx pkt: 0 kbps - 1000 kbps
#         rate of last rx pkt: 0 kbps
#         rx decrypt succeeds: 0
#         rx decrypt failures: 0
#         tx data pkts retried: 0
#         per antenna rssi of last rx data frame: -45 -39 -77 0
#         per antenna average rssi of rx data frames: -45 -39 -77 0
#         per antenna noise floor: -86 -88 -97 0
#         tx total pkts sent: 2
#         tx pkts retries: 0
#         tx pkts retry exhausted: 0
#         tx FW total pkts sent: 0
#         tx FW pkts retries: 0
#         tx FW pkts retry exhausted: 0
#         rx total pkts retried: 0
#MCS SET : [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ]
#smoothed rssi: -39
#tx nrate
#auto
#rx nrate
#auto
#wnm
#0x0:
#link bandwidth = 20 MHZ
#RRM capability = 0x0
#Frequency Bands Supported:

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_list]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceTxStatsResult $idx $radio_cnf]
            if {[string match -nocase "*invalid argument*" $get_rssi_temp]} {
                error "wifi_getApAssociatedDeviceTxStatsResult invalid argument"
            } else {
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    if {[string match -nocase "*handle*" $get_rssi_temp]} {
                UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceTxStatsResult wl output"
            } else {
                error "wifi_getApAssociatedDeviceTxStatsResult output and get_rssi_op output is not matching"
            }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "tx total pkts:"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceTxStatsResult wl output"
	    } else {
	        error "wifi_getApAssociatedDeviceTxStatsResult output and wl output is not matching"
	    }
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceTxStatsResult $idx $radio_cnf]
        if {[string match -nocase "*invalid argument*" $get_rssi_temp]} {
            error "wifi_getApAssociatedDeviceTxStatsResult invalid argument"
        } else {
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

            if {[string match -nocase "*handle*" $get_rssi_temp]} {
                UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceTxStatsResult wl output"
            } else {
                error "wifi_getApAssociatedDeviceTxStatsResult output and get_rssi_op output is not matching"
            }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "tx data pkts:"
	    UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceTxStatsResult wl output"
	    } else {
		error "wifi_getApAssociatedDeviceTxStatsResult output and wl output is not matching"
	    }
	}
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApAssociatedDeviceTxStatsResult no STA with $radio_cnf is in associated list"
    }
}

UTF::Try "wifi_getApAssociatedDeviceStats_$radio_intf" {

#
# wifi_api wifi_getApAssociatedDeviceStats  0 00:10:18:F8:F
#wifi_getApAssociatedDeviceStats(0 00:10:18:F8:F0:54)
#  handle                         (x64) = 0x0
#  cli_rx_bytes                   (u64) = 0
#  cli_tx_bytes                   (u64) = 606
#  cli_rx_frames                  (u64) = 0
#  cli_tx_frames                  (u64) = 7
#  cli_rx_retries                 (u64) = 0
#  cli_tx_retries                 (u64) = 0
#  cli_rx_errors                  (u64) = 0
#  cli_tx_errors                  (u64) = 0
#  cli_rx_rate                    (dbl) = 0.00
#  cli_tx_rate                    (dbl) = 0.00

#
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_list]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceStats $idx $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

            if {[string match -nocase "*cli_rx_errors*" $get_rssi_temp]} {
                UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceTxStatsResult wl output"
            } else {
                error "wifi_getApAssociatedDeviceTxStatsResult output and get_rssi_op output is not matching"
            }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "smoothed rssi:"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceStats wl output"
	    } else {
	        error "wifi_getApAssociatedDeviceStats output and wl output is not matching"
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceStats $idx $radio_cnf]
	set get_rssi_op [lindex [split $get_rssi_temp] end]

	if {[string match -nocase "*cli_rx_errors*" $get_rssi_temp]} {
	    UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceTxStatsResult wl output"
	} else {
	    error "wifi_getApAssociatedDeviceTxStatsResult output and get_rssi_op output is not matching"
	}
	set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	#string to compare is
	set smooth_rssi_temp "smoothed rssi:"
	UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	#Need to verify against smoothed rssi value
	if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceStats wl output"
	} else {
		error "wifi_getApAssociatedDeviceStats output and wl output is not matching"
	}
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApAssociatedDeviceStats no STA with $radio_cnf is in associated list"
    }
}

#INT wifi_getApAssociatedDeviceDiagnosticResult(INT apIndex, wifi_associated_dev3_t **associated_dev_array, UINT *output_array_size)
UTF::Try "wifi_getApAssociatedDeviceDiagnosticResult_$radio_intf" {

#00:10:18:F8:F0:54mwvg2:~# wifi_api wifi_getApAssociatedDeviceDiagnosticResult 0 00:
#Total_STA:1

#sta_1: cli_MACAddress                   :00:10:18:F8:F0:54
#sta_1: cli_AuthenticationState          :1
#sta_1: cli_LastDataDownlinkRate         :0
#sta_1: cli_LastDataUplinkRate           :0
#sta_1: cli_SignalStrength               :-40
#sta_1: cli_Retransmissions              :1
#sta_1: cli_OperatingStandard            :n
#sta_1: cli_OperatingChannelBandwidth    :20
#sta_1: cli_SNR                          :46
#sta_1: cli_DataFramesSentAck            :2
#sta_1: cli_DataFramesSentNoAck          :1
#sta_1: cli_RSSI                         :-40
#sta_1: cli_Disassociations              :0
#sta_1: cli_AuthenticationFailures       :0

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_list]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceDiagnosticResult $idx $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    if {[string match -nocase "*$radio_cnf*" $get_rssi_temp]} {
		UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceDiagnosticResult wl output"
	    } else {
		error "wifi_getApAssociatedDeviceDiagnosticResult output and get_rssi_op output is not matching"
	    }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "smoothed rssi:"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceDiagnosticResult wl output"
	    } else {
	        error "wifi_getApAssociatedDeviceDiagnosticResult output and wl output is not matching"
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceDiagnosticResult $idx $radio_cnf]
	set get_rssi_op [lindex [split $get_rssi_temp] end]

	if {[string match -nocase "*$radio_cnf*" $get_rssi_temp]} {
	    UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceDiagnosticResult wl output"
	} else {
	    error "wifi_getApAssociatedDeviceDiagnosticResult output and get_rssi_op output is not matching"
	}
	set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	#string to compare is
	set smooth_rssi_temp "smoothed rssi:"
	UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	#Need to verify against smoothed rssi value
	if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceDiagnosticResult wl output"
	} else {
		error "wifi_getApAssociatedDeviceDiagnosticResult output and wl output is not matching"
	}
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApAssociatedDeviceDiagnosticResult no STA with $radio_cnf is in associated list"
    }
}

UTF::Try "wifi_getApAssociatedDeviceDiagnosticResult2_$radio_intf" {

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_list]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceDiagnosticResult2 $idx $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    if {[string match -nocase "*$radio_cnf*" $get_rssi_temp]} {
		UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceDiagnosticResult2 wl output"
	    } else {
		error "wifi_getApAssociatedDeviceDiagnosticResult2 output and get_rssi_op output is not matching"
	    }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "smoothed rssi:"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceDiagnosticResult2 wl output"
	    } else {
	        error "wifi_getApAssociatedDeviceDiagnosticResult2 output and wl output is not matching"
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	set get_rssi_temp [$Router wifi_api wifi_getApAssociatedDeviceDiagnosticResult2 $idx $radio_cnf]
	set get_rssi_op [lindex [split $get_rssi_temp] end]

	if {[string match -nocase "*$radio_cnf*" $get_rssi_temp]} {
	    UTF::Message LOG "" "output from get_rssi_op matching wifi_getApAssociatedDeviceDiagnosticResult2 wl output"
	} else {
	    error "wifi_getApAssociatedDeviceDiagnosticResult2 output and get_rssi_op output is not matching"
	}
	set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	#string to compare is
	set smooth_rssi_temp "smoothed rssi:"
	UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	#Need to verify against smoothed rssi value
	if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApAssociatedDeviceDiagnosticResult2 wl output"
	} else {
		error "wifi_getApAssociatedDeviceDiagnosticResult2 output and wl output is not matching"
	}
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApAssociatedDeviceDiagnosticResult2 no STA with $radio_cnf is in associated list"
    }
}

#INT wifi_getRadioBandUtilization (INT radioIndex, INT *output_percentage)
UTF::Try "wifi_getRadioBandUtilization_$radio_intf" {
    set band_util_temp [$Router wifi_api wifi_getRadioBandUtilization $idx]
    set band_util_op [lindex [split $band_util_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioBandUtilization is $band_util_op"
    set value_to_check [expr 100 - $band_util_op]

    set wl_radar_op [$Router wl -i $if_name chanim_stats]

    set chan 0
    foreach j $wl_radar_op {
        puts "$j STA from assoclist is $chan in list"
        incr chan
    }

    if {[string match -nocase "*$value_to_check*" $wl_radar_op]} {
	UTF::Message LOG "" "output from wifi_getRadioBandUtilization and wl matching"
    }
}

#INT wifi_getApAssociatedDevice(INT ap_index, CHAR *output_buf, INT output_buf_size)
UTF::Try "wifi_getApAssociatedDevice_$radio_intf" {

    set no_of_assoc_stas_output [$Router wifi_api wifi_getApAssociatedDevice $idx]

    set no_of_assoc_stas 0
    foreach j $no_of_assoc_stas_output {
	incr no_of_assoc_stas
    }

    UTF::Message LOG "" "The number of Associated STAs in $if_name is $no_of_assoc_stas"

    set assoclist_output [$Router wl -i $if_name assoclist]
    UTF::Message LOG "" "wl assoclist output is $assoclist_output"

    #split based on newline
    set assoclist_split [split $assoclist_output "\n"]
    UTF::Message LOG "" "wl assoclist split output is $assoclist_split"

    set assoclist_check 0
    foreach j $assoclist_split {
	puts "$j STA from assoclist is $assoclist_check in list"
	incr assoclist_check
    }

    UTF::Message LOG "" "The number of Associated STAs from assoclist is $assoclist_check"

    if {$no_of_assoc_stas == $assoclist_check} {
	UTF::Message LOG "" "The number of Associated STAs are matching"
    } else {
	error "Number of associated STAa are not matching"
    }

}

#INT wifi_getApDeviceRxrate (INT ap_index, CHAR *MAC, INT *output_RxMb)
UTF::Try "wifi_getApDeviceRxrate_$radio_intf" {
#root@brcm93390smwvg2:~# wifi_api wifi_getApDeviceRxrate 1 e2:d3:b9:89:13:b4
#6
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_temp]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApDeviceRxrate $idx $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] 0]

	    if {$get_rssi_op >= 0 || $get_rssi_op <= 100} {
		UTF::Message LOG "" "output from get_rssi_op matching wifi_getApDeviceRxrate wl output"
	    } else {
		error "wifi_getApDeviceRxrate output and get_rssi_op output is not matching $get_rssi_op"
	    }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "rx nrate"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApDeviceRxrate wl output"
	    } else {
	        error "wifi_getApDeviceRxrate output and wl output is not matching"
	    }

	} else {
            incr no_of_assoc_sta
	}
    }

    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	    set get_rssi_temp [$Router wifi_api wifi_getApDeviceRxrate $idx $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    if {$get_rssi_op >= 0 || $get_rssi_op <= 100} {
		UTF::Message LOG "" "output from get_rssi_op matching wifi_getApDeviceRxrate wl output"
	    } else {
		error "wifi_getApDeviceRxrate output and get_rssi_op output is not matching $get_rssi_op NEW"
	    }
	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "rx nrate"
	    UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApDeviceRxrate wl output"
	    } else {
		error "wifi_getApDeviceRxrate output and wl output is not matching NEW"
	    }
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApDeviceRxrate no STA with $radio_cnf is in associated list"
    }
}

#INT wifi_getApDeviceTxrate (INT ap_index, CHAR *MAC, INT *output_TxMb)
UTF::Try "wifi_getApDeviceTxrate_$radio_intf" {

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "assoc_stats_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "assoc_stats_6g"]
    }

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_temp]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApDeviceTxrate $idx $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "rate of last tx pkt"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*$get_rssi_op*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApDeviceTxrate wl output"
	    } else {
	        error "wifi_getApDeviceTxrate output and wl output is not matching"
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 120
        set assoc_stat [$STA wl status]
        UTF::Sleep 1

	if {![string match -nocase "*Not associated*" $assoc_stat]} {

	set get_rssi_temp [$Router wifi_api wifi_getApDeviceTxrate $idx $radio_cnf]
	set get_rssi_op [lindex [split $get_rssi_temp] end]

	set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	#string to compare is
	set smooth_rssi_temp "rate of last tx pkt"
	UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	#Need to verify against smoothed rssi value
	if {[string match -nocase "*$smooth_rssi_temp*$get_rssi_op*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApDeviceTxrate wl output"
	} else {
		error "wifi_getApDeviceTxrate output and wl output is not matching"
	}
	}

    } elseif {$found_sta != 1} {
	error "wifi_getApDeviceTxrate no STA with $radio_cnf is in associated list"
    }
}

#P2END#

#INT wifi_setRadioEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioEnable_$radio_intf" {
    set radio_en_cnf [extract_config_from_file $file_name "radio_en"]

    UTF::Message LOG "" "wifi_setRadioEnable is about to set $radio_en_cnf"
    $Router wifi_api wifi_setRadioEnable $idx $radio_en_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_isup_op [$Router wifi_api wifi_getRadioEnable $idx]
    UTF::Message LOG "" "wl output is $wl_isup_op"

    if {$radio_en_cnf == 1} {
	if {[string match -nocase "*TRUE*" $wl_isup_op]} {
	    UTF::Message LOG "" "wifi_setRadioEnable and wl output is matching"
	} else {
            error "wifi_setRadioEnable 1 and wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $wl_isup_op]} {
	    UTF::Message LOG "" "wifi_setRadioEnable and wl output is matching"
	} else {
            error "wifi_setRadioEnable 1 and wl output is not matching"
	}
    }

}

#INT wifi_setClientDetailedStatisticsEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setClientDetailedStatisticsEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "radio_en"]

    UTF::Message LOG "" "wifi_setClientDetailedStatisticsEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setClientDetailedStatisticsEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getRadioStatsEnable $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        UTF::Message LOG "" "STUB FUNCTION"
        #error "wl output is not matching"
    }

}

#INT wifi_setRadioStatsEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioStatsEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "radio_stats"]

    UTF::Message LOG "" "wifi_setRadioStatsEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioStatsEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getRadioStatsEnable $idx]
    UTF::Message LOG "" "wl output is $wl_op"
    if {[string match -nocase $radio_cnf $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "STUB FUNCTION"
#        error "wl output is not matching"
    }
}

#INT wifi_cancelApWPS(INT apIndex)
#Also checked /rdklogs/logs/wifihealth.txt, WPS cancel log is printed as expected.
#root@brcm93390smwvg2:~# tail -f /rdklogs/logs/wifihealth.txt
#2020-04-17 06:45:26 RDKB_WPS_CLI PBC_1 START
#2020-04-17 06:45:26 RDKB_WPS_CLI PBC_2 START
#2020-04-17 06:47:24 RDKB_WPS_1 TIMEOUT
#2020-04-17 06:49:05 RDKB_WPS_CANCEL_1 START
UTF::Try "wifi_cancelApWPS_$radio_intf" {
    $Router wifi_api wifi_cancelApWPS $idx

#hostapd_cli -i wl0 wps_get_status
#PBC Status: Disabled
#Last WPS result: None

    set ap_wps_config_temp [$Router hostapd_cli -i $if_name wps_get_status]

    UTF::Message LOG "" "output from wifi_cancelApWPS get is $ap_wps_config_temp"

    if {[string match -nocase "*Disabled*" $ap_wps_config_temp]} {
        UTF::Message LOG "" "output from wifi_getApWpsConfigMethodsSupported and wl matching"
        #error "Get returns value Push"
    } elseif {[string match -nocase "*Enabled*" $ap_wps_config_temp]} {
        error "Get returns value $ap_wps_config_temp"
    }

}
}
#end of for loop
}


proc test_p3_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts

    puts "JST3:inside test_p3_commands "

    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(ap) 0]
    }

    UTF::Message LOG "" "JST4: Trying to execute HAL P3 commands"

    set kk [$Router wifi_api wifi_getRadioNumberOfEntries]

    set num_radios [string index $kk end]

    puts "mum radios: $num_radios"

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    set acs_ver [extract_config_from_file $file_name "acs_ver"]

    if {$num_radios > 3} {
        UTF::Message ERROR "" "num_radios is not correct $num_radios"
        return
    }

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        UTF::Message LOG "" "Radio index: $idx"

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        } elseif {$idx == 2} {
                set radio_intf "6g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        }
#P3ADD#

#INT wifi_setApWmmOgAckPolicy(INT apIndex, INT class, BOOL ackPolicy)
UTF::Try "wifi_setApWmmOgAckPolicy_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wme_apsd"]
    set radio_cnf_class [extract_config_from_file $file_name "wme_apsd_class"]

    UTF::Message LOG "" "wifi_setApWmmOgAckPolicy is about to set $radio_cnf"
    $Router wifi_api wifi_setApWmmOgAckPolicy $idx $radio_cnf $radio_cnf_class
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name wme_apsd]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "STUB FUNCTION"
#       error "wl output is not matching"
    }

}

#INT wifi_setRadioDCSChannelPool(INT radioIndex, CHAR *pool)
UTF::Try "wifi_setRadioDCSChannelPool_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getRadioDCSChannelPool $idx]
    UTF::Sleep 2

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "dcs_chan_pool_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "dcs_chan_pool_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "dcs_chan_pool_6g"]
    }

    UTF::Message LOG "" "wifi_setRadioDCSChannelPool is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDCSChannelPool $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_op [$Router wifi_api wifi_getRadioDCSChannelPool $idx]
    UTF::Sleep 2

    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$radio_cnf*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching $wl_op"
    }

#reset
    UTF::Message LOG "" "wifi_setRadioDCSChannelPool is about to reset $actual_val"
    $Router wifi_api wifi_setRadioDCSChannelPool $idx $actual_val
    wifi_apply_test_suite $Router
    UTF::Sleep 10
}

#INT wifi_getRadioDCSChannelPool(INT radioIndex, CHAR *output_pool)
UTF::Try "wifi_getRadioDCSChannelPool_$radio_intf" {

    set ap_dcs_chan_temp [$Router wifi_api wifi_getRadioDCSChannelPool $idx]
    set ap_dcs_chan_op [lindex [split $ap_dcs_chan_temp] end]

#wifi_api wifi_setRadioDCSChannelPool  0 0x1001,0x1006,0x100b,0x1904,0x1909,0x1803, it works.
#root@Docsis-Gateway:~# wifi_api wifi_getRadioDCSChannelPool  0
#0x1001,0x1006,0x100b,0x1904,0x1909,0x1803

    UTF::Message LOG "" "output from wifi_getRadioDCSChannelPool is $ap_dcs_chan_op"

    if {$idx == 0} {
	if {[string match -nocase "*0x1001,0x1006*" $ap_dcs_chan_temp]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    #error "wl output is not matching"
	    UTF::Message LOG "" "STUB FUNCTION"
	}
    } elseif {$idx == 1} {
        if {[string match -nocase "*0xd024,0xd028*" $ap_dcs_chan_temp]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            #error "wl output is not matching"
	    UTF::Message LOG "" "STUB FUNCTION"
        }
    } elseif {$idx == 2} {
        if {[string match -nocase "*0x6f*" $ap_dcs_chan_temp]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            #error "wl output is not matching"
	    UTF::Message LOG "" "STUB FUNCTION"
        }
    }
}

#INT wifi_setRadioDcsDwelltime(INT radioIndex, INT millisecond)
UTF::Try "wifi_setRadioDcsDwelltime_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getRadioDcsDwelltime $idx]
    UTF::Sleep 2

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "dcs_dwell_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "dcs_dwell_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "dcs_dwell_6g"]
    }

    UTF::Message LOG "" "wifi_setRadioDcsDwelltime is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDcsDwelltime $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    if {$idx == 0} {
	set wl_op [$Router nvram get wl0_dcs_dwell_time]
    } elseif {$idx == 1} {
        set wl_op [$Router nvram get wl1_dcs_dwell_time]
    } elseif {$idx == 2} {
	set wl_op [$Router nvram get wl2_dcs_dwell_time]
    }
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

#reset
    $Router wifi_api wifi_setRadioDcsDwelltime $idx $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2

}

#INT wifi_getRadioDcsDwelltime(INT radioIndex, INT *output_millisecond)
UTF::Try "wifi_getRadioDcsDwelltime_$radio_intf" {
    set ap_dcs_dwell_temp [$Router wifi_api wifi_getRadioDcsDwelltime $idx]
    set ap_dcs_dwell_op [lindex [split $ap_dcs_dwell_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioDcsDwelltime is $ap_dcs_dwell_op"

    if {$idx == 0} {
        set wl_op [$Router nvram get wl0_dcs_dwell_time]
    } elseif {$idx == 1} {
        set wl_op [$Router nvram get wl1_dcs_dwell_time]
    } elseif {$idx == 2} {
        set wl_op [$Router nvram get wl2_dcs_dwell_time]
    }
    UTF::Message LOG "" "wl output is $wl_op"

    if {$ap_dcs_dwell_op == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}

#
#root@brcm93390smwvg2:~# wl -i wl1 assoclist
#assoclist 00:90:4C:2B:E0:65

#root@brcm93390smwvg2:~# wifi_api wifi_getRMCapabilities 00:90:4C:2B:E0:65
#Enter main wifi_getRMCapabilities
#In main out_Capabilities = 33 0F 00 00 00

#root@brcm93390smwvg2:~# wifi_api wifi_RMBeaconRequest_callback_register 1 &
#[1] 15437

#root@brcm93390smwvg2:~# wifi_api wifi_setRMBeaconRequest 1 00:90:4C:2B:E0:65 \
#>  00 00 0000 0001 01
#wifi_setRMBeaconRequest argcnt=9
#wifi_setRMBeaconRequest complete
#root@brcm93390smwvg2:~# <802.11K Rx Rep> wifi_RMBeaconReport_callback_test_func: opClass: 0 channel: 36, duration: 1, frame info: 0, rcpi: 90,rsni: 76, bssid: 90:94:e4:ff:18:d6, antenna id: 0, parent tsf: 1387155666

#---------------
#<802.11K Rx Rep> wifi_RMBeaconReport_callback_test_func: opClass: 0 channel: 36, duration: 1, frame info: 0, rcpi: 70,rsni: 56, bssid: 82:85:2a:d9:52:80, antenna id: 0, parent tsf: 1387155668

#---------------
#<802.11K Rx Rep> wifi_RMBeaconReport_callback_test_func: opClass: 0 channel: 44, duration: 1, frame info: 0, rcpi: 32,rsni: 26, bssid: a8:bd:27:de:9b:b0, antenna id: 0, parent tsf: 1387155671

#---------------
#:::
#root@brcm93390smwvg2:~# cat /tmp/rdk_log_rrm_11k.txt
#1616129122 2021-3-19 4:45:22
# <802.11K Tx> Radio:1 Beacon Request to MAC= Token=0x9e

#1616129123 2021-3-19 4:45:23
# <802.11K Rx> Radio:1 Beacon Report from MAC=00:90:4C:2B:E0:65 Token=0x9e

#1616129123 2021-3-19 4:45:23
# <802.11K Rx> Radio:1 Beacon Report from MAC=00:90:4C:2B:E0:65 Token=0x9e
#
#INT wifi_setRMBeaconRequest(UINT apIndex,CHAR *peer,wifi_BeaconRequest_t *in_request,UCHAR *out_DialogToken)
UTF::Try "wifi_setRMBeaconRequest_$radio_intf" {

#wifi_api wifi_RMBeaconRequest_callback_register 1 &
#wifi_api wifi_setRMBeaconRequest 1 00:90:4C:2B:E0:65 00 00 0000 0001 01
    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "radio_rm_bcn_req_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "radio_rm_bcn_req_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "radio_rm_bcn_req_6g"]
    }

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    $Router wifi_api wifi_RMBeaconRequest_callback_register $to_exec &
    UTF::Sleep 2

    UTF::Message LOG "" "wifi_setRMBeaconRequest is about to set $radio_cnf"
    set rm_bcn_op [$Router wifi_api wifi_setRMBeaconRequest $to_exec $radio_cnf]
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    if {[string match -nocase "*wifi_setRMBeaconRequest complete*" $rm_bcn_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getBSSColor(UINT apIndex)
UTF::Try "wifi_getBSSColor_$radio_intf" {

    set bss_color_temp [$Router wifi_api wifi_getBSSColor $idx]
    set bss_color_op [lindex [split $bss_color_temp] end]
    UTF::Message LOG "" "wifi_getBSSColor is $bss_color_op"

#    set wl_op [$Router wl -i $if_name phy_bsscolor]
#    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*BSSColor=*" $bss_color_op]} {
        UTF::Message LOG "" "API output is $bss_color_op"
    }

}

#INT wifi_setBSSColorEnabled(UINT apIndex)
UTF::Try "wifi_setBSSColorEnabled_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getBSSColorEnabled $idx]

    if {[string match -nocase "*TRUE*" $wl_actual]} {
	set radio_cnf 0
    } elseif {[string match -nocase "*FALSE*" $wl_actual]} {
        set radio_cnf 1
    }

    UTF::Message LOG "" "wifi_setBSSColorEnabled is about to set $radio_cnf"
    $Router wifi_api wifi_setBSSColorEnabled $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_op [$Router wifi_api wifi_getBSSColorEnabled $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 0} {
	if {[string match -nocase "*BSSColorEnabled=FALSE*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	    set radio_cnf 1
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*BSSColorEnabled=TRUE*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	    set radio_cnf 0
	} else {
	    error "wl output is not matching"
	}
    }

#reset
    $Router wifi_api wifi_setBSSColorEnabled $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

}

#INT wifi_getBSSColorEnabled(UINT apIndex)
UTF::Try "wifi_getBSSColorEnabled_$radio_intf" {

    set act_val [$Router wifi_api wifi_getBSSColorEnabled $idx]

    if {[string match -nocase "*FALSE*" $wl_op]} {
	set to_set_color 1
    } else {
	set to_set_color 0
    }

    $Router wifi_api wifi_setBSSColorEnabled $idx $to_set_color
    UTF::Sleep 5

    set bss_color_en_temp [$Router wifi_api wifi_getBSSColorEnabled $idx]
    set bss_color_en_op [lindex [split $bss_color_en_temp] end]
    UTF::Message LOG "" "wifi_getBSSColorEnabled is $bss_color_en_op"

    if {$to_set_color == 1} {
	if {[string match -nocase "*TRUE*" $bss_color_en_op]} {
	    UTF::Message LOG "" "wl output is matching TRUE"
	    set to_set_color 0
	} else {
	    error "wl output is not matching TRUE"
	}
    } elseif {$to_set_color == 0} {
        if {[string match -nocase "*FALSE*" $bss_color_en_op]} {
            UTF::Message LOG "" "wl output is matching FALSE"
            set to_set_color 1
        } else {
            error "wl output is not matching FALSE"
        }
    } else {
	 error "wl output to set_color is not expected"
    }

#reset
    $Router wifi_api wifi_setBSSColorEnabled $idx $to_set_color
    UTF::Sleep 5
}

#INT wifi_setApCsaDeauth(INT apIndex, INT mode)
UTF::Try "wifi_setApCsaDeauth_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "csa_deauth_en"]

    if {$idx == 0} {
        set wl_actual [extract_config_from_file $nvram_show_file "wl0_csa_deauth_mode"]
    } elseif {$idx == 1} {
        set wl_actual [extract_config_from_file $nvram_show_file "wl1_csa_deauth_mode"]
    } elseif {$idx == 2} {
        set wl_actual [extract_config_from_file $nvram_show_file "wl2_csa_deauth_mode"]
    }

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    if {$wl_actual == 0} {
	set csa_deauth_mode 1
    } else {
	set csa_deauth_mode 0
    }
    UTF::Message LOG "" "wifi_setApCsaDeauth is about to set $radio_cnf"

    $Router wifi_api wifi_setApCsaDeauth $to_exec $radio_cnf $csa_deauth_mode
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp
    UTF::Sleep 2

    if {$idx == 0} {
        set wl_op [extract_config_from_file $nvram_show_file "wl0_csa_deauth_mode"]
    } elseif {$idx == 1} {
        set wl_op [extract_config_from_file $nvram_show_file "wl1_csa_deauth_mode"]
    } elseif {$idx == 2} {
        set wl_op [extract_config_from_file $nvram_show_file "wl2_csa_deauth_mode"]
    }

    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

    #reset
    $Router wifi_api wifi_setApCsaDeauth $to_exec $radio_cnf $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_setApScanFilter(INT apIndex, INT mode, CHAR *essid)
UTF::Try "wifi_setApScanFilter_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "filter_ssid"]
    set radio_cnf1 [extract_config_from_file $file_name "filter_mode"]

    UTF::Message LOG "" "wifi_setApScanFilter is about to set $radio_cnf $radio_cnf1"
    $Router wifi_api wifi_setApScanFilter $idx $radio_cnf1 $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getNeighboringWiFiDiagnosticResult2 $idx]
    UTF::Sleep 10
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "$radio_cnf" $wl_op]} {
        UTF::Message LOG "" "SSID exist in neighbor"
	error "SSID exist in neighbor"
    } else {
        UTF::Message LOG "" "SSID Does exist in neighbor"
    }

}

UTF::Try "wifi_steering_clientDisconnect_$radio_intf" {
        $Router wifi_api wifi_steering_clientDisconnect 0 0 00:10:18:FB:D8:26 2 3
}

UTF::Try "wifi_steering_clientMeasure_$radio_intf" {
        $Router wifi_api wifi_steering_clientMeasure 0 0 00:10:18:FB:D8:26
}

UTF::Try "wifi_steering_clientRemove_$radio_intf" {
        $Router wifi_api wifi_steering_clientRemove 0 0 00:10:18:FB:D8:26
}

UTF::Try "wifi_steering_clientSet_$radio_intf" {
        #$Router wifi_api wifi_steering_clientSet $idx
        $Router wifi_api wifi_steering_clientSet 0 0 00:10:18:FB:D8:26 0 0 0 0 0 0 0 17
}

UTF::Try "wifi_steering_setGroup_$radio_intf" {
	#apindex 0/1 in group 0
        $Router wifi_api wifi_steering_setGroup 0 0 3 5 5 20 1 6 5 6 30
}

#INT wifi_setRadioAutoChannelRefreshPeriod(INT radioIndex, ULONG seconds)
UTF::Try "wifi_setRadioAutoChannelRefreshPeriod_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ach_refresh_period"]

    set get_api_temp [$Router wifi_api wifi_getRadioAutoChannelRefreshPeriod $idx]
    set get_api_val [lindex [split $get_api_temp] end]

    UTF::Message LOG "" "wifi_setRadioAutoChannelRefreshPeriod is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioAutoChannelRefreshPeriod $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_temp [$Router wifi_api wifi_getRadioAutoChannelRefreshPeriod $idx]
    set wl_op [lindex [split $wl_temp] end]

    if {[string match -nocase "*$radio_cnf*" $wl_op]} {
	UTF::Message LOG "" "wifi_setRadioAutoChannelRefreshPeriod output matching"
    } else {
	error "wifi_setRadioAutoChannelRefreshPeriod output is not matching $wl_op"
    }

    #reset
    $Router wifi_api wifi_setRadioAutoChannelRefreshPeriod $idx $get_api_val
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#P3END#

    }
}


proc test_p4_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts

    puts "JST3:inside test_p4_commands "

    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(ap) 0]
    }

    UTF::Message LOG "" "JST4: Trying to execute HAL P4 commands"

    set kk [$Router wifi_api wifi_getRadioNumberOfEntries]

    set num_radios [string index $kk end]

    puts "mum radios: $num_radios"

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    if {$num_radios > 3} {
        UTF::Message ERROR "" "num_radios is not correct $num_radios"
        return
    }

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        UTF::Message LOG "" "Radio index: $idx"

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        } elseif {$idx == 2} {
                set radio_intf "6g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        }
#P4ADD#

#wifi_getInterworkingAccessNetworkType
UTF::Try "wifi_getInterworkingAccessNetworkType_$radio_intf" {

    set inter_access_nw_type_temp [$Router wifi_api wifi_getInterworkingAccessNetworkType $idx]
    set inter_access_nw_type_op [lindex [split $inter_access_nw_type_temp] end]
    UTF::Message LOG "" "wifi_getInterworkingAccessNetworkType is $inter_access_nw_type_op"

    if {$idx == 0} {
	set wl_op [$Router nvram get wl0_iwnettype]
    } elseif {$idx == 1} {
        set wl_op [$Router nvram get wl1_iwnettype]
    } elseif {$idx == 2} {
	set wl_op [$Router nvram get wl2_iwnettype]
    }

    if {$inter_access_nw_type_op == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getRadioResetCount(INT radioIndex, ULONG *output_int)
UTF::Try "wifi_getRadioResetCount_$radio_intf" {
    set reset_crnt [$Router wifi_api wifi_getRadioResetCount $idx]

    $Router wifi_api wifi_factoryResetRadio $idx 1 0
    UTF::Sleep 2

    wifi_apply_test_suite $Router
    UTF::Sleep 200

    $Router wifi_api wifi_init
    UTF::Sleep 100

    set reset_op [$Router wifi_api wifi_getRadioResetCount $idx]

    if {$reset_op == [expr $reset_crnt + 1]} {
	 UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

#INT wifi_setInterworkingAccessNetworkType(INT apIndex, INT accessNetworkType)
UTF::Try "wifi_setInterworkingAccessNetworkType_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "inter_nw_access_type"]

    set api_val [$Router wifi_api wifi_getInterworkingAccessNetworkType $idx]

    UTF::Message LOG "" "wifi_setInterworkingAccessNetworkType is about to set $radio_cnf"
    $Router wifi_api wifi_setInterworkingAccessNetworkType $idx $radio_cnf
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getInterworkingAccessNetworkType $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$wl_op <= 11} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching NOT SUPPORTED"
    }

    #reset
    $Router wifi_api wifi_setInterworkingAccessNetworkType $idx $api_val
    UTF::Sleep 2
}

#wifi_getApInterworkingServiceCapability
UTF::Try "wifi_getApInterworkingServiceCapability_$radio_intf" {

    set ap_inter_cap_op [$Router wifi_api wifi_getApInterworkingServiceCapability $ap_index]

#    set wl_temp [$Router wl -i $if_name wnm]
#    set wl_op [lindex [split $wl_temp] end]

    if {$idx == 0} {
	set wl_op [extract_config_from_file $nvram_show_file "wl0_hspot"]
    } elseif {$idx == 1} {
        set wl_op [extract_config_from_file $nvram_show_file "wl1_hspot"]
    } elseif {$idx == 2} {
        set wl_op [extract_config_from_file $nvram_show_file "wl2_hspot"]
    }
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*TRUE*" $ap_inter_cap_op]} {
        if {$wl_op == 1} {
            UTF::Message LOG "" "wl output is matching"
       } else {
           error "wl output is not matching TRUE"
        }
    } else {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching TRUE"
        }
    }

}

#INT wifi_getApInterworkingServiceEnable(INT apIndex, BOOL input_bool)
UTF::Try "wifi_getApInterworkingServiceEnable_$radio_intf" {

    set ap_inter_nw_en [$Router wifi_api wifi_getApInterworkingServiceEnable $idx]
    set ap_inter_nw_op [lindex [split $ap_inter_nw_en] end]

    set wl_temp [$Router wl -i $if_name interworking]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*TRUE*" $ap_inter_nw_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*FALSE*" $ap_inter_nw_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }

}

#INT wifi_setApInterworkingServiceEnable(INT apIndex, BOOL input_bool)
UTF::Try "wifi_setApInterworkingServiceEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "iw_wnm"]

    set api_val [$Router wifi_api wifi_getApInterworkingServiceEnable $idx]
    UTF::Message LOG "" "wifi_setApInterworkingServiceEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApInterworkingServiceEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_temp [$Router wifi_api wifi_getApInterworkingServiceEnable $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 1} {
	if {[string match -nocase "*TRUE*" $wl_temp]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } elseif {$radio_cnf == 0} {
        if {[string match -nocase "*FALSE*" $wl_temp]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching"
        }
    }

    $Router wifi_api wifi_setApInterworkingServiceEnable $idx $api_val
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#P4END#
    }
}

proc test_p5_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts

    puts "JST3:inside test_p5_commands "

    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(ap) 0]
    }

    UTF::Message LOG "" "JST4: Trying to execute HAL P5 commands"

    set kk [$Router wifi_api wifi_getRadioNumberOfEntries]

    set num_radios [string index $kk end]

    puts "mum radios: $num_radios"

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    if {$num_radios > 3} {
        UTF::Message ERROR "" "num_radios is not correct $num_radios"
        return
    }

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        UTF::Message LOG "" "Radio index: $idx"

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        } elseif {$idx == 2} {
                set radio_intf "6g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        }
#P5ADD#

#wifi_getApTxBeaconFrameCount
UTF::Try "wifi_getApTxBeaconFrameCount_$radio_intf" {

    set radio_bcn_cnt_temp [$Router wifi_api wifi_getApTxBeaconFrameCount $idx]

    set radio_bcn_cnt_op [lindex [split $radio_bcn_cnt_temp] end]

    set num_chars [string length $radio_bcn_cnt_op]
    UTF::Message LOG "" "outputi from wifi_getApTxBeaconFrameCount is $radio_bcn_cnt_op"

    #set wl_bcn_period_temp [$Router wl -i $if_name counters]

    set wl_bcn_period_temp [$Router wl -i $if_name counters]
    UTF::Message LOG "" "output from wl is $wl_bcn_period_temp"

    set wl_bcn_period_op [extract_wl_counter_output $wl_bcn_period_temp "txbcnfrm" $num_chars]
#    set wl_bcn_period_op [lindex [split $wl_bcn_period_temp " "] end]

    UTF::Message LOG "" "output from wl counters is $wl_bcn_period_op"

    if {$radio_bcn_cnt_op <= $wl_bcn_period_op} {
        UTF::Message LOG "" "output from wifi_getApTxBeaconFrameCount is matching wl output"
    }
}

#root@Docsis-Gateway:~# nvram get wl1_oper_stands
#a,n,ac
#root@Docsis-Gateway:~# wifi_api wifi_getRadioMode 1
#standards=ac pureMode=0x0
#
#
#  root@Docsis-Gateway:~# wifi_api wifi_setRadioMode 2 "11AX" 0
#  API wifi_setRadioMode complete
#  root@Docsis-Gateway:~# wifi_api wifi_applyRadioSettings 2
#  root@Docsis-Gateway:~#
#  root@Docsis-Gateway:~# wifi_api wifi_getRadioOperatingParameters 2
#  root@Docsis-Gateway:~# wifi_api wifi_getRadioMode 2
#  standards=ax pureMode=0x0
#  root@Docsis-Gateway:~# nvram get wl2_oper_stands
#  a,n,ac,ax
#wifi_getRadioMode
UTF::Try "wifi_getRadioMode_$radio_intf" {
    set radio_mode_op [$Router wifi_api wifi_getRadioMode $idx]

    UTF::Message LOG "" "output from wifi_getRadioMode is $radio_mode_op"

        if {[string match -nocase "*pureMode=0x1*" $radio_mode_op]} {
            UTF::Message LOG "" "output from wifi_getRadioMode and wl matching"
        } elseif {[string match -nocase "*pureMode=0x4*" $radio_mode_op]} {
            UTF::Message LOG "" "output from wifi_getRadioMode and wl matching"
        } elseif {[string match -nocase "*pureMode=0x0*" $radio_mode_op]} {
            UTF::Message LOG "" "output from wifi_getRadioMode and wl matching"
        } elseif {[string match -nocase "*pureMode=0x20*" $radio_mode_op]} {
            UTF::Message LOG "" "output from wifi_getRadioMode and wl matching"
        } elseif {[string match -nocase "*pureMode=0x24*" $radio_mode_op]} {
            UTF::Message LOG "" "output from wifi_getRadioMode and wl matching"
        } else {
            error "output from wifi_setRadioMode and wl is not matching $radio_mode_op"
        }

}

#INT wifi_setDownlinkMuType(INT radio_index, wifi_dl_mu_type_t dl_mu_type)
UTF::Try "wifi_setDownlinkMuType_$radio_intf" {
    set dlink_mu_cnf [extract_config_from_file $file_name "dlink_mu_type"]

    set api_temp [$Router wifi_api wifi_getDownlinkMuType $idx]

    if {[string match -nocase "*DownlinkMuType=0*" $api_temp]} {
	set api_val 0
    } elseif {[string match -nocase "*DownlinkMuType=1*" $api_temp]} {
        set api_val 1
    } elseif {[string match -nocase "*DownlinkMuType=2*" $api_temp]} {
        set api_val 2
    } elseif {[string match -nocase "*DownlinkMuType=3*" $api_temp]} {
        set api_val 3
    }

    UTF::Message LOG "" "wifi_setDownlinkMuType is about to set $dlink_mu_cnf"
    $Router wifi_api wifi_setDownlinkMuType $idx $dlink_mu_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_op [$Router wifi_api wifi_getDownlinkMuType $idx]

    if {$dlink_mu_cnf == 1} {
	if {[string match -nocase "*DownlinkMuType=1*" $wl_op]} {
	    UTF::Message LOG "" "output from wifi_setDownlinkMuType and wl matching"
	} else {
	    error "output from wifi_setDownlinkMuType and wl not matching"
	}
    } else {
	if {[string match -nocase "*DownlinkMuType=0*" $wl_op]} {
	    UTF::Message LOG "" "output from wifi_setDownlinkMuType and wl matching"
	} else {
	    error "output from wifi_setDownlinkMuType and wl not matching"
	}
    }

    $Router wifi_api wifi_setDownlinkMuType $idx $api_val
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}

#INT wifi_getDownlinkMuType(INT radio_index, wifi_dl_mu_type_t *dl_mu_type)
UTF::Try "wifi_getDownlinkMuType_$radio_intf" {
    set dlink_mu_temp [$Router wifi_api wifi_getDownlinkMuType $idx]
    set dlink_mu_op [lindex [split $dlink_mu_temp] 0]

    UTF::Message LOG "" "output from wifi_getDownlinkMuType is $dlink_mu_op"

    if {[string match -nocase "*DownlinkMuType=*" $dlink_mu_op]} {
        UTF::Message LOG "" "output from wifi_getDownlinkMuType and wl matching"
    } else {
        error "output from wifi_getDownlinkMuType and wl is not matching"
    }

}

#INT wifi_setUplinkMuType(INT radio_index, wifi_dl_mu_type_t dl_mu_type)
UTF::Try "wifi_setUplinkMuType_$radio_intf" {
    set ulink_mu_cnf [extract_config_from_file $file_name "ulink_mu_type"]

    set api_temp [$Router wifi_api wifi_getUplinkMuType $idx]

    if {[string match -nocase "*UplinkMuType=0*" $api_temp]} {
        set api_val 0
    } elseif {[string match -nocase "*UplinkMuType=1*" $api_temp]} {
        set api_val 1
    } elseif {[string match -nocase "*UplinkMuType=2*" $api_temp]} {
        set api_val 2
    } elseif {[string match -nocase "*UplinkMuType=3*" $api_temp]} {
        set api_val 3
    }

    UTF::Message LOG "" "wifi_setUplinkMuType is about to set $ulink_mu_cnf"
    $Router wifi_api wifi_setUplinkMuType $idx $ulink_mu_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_op [$Router wifi_api wifi_getUplinkMuType $idx]

    if {$ulink_mu_cnf == 1} {
        if {[string match -nocase "*UplinkMuType=1*" $wl_op]} {
            UTF::Message LOG "" "output from wifi_setUplinkMuType and wl matching"
        } else {
            error "output from wifi_setUplinkMuType and wl not matching"
        }
    } else {
        if {[string match -nocase "*UplinkMuType=0*" $wl_op]} {
            UTF::Message LOG "" "output from wifi_setUplinkMuType and wl matching"
        } else {
            error "output from wifi_setUplinkMuType and wl not matching"
        }
    }

    $Router wifi_api wifi_setUplinkMuType $idx $api_val
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}

#INT wifi_getUplinkMuType(INT radio_index, wifi_dl_mu_type_t *dl_mu_type)
UTF::Try "wifi_getUplinkMuType_$radio_intf" {
    set ulink_mu_op [$Router wifi_api wifi_getUplinkMuType $idx]

    UTF::Message LOG "" "output from wifi_getUplinkMuType is $ulink_mu_op"

    if {[string match -nocase "*UplinkMuType=*" $ulink_mu_op]} {
        UTF::Message LOG "" "output from wifi_getUplinkMuType and wl matching"
    } else {
        error "output from wifi_getUplinkMuType and wl is not matching"
    }

}

#TODO
#wifi_dpp_callbacks_register


UTF::Try "wifi_BTMQueryRequest_callback_register_$radio_intf" {
        $Router wifi_api wifi_BTMQueryRequest_callback_register $idx &
	#TODO
	#execute the BTM quesry request from the client and check the call back is invoked
}

#INT wifi_getBSSTransitionActivated(INT apIndex, BOOL *activate)
UTF::Try "wifi_getBSSTransitionActivated_$radio_intf" {
    set conf_temp [$Router wifi_api wifi_getBSSTransitionActivated $idx]
    set conf_op [lindex [split $conf_temp] end]
    UTF::Message LOG "" "get command output is $conf_op"

    set wl_op [$Router wl -i $if_name fbt]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*activate 1*" $conf_temp]} {
        if {$wl_op == 1} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 1"
        }
    } elseif {[string match -nocase "*activate 0*" $conf_temp]} {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 0"
        }
    } elseif {$conf_op == 1} {
        if {$wl_op == 1} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 1"
        }
    } elseif {$conf_op == 0} {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 1"
        }
    }
}

#INT wifi_getFTOverDSActivated(INT apIndex, BOOL *activate)
UTF::Try "wifi_getFTOverDSActivated_$radio_intf" {
    set conf_temp [$Router wifi_api wifi_getFTOverDSActivated $idx]
    set conf_op [lindex [split $conf_temp] end]
    UTF::Message LOG "" "get command output is $conf_op"

    set wl_op [$Router wl -i $if_name fbtoverds]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*activate 1*" $conf_temp]} {
        if {$wl_op == 1} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 1"
        }
    } elseif {[string match -nocase "*activate 0*" $conf_temp]} {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 0"
        }
    } elseif {$conf_op == 1} {
        if {$wl_op == 1} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 1"
        }
    } elseif {$conf_op == 0} {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching for 1"
        }
    }
}

#INT wifi_getFTMobilityDomainID(INT apIndex, UCHAR mobilityDomain[2])
UTF::Try "wifi_getFTMobilityDomainID_$radio_intf" {
    set conf_temp [$Router wifi_api wifi_getFTMobilityDomainID $idx]
    set conf_op [lindex [split $conf_temp] 0]

#
#root@brcm93390smwvg2:~# wifi_api wifi_setFTMobilityDomainID 0 18
#wifi_setFTMobilityDomainID(apIndex 0, ..)
#WLDM >> wldm_11r_ft: set fbt_mdid=18
#WLDM >> wl_11r_ft_integer: apIndex=0 osifname=wl0 cmd=0x60000 ftname=fbt_mdid value=18
#WLDM >> wl_11r_ft_integer: current fbt_mdid=0x0, set to 18 on wl0
#wifi_setFTMobilityDomainID(apIndex 0, 0x31 0x38 0x1f) rc=0
#
#root@brcm93390smwvg2:~# wl fbt_mdid
#18 (0x12)
#
#
    set wl_temp [$Router wl -i $if_name fbt_mdid]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$wl_op == 0} {
	if {[string match -nocase "*apIndex $idx, 0x0*" $conf_temp]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching 0 case $conf_temp"
	}
    } else {
	set hex_val [format %x $wl_op]
	if {[string match -nocase "*apIndex $idx, %hex_val*" $conf_temp]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching Non-Zero case $conf_temp"
	}
    }
}

#INT wifi_getFTR0KeyHolderID(INT apIndex, UCHAR *keyHolderID)
UTF::Try "wifi_getFTR0KeyHolderID_$radio_intf" {
    set conf_temp [$Router wifi_api wifi_getFTR0KeyHolderID $idx]
    set conf_op [lindex [split $conf_temp] end]

    set wl_op [$Router wl -i $if_name fbt_r0kh_id]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$wl_op*" $conf_temp]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}

#INT wifi_getFTR1KeyHolderID(INT apIndex, UCHAR *keyHolderID)
UTF::Try "wifi_getFTR1KeyHolderID_$radio_intf" {
    set conf_temp [$Router wifi_api wifi_getFTR1KeyHolderID $idx]
    set conf_op [lindex [split $conf_temp] end]

    set wl_op [$Router wl -i $if_name fbt_r1kh_id]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$wl_op*" $conf_temp]} {
        UTF::Message LOG "" "wl output is matching"
#    } else {
#        error "wl output is not matching"
    }
}


#STUB FUNCTION
#INT wifi_getRadioReverseDirectionGrantSupported(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioReverseDirectionGrantSupported_$radio_intf" {
    $Router wifi_api wifi_getRadioReverseDirectionGrantSupported $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getRadioReverseDirectionGrantEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioReverseDirectionGrantEnable_$radio_intf" {
    $Router wifi_api wifi_getRadioReverseDirectionGrantEnable $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getRadioDeclineBARequestEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioDeclineBARequestEnable_$radio_intf" {
    $Router wifi_api wifi_getRadioDeclineBARequestEnable $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getRadioAutoBlockAckEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioAutoBlockAckEnable_$radio_intf" {
    $Router wifi_api wifi_getRadioAutoBlockAckEnable $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getApAssociatedDevicesHighWatermarkThreshold(INT apIndex, UINT *output)
UTF::Try "wifi_getApAssociatedDevicesHighWatermarkThreshold_$radio_intf" {
    $Router wifi_api wifi_getApAssociatedDevicesHighWatermarkThreshold $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getApAssociatedDevicesHighWatermarkThresholdReached(INT apIndex, UINT *output)
UTF::Try "wifi_getApAssociatedDevicesHighWatermarkThresholdReached_$radio_intf" {
    $Router wifi_api wifi_getApAssociatedDevicesHighWatermarkThresholdReached $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getApAssociatedDevicesHighWatermark(INT apIndex, UINT *output)
UTF::Try "wifi_getApAssociatedDevicesHighWatermark_$radio_intf" {
    $Router wifi_api wifi_getApAssociatedDevicesHighWatermark $idx
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_getApAssociatedDevicesHighWatermarkDate(INT apIndex, ULONG *output_in_seconds)
UTF::Try "wifi_getApAssociatedDevicesHighWatermarkDate_$radio_intf" {
    $Router wifi_api wifi_getApAssociatedDevicesHighWatermarkDate $idx
    UTF::Sleep 2
}

#INT wifi_getApSecurityRadiusSettings(INT apIndex, wifi_radius_setting_t *output)
UTF::Try "wifi_getApSecurityRadiusSettings_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    set ap_rad_sec_temp [$Router wifi_api wifi_getApSecurityRadiusSettings $to_exec]
    UTF::Sleep 2
    #$Router wifi_api wifi_getApSecurityRadiusSettings $idx

    UTF::Message LOG "" "output from wifi_getApSecurityRadiusSettings is $ap_rad_sec_temp"

if {0} {
    if {[string match -nocase "*RadiusServerRetries*" $ap_rad_sec_temp]} {
        UTF::Message LOG "" "output from wifi_getApSecurityRadiusSettings and wl matching"
    } else {
        error "output from wifi_getApSecurityRadiusSettings and wl is not matching"
    }
}
}

#wifi_api wifi_setApSecurityRadiusSettings 0 1 2 3 0 5 6 7 8 9
#wifi_api wifi_apply
#
#
#From the log, confirmed nvram variables are set, security daemons were restarted.
#Run below 'nvram get' commmand, confirmed nvram variables are set to the correct value.
#nvram get wl0_radius_max_retransmit
#1
#nvram get wl0_radius_fixed_interval
#2
#nvram get radius_wpa_pmk_lifetime
#3
#nvram get wl0_radius_flags
#0x200000
#nvram get wl0_net_reauth
#5
#nvram get radius_max_auth_attempts
#6
#nvram get radius_black_timeout
#7
#nvram get radius_identity_interval
#8
#nvram get radius_quiet_period
#9
#INT wifi_setApSecurityRadiusSettings(INT apIndex, wifi_radius_setting_t *input)
UTF::Try "wifi_setApSecurityRadiusSettings_$radio_intf" {
    set srvr_retries [extract_config_from_file $file_name "radious_srvr_retries"]
    set srvr_req_timeout [extract_config_from_file $file_name "radious_srvr_req_timeout"]
    set pmk_caching [extract_config_from_file $file_name "radious_pmk_caching"]
    set pmk_interval [extract_config_from_file $file_name "radious_pmk_interval"]
    set pmk_lifetime [extract_config_from_file $file_name "radious_pmk_lifetime"]
    set max_auth [extract_config_from_file $file_name "radious_max_auth"]
    set blklist_table_timeout [extract_config_from_file $file_name "radious_blklist_table_timeout"]
    set id_req_retry [extract_config_from_file $file_name "radious_id_req_retry"]
    set period_after_fail [extract_config_from_file $file_name "radious_period_after_fail"]

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    UTF::Message LOG "" "wifi_setApSecurityRadiusSettings is about to set $srvr_retries"
    $Router wifi_api wifi_setApSecurityRadiusSettings $to_exec $srvr_retries $srvr_req_timeout $pmk_caching $pmk_interval $pmk_lifetime $max_auth $blklist_table_timeout $id_req_retry $period_after_fail
    wifi_apply_test_suite $Router
    UTF::Sleep 2

#radious_srvr_retries=1
#radious_srvr_req_timeout=1
#radious_pmk_caching=1
#radious_pmk_interval=300
#radious_pmk_lifetime=1
#radious_max_auth=5
#radious_blklist_table_timeout=300
#radious_id_req_retry=120
#radious_period_after_fail=60

    if {$idx == 0} {
	set wl_op [$Router nvram get wl0_radius_max_retransmit]
    } elseif {$idx == 1} {
	set wl_op [$Router nvram get wl1_radius_max_retransmit]
    } elseif {$idx == 2} {
        set wl_op [$Router nvram get wl2_radius_max_retransmit]
    }
    UTF::Message LOG "" "wl output is $wl_op"

    if {$srvr_retries == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApBeaconRate(INT apIndex, char *sBeaconRate)
UTF::Try "wifi_setApBeaconRate_$radio_intf" {

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "bcn_rate_2g"]
    } elseif {$idx == 1} {
	set radio_cnf [extract_config_from_file $file_name "bcn_rate_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "bcn_rate_6g"]
    }

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    set act_val [$Router wifi_api wifi_getApBeaconRate $to_exec]
    UTF::Message LOG "" "actual get API value is $act_val"

    if {$idx == 0} {
	if {[string match -nocase "*2Mbps*" $act_val]} {
	    set radio_cnf "1Mbps"
	} else {
	    set radio_cnf "2Mbps"
	}
    } elseif {$idx == 1} {
	if {[string match -nocase "*6Mbps*" $act_val]} {
	    set radio_cnf "24Mbps"
	} else {
	    set radio_cnf "6Mbps"
	}
    } elseif {$idx == 2} {
	if {[string match -nocase "*6Mbps*" $act_val]} {
	    set radio_cnf "12Mbps"
	} else {
	    set radio_cnf "6Mbps"
	}
    }

    UTF::Message LOG "" "wifi_setApBeaconRate is about to set $radio_cnf"
    $Router wifi_api wifi_setApBeaconRate $to_exec $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set get_api_op [$Router wifi_api wifi_getApBeaconRate $to_exec]
    UTF::Message LOG "" "output from  wifi_getApBeaconRate is $get_api_op"

    if {[string match -nocase "*$get_api_op*" $radio_cnf]} {
	UTF::Message LOG "" "set is matching get API $get_api_op"
    } else {
        error "output from wifi_setApBeaconRate and wl is not matching"
    }

#reset
    UTF::Message LOG "" "actual API is reset to $act_val"
    $Router wifi_api wifi_setApBeaconRate $to_exec $act_val
    wifi_apply_test_suite $Router
    UTF::Sleep 10

}

#INT wifi_getApSecuritySecondaryRadiusServer(INT apIndex, CHAR *IP_output, UINT *Port_output, CHAR *RadiusSecret_output)
#INT wifi_hal_cb_dpp_evt_handler (int sock_fd)
#INT wifi_sendActionFrame(INT apIndex, mac_address_t sta, UINT frequency, UCHAR *frame, UINT len)


#INT wifi_setBandSteeringApGroup(char *ApGroup)
UTF::Try "wifi_setBandSteeringApGroup_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "steering_grp"]

    UTF::Message LOG "" "wifi_setBandSteeringApGroup is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringApGroup $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_temp [$Router wifi_api wifi_getBandSteeringApGroup]

    if {[string match -nocase "*$wl_temp*" $radio_cnf]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getBandSteeringApGroup(char *output_ApGroup)
UTF::Try "wifi_getBandSteeringApGroup_$radio_intf" {

    set bs_apgroup_temp [$Router wifi_api wifi_getBandSteeringApGroup]
    set bs_apgroup_op [lindex [split $bs_apgroup_temp] end]

    UTF::Message LOG "" "output from wifi_getBandSteeringApGroup is $bs_apgroup_op"

    if {[string match -nocase "**1*2*" $bs_apgroup_op]} {
        UTF::Message LOG "" "output from wifi_getBandSteeringApGroup and wl matching"
    } elseif {[string match -nocase "*3*" $bs_apgroup_op]} {
        UTF::Message LOG "" "output from wifi_getBandSteeringApGroup and wl matching"
    } else {
        error "output from wifi_getBandSteeringApGroup and wl is not matching WL NOT SUPPORTED"
    }
}

#INT wifi_getBSSTransitionImplemented(UINT apIndex, BOOL *activate)


#INT wifi_getNeighborReportActivation(UINT apIndex)
UTF::Try "wifi_getNeighborReportActivation_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    set nghbr_report_activate_temp [$Router wifi_api wifi_getNeighborReportActivation $to_exec]
    UTF::Message LOG "" "wifi_getNeighborReportActivation is $nghbr_report_activate_temp"

    set wl_op [$Router wl -i $if_name rrm]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*activate=1*" $nghbr_report_activate_temp]} {
	if {[string match -nocase "*Neighbor_Report*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
        if {[string match -nocase "*Neighbor_Report*" $wl_op]} {
            error "wl output is not matching"
        } else {
            UTF::Message LOG "" "wl output is matching"
        }
    }

}

UTF::Try "wifi_RMBeaconReport_callback_$radio_intf" {
        $Router wifi_api wifi_RMBeaconReport_callback $idx
}

UTF::Try "wifi_RMBeaconReport_callback_register_$radio_intf" {
        $Router wifi_api wifi_RMBeaconReport_callback_register $idx
}

UTF::Try "wifi_RMBeaconReport_callback_Unregister_$radio_intf" {
        $Router wifi_api wifi_RMBeaconReport_callback_Unregister $idx
}

#INT wifi_getRMCapabilities(UINT apIndex)
UTF::Try "wifi_getRMCapabilities_$radio_intf" {

#wifi_api wifi_getRMCapabilities 00:10:18:FB:D8:26

#RM_cap_MAC_2g=00:10:18:FB:D8:26
#RM_cap_MAC_5g=DC:EF:CA:5F:78:22
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "RM_cap_MAC_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "RM_cap_MAC_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "RM_cap_MAC_6g"]
    }

    set assoclist_temp [$Router wl -i $if_name assoclist]

    if {[string match -nocase "*$radio_cnf*" $assoclist_temp]} {
	set rm_cap_temp [$Router wifi_api wifi_getRMCapabilities $radio_cnf]
	UTF::Sleep 4

	if {[string match -nocase "*out_Capabilities =*" $rm_cap_temp]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	 UTF::Message LOG "" "MAC address is not associated"
    }

}

#INT wifi_setRadioDfsRefreshPeriod(INT radioIndex, BOOL enabled)
UTF::Try "wifi_setRadioDfsRefreshPeriod_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "radio_dfs_refresh_period"]

    set acs_ver [extract_config_from_file $file_name "acs_ver"]

    UTF::Message LOG "" "wifi_setRadioDfsRefreshPeriod is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDfsRefreshPeriod $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_temp [$Router $acs_ver -i $if_name get acs_ci_scan_timer ]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getBSSTransitionActivation(UINT apIndex)
UTF::Try "wifi_getBSSTransitionActivation_$radio_intf" {

    set bss_tran_act_temp [$Router wifi_api wifi_getBSSTransitionActivation $ap_index]
    set bss_tran_act_op [lindex [split $bss_tran_act_temp] end]
    UTF::Message LOG "" "wifi_getBSSTransitionActivation is $bss_tran_act_op"

    if {$bss_tran_act_op == 0} {
	set to_set 1
    } else {
	set to_set 0
    }

    UTF::Message LOG "" "wifi_setBSSTransitionActivation is about to set $radio_cnf"
    set set_api_op [$Router wifi_api wifi_setBSSTransitionActivation $ap_index $to_set]
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set set_api_op [$Router wifi_api wifi_getBSSTransitionActivation $ap_index]

    if {$bss_tran_act_op != $set_api_op} {
        UTF::Message LOG "" "get/set api is working"
    } else {
	error "get/set API output is not working"
    }

#reset

    UTF::Message LOG "" "wifi_setBSSTransitionActivation is about to set $radio_cnf"
    set set_api_op [$Router wifi_api wifi_setBSSTransitionActivation $ap_index $bss_tran_act_op]
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}

#INT wifi_getBTMClientCapabilityList(UINT apIndex, wifi_BTMCapabilities_t *extBTMCapabilities)
UTF::Try "wifi_getBTMClientCapabilityList_$radio_intf" {

    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_6g"]
    }

    set assoclist_temp [$Router wl -i $if_name assoclist]

    if {[string match -nocase "*$radio_cnf*" $assoclist_temp]} {

	set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
	set btm_cap_list_temp [$Router wifi_api wifi_getBTMClientCapabilityList $to_exec $radio_cnf]
	set btm_cap_list_op [lindex [split $btm_cap_list_temp] 3]
	UTF::Message LOG "" "wifi_getBTMClientCapabilityList is $btm_cap_list_op"

	set wl_op [$Router wl -i $if_name wnm_btq_nbr_list]
	UTF::Message LOG "" "wl output is $wl_op"

	if {[string match -nocase "*$radio_cnf*" $btm_cap_list_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    } else {
	UTF::Message LOG "" "No STA is associated"
    }

}

#INT wifi_setBandSteeringPhyRateThreshold (INT radioIndex, INT prThreshold)
UTF::Try "wifi_setBandSteeringPhyRateThreshold_$radio_intf" {
    set act_val [$Router wifi_api wifi_getBandSteeringPhyRateThreshold $idx]

    set radio_cnf [extract_config_from_file $file_name "steering_thresh"]

    UTF::Message LOG "" "wifi_setBandSteeringPhyRateThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringPhyRateThreshold $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getBandSteeringPhyRateThreshold $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

#reset
    UTF::Message LOG "" "wifi_setBandSteeringPhyRateThreshold is about to reset $act_val"
    $Router wifi_api wifi_setBandSteeringPhyRateThreshold $idx $act_val
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_setBSSTransitionActivation(UINT apIndex, BOOL activate)
UTF::Try "wifi_setBSSTransitionActivation_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bsstrans"]

    UTF::Message LOG "" "wifi_setBSSTransitionActivation is about to set $radio_cnf"
    $Router wifi_api wifi_setBSSTransitionActivation $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    #wl wnm_btq_nbr_add -b 00:4c:91:11:22:33 -c 6 -o 81 -p 255
    set wl_temp [$Router wifi_api wifi_getBSSTransitionActivation $ap_index]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*BSSTransitionActivation=*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setBTMRequest(UINT apIndex,CHAR *peer,wifi_BTMRequest_t *request)
UTF::Try "wifi_setBTMRequest_$radio_intf" {

    if {$idx ==0} {
	set req_MAC [extract_config_from_file $file_name "btm_req_MAC_2g"]
    } else {
	set req_MAC [extract_config_from_file $file_name "btm_req_MAC_5g"]
    }
    set req_token [extract_config_from_file $file_name "btm_req_token"]
    set req_mode [extract_config_from_file $file_name "btm_req_mode"]
    set req_num [extract_config_from_file $file_name "btm_req_num"]
    set req_len [extract_config_from_file $file_name "btm_req_len"]
    set req_candidate [extract_config_from_file $file_name "btm_req_candidate"]

    UTF::Message LOG "" "wifi_setBTMRequest is about to set $radio_cnf"
#wifi_api wifi_setBTMRequest 0 F0:99:BF:76:FF:54 18 5 1 13 44AAF59B179000000000162400

    $Router wifi_api wifi_setBTMRequest $idx $req_MAC $req_token $req_mode $req_num $req_len $req_candidate
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set bssid_check [lindex [$Router wl -i $if_name bssid] end]
    set chan_check [lindex [$Router wl -i $if_name chanspec] 0]

    set bss_trans_ip "-b $bssid_check -c $chan_check -o 81 -p 255"

    #wl wnm_btq_nbr_add -b 00:4c:91:11:22:33 -c 6 -o 81 -p 255
    set wl_op [$Router wl -i $if_name wnm_btq_nbr_add $bss_trans_ip]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    }

}

#INT wifi_getApManagementFramePowerControl(INT apIndex, INT *output_dBm)
UTF::Try "wifi_getApManagementFramePowerControl_$radio_intf" {
    set ap_mfc_temp [$Router wifi_api wifi_getApManagementFramePowerControl $idx]
    set ap_mfc_op [lindex [split $ap_mfc_temp] end]
    set abs_ap_mfc_op [abs $ap_mfc_op]

    UTF::Message LOG "" "output from wifi_getApManagementFramePowerControl is $abs_ap_mfc_op"

    set wl_bcnprs_txpwr_offset_op [$Router wl -i $if_name bcnprs_txpwr_offset]

    if {$abs_ap_mfc_op == $wl_bcnprs_txpwr_offset_op} {
        UTF::Message LOG "" "output from wifi_getApManagementFramePowerControl and wl matching"
    } else {
        error "output from wifi_getApManagementFramePowerControl and wl is not matching $wl_bcnprs_txpwr_offset_op"
    }

}

#INT wifi_setApManagementFramePowerControl(INT apIndex, INT dBm)
UTF::Try "wifi_setApManagementFramePowerControl_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "mfp_pwrctrl"]

    set actual_val [$Router wifi_api wifi_getApManagementFramePowerControl $ap_index]

    UTF::Message LOG "" "wifi_setApManagementFramePowerControl is about to set $radio_cnf"
    $Router wifi_api wifi_setApManagementFramePowerControl  $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set ap_txpwr_offset_temp [$Router wifi_api wifi_getApManagementFramePowerControl $ap_index]
    set ap_txpwr_offset_op [lindex [split $ap_txpwr_offset_temp] end]

    if {$radio_cnf == $ap_txpwr_offset_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching $ap_txpwr_offset_temp $ap_txpwr_offset_op"
    }

#reset
    UTF::Message LOG "" "iwifi_setApManagementFramePowerControl is about to reset $radio_cnf"
    $Router wifi_api wifi_setApManagementFramePowerControl  $ap_index $actual_val
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_getApInterworkingElement(INT apIndex, wifi_InterworkingElement_t *output_struct)
UTF::Try "wifi_getApInterworkingElement_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    set wl_act [$Router wifi_api wifi_getApInterworkingElement $to_exec]

    set bssid_temp [$Router wifi_api wifi_getBaseBSSID $to_exec]

    set bssid_output [lindex [split $bssid_temp] end]

    $Router wifi_api wifi_pushApInterworkingElement $to_exec 1 8 0 1 0 0 0 8 8 1 $bssid_output
    UTF::Sleep 5

    set push_op [$Router wifi_api wifi_getApInterworkingElement $to_exec]

    if {[string match -nocase "*interworkingEnabled:	1*" $push_op]} {
        UTF::Message LOG "" "wl output is matching $push_op"
    } else {
        error "wl output is not matching"
    }
}

#INT wifi_pushApInterworkingElement(INT apIndex, wifi_InterworkingElement_t *infoEelement)
UTF::Try "wifi_pushApInterworkingElement_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    set radio_cnf [extract_config_from_file $file_name "inter_element"]

    set bssid_temp [$Router wifi_api wifi_getBaseBSSID $to_exec]

    set bssid_output [lindex [split $bssid_temp] end]

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushApInterworkingElement $to_exec 1 8 0 1 0 0 0 8 8 1 $bssid_output
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_op [$Router wifi_api wifi_getApInterworkingElement $to_exec]

    if {[string match -nocase "*nterworkingEnabled*1*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching $wl_op"
    }
}

#wl down
#wl wpa_auth
#wl wpa_auth 128
#wl wpa_auth
#wl up
#INT wifi_setFastBSSTransitionActivated(INT apIndex, UCHAR activate)
UTF::Try "wifi_setFastBSSTransitionActivated_$radio_intf" {

    set api_actual [$Router wifi_api wifi_getBSSTransitionActivated $ap_index]

    if {[string match -nocase "*activate 0*" $api_actual]} {
	set to_set 1
    } else {
	set to_set 0
    }

    if {$to_set == 1} {
	UTF::Message LOG "" "about to Activate"
	#Make sure WPA2 is set
	set wl_op [$Router wl -i $if_name wpa_auth]

	if {[string match -nocase "*WPA2*" $wl_op]} {
	    UTF::Message LOG "" "Already WPA2, do nothing"
	} else {
	    $Router wl -i $if_name down
	    UTF::Sleep 2
	    set wpa_val 0x80
	    $Router wl -i $if_name wpa_auth $wpa_val
	    UTF::Sleep 2
	    $Router wl -i $if_name up
	    UTF::Sleep 10
	    $Router wl -i $if_name fbt $to_set
	    UTF::Sleep 2
	    $Router wl -i $if_name wpa_auth
	    $Router wl -i $if_name fbt
	}
    }
#RDKM output
#root@brcm93390smwvg2:~# wifi_api wifi_getBSSTransitionActivated 0
#wifi_getBSSTransitionActivated(apIndex 0, ..)
#wifi_getBSSTransitionActivated(apIndex 0, activate 0)
#root@brcm93390smwvg2:~# wifi_api wifi_setFastBSSTransitionActivated 0 1
#wifi_setBSSTransitionActivated(apIndex 0, ..)
#wifi_setFastBSSTransitionActivated(apIndex 0, activate 1)
#root@brcm93390smwvg2:~# wifi_api wifi_getBSSTransitionActivated 0
#
#wifi_getBSSTransitionActivated(apIndex 0, ..)
#wifi_getBSSTransitionActivated(apIndex 0, activate 1)
#root@brcm93390smwvg2:~#
#
#
    UTF::Message LOG "" "wifi_setFastBSSTransitionActivated is about to set $radio_cnf"
    $Router wifi_api wifi_setFastBSSTransitionActivated $ap_index $to_set
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set api_op [$Router wifi_api wifi_getBSSTransitionActivated $ap_index]
    UTF::Message LOG "" "wl output is $api_op"

    if {$to_set == 1} {
	if {[string match -nocase "*activate 1*" $api_op]} {
	    UTF::Message LOG "" "wl output is matching $api_op"
	} else {
	    error "wl output is not matching $api_op for 1"
	}
    } else {
	if {[string match -nocase "*activate 0*" $api_op]} {
	    error "wl output is not matching $api_op for 0"
	} else {
	    UTF::Message LOG "" "wl output is matching $api_op"
	}
    }

#reset
if {0} {
    if {$to_set == 1} {
	 $Router wifi_api wifi_setFastBSSTransitionActivated $ap_index 0
    } else {
	 $Router wifi_api wifi_setFastBSSTransitionActivated $ap_index 1
    }
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}
}

#INT wifi_setFTOverDSActivated(INT apIndex, BOOL *activate)
UTF::Try "wifi_setFTOverDSActivated_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "fbtoverds"]
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    UTF::Message LOG "" "wifi_setFTOverDSActivated is about to set $radio_cnf"
    $Router wifi_api wifi_setFTOverDSActivated $to_exec $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name fbtoverds]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setFTMobilityDomainID(INT apIndex, UCHAR mobilityDomain[2])
UTF::Try "wifi_setFTMobilityDomainID_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ftm_domain_id"]
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    UTF::Message LOG "" "wifi_setFTMobilityDomainID is about to set $radio_cnf"
    $Router wifi_api wifi_setFTMobilityDomainID $to_exec $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_temp [$Router wl -i $if_name fbt_mdid]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setFTR0KeyHolderID(INT apIndex, UCHAR *keyHolderID)
UTF::Try "wifi_setFTR0KeyHolderID_$radio_intf" {
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "fbt_r0kh_id_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "fbt_r0kh_id_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "fbt_r0kh_id_6g"]
    }

    UTF::Message LOG "" "wifi_setFTR0KeyHolderID is about to set $radio_cnf"
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    $Router wifi_api wifi_setFTR0KeyHolderID $to_exec $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name fbt_r0kh_id]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$radio_cnf*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setFTR1KeyHolderID(INT apIndex, UCHAR *keyHolderID)
UTF::Try "wifi_setFTR1KeyHolderID_$radio_intf" {
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "fbt_r1kh_id_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "fbt_r1kh_id_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "fbt_r1kh_id_6g"]
    }

    UTF::Message LOG "" "wifi_setFTR1KeyHolderID is about to set $radio_cnf"
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    $Router wifi_api wifi_setFTR1KeyHolderID $to_exec $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name fbt_r1kh_id]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*fbt_r1kh_id*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_pushApFastTransitionConfig(INT apIndex, wifi_FastTransitionConfig_t *ftData)
UTF::Try "wifi_pushApFastTransitionConfig_$radio_intf" {
    set bss_supp [extract_config_from_file $file_name "ap_bss_supp"]
    set bss_mobdomain [extract_config_from_file $file_name "ap_bss_mobdomain"]
    set bss_overds [extract_config_from_file $file_name "ap_bss_overds"]

    if {$idx == 0} {
        set bss_r0lifetime [extract_config_from_file $file_name "ap_bss_r0lifetime_2g"]
    } elseif {$idx == 1} {
        set bss_r0lifetime [extract_config_from_file $file_name "ap_bss_r0lifetime_5g"]
    } elseif {$idx == 2} {
        set bss_r0lifetime [extract_config_from_file $file_name "ap_bss_r0lifetime_6g"]
    }

    set to_set 1

    if {$to_set == 1} {
	$Router wl -i $if_name down
	UTF::Sleep 2
	set wpa_val 0x80
	$Router wl -i $if_name wpa_auth $wpa_val
	UTF::Sleep 2
	$Router wl -i $if_name up
	UTF::Sleep 10
	$Router wl -i $if_name fbt $to_set
	UTF::Sleep 2
	$Router wl -i $if_name wpa_auth
    }

    UTF::Message LOG "" "about to set $radio_cnf"
#wifi_api wifi_pushApFastTransitionConfig <support> <mobilityDomain> <overDS> <r0KeyLifeTime>
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    $Router wifi_api wifi_pushApFastTransitionConfig $to_exec $bss_supp $bss_mobdomain $bss_overds $bss_r0lifetime
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    if {$idx == 0} {
	set wl_op [$Router nvram get wl0_fbtoverds]
    } elseif {$idx == 1} {
        set wl_op [$Router nvram get wl1_fbtoverds]
    } elseif {$idx == 2} {
        set wl_op [$Router nvram get wl2_fbtoverds]
    }
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*fbtoverds=1*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {$wl_op == 1} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {$wl_op == 0} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setNeighborReports(UINT apIndex,UINT numNeighborReports,wifi_NeighborReport_t *neighborReports)
UTF::Try "wifi_setNeighborReports_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "neighbor_reports_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "neighbor_reports_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "neighbor_reports_6g"]
    }

    UTF::Message LOG "" "wifi_setNeighborReports is about to set $radio_cnf"
    $Router wifi_api wifi_setNeighborReports $to_exec $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

#usage wifi_api wifi_setNeighborReports <AP Index> <cnt> [<bssid1> <bssid1 info> <regulatory1> <channel1> <phytype1>] cnt times
#wifi_api wifi_setNeighborReports 1 2 1C:EB:02:DA:22:E1 2183 5 165 0 1C:EB:02:CC:22:E2 2184 5 161 0

    set wl_op [$Router wl -i $if_name rrm_nbr_list]
    set num_entry [expr {[llength [split $wl_op \n]] - 1}]
    UTF::Message LOG "" "wl output is $wl_op $num_entry"

    if {[string match -nocase "*bssid*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }

}

#INT wifi_setNeighborReportActivation(UINT apIndex, BOOL activate)
UTF::Try "wifi_setNeighborReportActivation_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "nbr_en"]

    UTF::Message LOG "" "wifi_setNeighborReportActivation is about to set $radio_cnf"
    $Router wifi_api wifi_setNeighborReportActivation $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getNeighborReportActivation $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*activate=$radio_cnf*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setRadioDcsScanning(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioDcsScanning_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "dcs_scan_en"]

    UTF::Message LOG "" "wifi_setRadioDcsScanning is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDcsScanning $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getRadioDcsScanning $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    #STUB FUNCTION
    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    }
}

UTF::Try "wifi_BTMQueryRequest_callback_$radio_intf" {
        $Router wifi_api wifi_BTMQueryRequest_callback $idx
}

UTF::Try "wifi_BTMResponse_callback_$radio_intf" {
        $Router wifi_api wifi_BTMResponse_callback $idx
}

UTF::Try "wifi_steering_eventRegister" {
        $Router wifi_api wifi_apAuthEvent_callback_register
}

UTF::Try "wifi_steering_eventUnregister" {
        $Router wifi_api wifi_steering_event_callback_unregister
}

UTF::Try "wifi_getNeighboringWiFiStatus_$radio_intf" {
    set neighbor_wifi_stat_temp [$Router wifi_api wifi_getNeighboringWiFiStatus $idx]

    #Need to invoke scan to read the results
    if {$idx == 0} {
	$Router wifi_api wifi_startNeighborScan 0 0 -1 1 11
    } elseif {$idx == 1} {
        $Router wifi_api wifi_startNeighborScan 1 0 -1 1 36
    } elseif {$idx == 2} {
	$Router wifi_api wifi_startNeighborScan $idx 0 -1 1 179
    }

    UTF::Sleep 10
    if {[string match -nocase "*neighbor*" $neighbor_wifi_stat_temp]} {
	UTF::Message LOG "" "Neighbr results are available"
    } else {
	UTF::Message LOG "" "STUB FUNCTION"
     }

}

#INT wifi_getRadioStatsEnable(INT radioIndex, BOOL *output_enable)
UTF::Try "wifi_getRadioStatsEnable_$radio_intf" {
    set rad_stats_temp [$Router wifi_api wifi_getRadioStatsEnable $idx]

    set rad_stats_op [lindex [split $rad_stats_temp] end]

    if {[string match -nocase "FALSE" $rad_stats_op]} {
	UTF::Message LOG "" "Stats not enabled"
    } elseif {[string match -nocase "TRUE" $rad_stats_op]} {
	UTF::Message LOG "" "Stats enabled"
    } else {
	error "Stats not expected"
    }
}

UTF::Try "wifi_setRadioStatsEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "radio_stats_en"]

    $Router wifi_api wifi_setRadioStatsEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set rad_stats_op [$Router wifi_api wifi_getRadioStatsEnable $idx]

    if {[string match -nocase "FALSE" $rad_stats_op]} {
	if {$radio_cnf == 0} {
            UTF::Message LOG "" "STUB FUNCTION"
#	} else {
#	    error "Stats not expected FALSE"
	}
    } elseif {[string match -nocase "TRUE" $rad_stats_op]} {
	if {$radio_cnf == 1} {
            UTF::Message LOG "" "STUB FUNCTION"
#	} else {
#	    error "Stats not expected TRUE"
	}
    } else {
        UTF::Message LOG "" "Stats not enabled"
#        error "Stats not expected"
    }
}

#INT wifi_getRadioClientInactivityTimout(INT radioIndex, INT *output_timout_sec)
UTF::Try "wifi_getRadioClientInactivityTimout_$radio_intf" {
    set cli_inactive_temp [$Router wifi_api wifi_getRadioClientInactivityTimeout $idx]
    set cli_inactive_op [lindex [split $cli_inactive_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioClientInactivityTimout is $cli_inactive_op"

    set rad_stats_op [$Router wl -i $if_name scb_timeout]
    if {[string match -nocase "*Client Inactivity Timeout:*$rad_stats_op*" $cli_inactive_temp]} {
        UTF::Message LOG "" "output from wifi_getRadioClientInactivityTimout and wl matching"
    } else {
        UTF::Message LOG "" "STUB FUNCTION"
        #error "output from wifi_getRadioClientInactivityTimout and wl is not matching NOT SUPPORTED"
    }

}

#getApVlanID
#STUB FUNCTION
UTF::Try "wifi_getApVlanID_$radio_intf" {
    set ap_vlan_id_temp [$Router wifi_api wifi_getApVlanID $idx]
    set ap_vlan_id_op [lindex [split $ap_vlan_id_temp] end]

    UTF::Message LOG "" "wifi_getApVlanID_ is $ap_vlan_id_op"
}

#wifi_resetApVlanCfg
#STUB FUNCTION
UTF::Try "wifi_resetApVlanCfg_$radio_intf" {
    set ap_vlan_cfg_temp [$Router wifi_api wifi_resetApVlanCfg $idx]
    set ap_vlan_cfg_op [lindex [split $ap_vlan_cfg_temp] end]

    UTF::Message LOG "" "wifi_resetApVlanCfg is $ap_vlan_cfg_op"
}

#INT wifi_getRadioStatsReceivedSignalLevel(INT radioIndex,INT sig_idx)
#STUB FUNCTION
UTF::Try "wifi_getRadioStatsReceivedSignalLevel_$radio_intf" {

    set radio_stats_rx_temp [$Router wifi_api wifi_getRadioStatsReceivedSignalLevel $idx 0]
    set radio_stats_rx_op [lindex [split $radio_stats_rx_temp] end]
    UTF::Message LOG "" "wifi_getRadioStatsReceivedSignalLevel is $radio_stats_rx_op"
}

#STUB FUNCTION
UTF::Try "wifi_getApBridgeInfo_$radio_intf" {
	$Router wifi_api wifi_getApBridgeInfo $idx
	UTF::Message LOG "" "STUB FUNCTION"
}

#INT wifi_pushApEnable(INT apIndex, BOOL Enable)
UTF::Try "wifi_pushApEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ap"]

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushApEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name ap]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "TRUE" $radio_cnf]} {
	if {$wl_op == 1} {
            UTF::Message LOG "" "STUB FUNCTION"
	}
    } else {
	if {$wl_op == 0} {
            UTF::Message LOG "" "STUB FUNCTION"
	}
    }

}

#INT wifi_pushCountryCode(CHAR *CountryCode)
UTF::Try "wifi_pushCountryCode_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ccode"]

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushCountryCode $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_temp [$Router wl -i $if_name country]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$wl_op*" $radio_cnf]} {
        UTF::Message LOG "" "STUB FUNCTION"
    } else {
        UTF::Message LOG "" "STUB FUNCTION"
    }

}

#INT wifi_getRadioCarrierSenseThresholdRange(INT radioIndex, INT *output)
#STUB FUNCTION
UTF::Try "wifi_getRadioCarrierSenseThresholdRange_$radio_intf" {
    $Router wifi_api wifi_getRadioCarrierSenseThresholdRange $idx
}

#INT wifi_setRadioCarrierSenseThresholdInUse(INT radioIndex, INT threshold)
UTF::Try "wifi_setRadioCarrierSenseThresholdInUse_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ach_refresh_inuse"]

    UTF::Message LOG "" "wifi_setRadioCarrierSenseThresholdInUse is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioCarrierSenseThresholdInUse $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

if {0} {
    set wl_op [$Router wl -i $if_name lpphy_crs]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}
}


#INT wifi_setRadioOperationalDataTransmitRates(INT radioIndex, char *rates)
UTF::Try "wifi_setRadioOperationalDataTransmitRates_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "oper_data_tx_rates"]

    UTF::Message LOG "" "wifi_setRadioOperationalDataTransmitRates is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioOperationalDataTransmitRates $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name rateset]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string compare $radio_cnf $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setRadioTrafficStatsMeasure(INT radioIndex, wifi_radioTrafficStatsMeasure_t *input_struct)
UTF::Try "wifi_setRadioTrafficStatsMeasure_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "traffic_stats_rate"]
    set radio_cnf1 [extract_config_from_file $file_name "traffic_stats_period"]

    UTF::Message LOG "" "wifi_setRadioTrafficStatsMeasure is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioTrafficStatsMeasure $idx $radio_cnf $radio_cnf1
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    if {$idx == 0} {
	set wl_op [$Router nvram get wl0_radio_stats_measure_rate]
    } elseif {$idx == 1} {
        set wl_op [$Router nvram get wl1_radio_stats_measure_rate]
    } elseif {$idx == 2} {
        set wl_op [$Router nvram get wl2_radio_stats_measure_rate]
    }
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        UTF::Message LOG "" "STUB FUNCTION"
        #error "wl output is not matching"
    }

}

#INT wifi_setRadioTrafficStatsRadioStatisticsEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioTrafficStatsRadioStatisticsEnable_$radio_intf" {
    if {$idx ==0} {
	set radio_cnf [extract_config_from_file $file_name "ssid_traffic_stats_2g"]
    } else {
	set radio_cnf [extract_config_from_file $file_name "ssid_traffic_stats_5g"]
    }

    UTF::Message LOG "" "wifi_setRadioTrafficStatsRadioStatisticsEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioTrafficStatsRadioStatisticsEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

}

#STUB FUNCTION
#INT wifi_setRadioIGMPSnoopingEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioIGMPSnoopingEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "igmp_en"]

    UTF::Message LOG "" "wifi_setRadioIGMPSnoopingEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioIGMPSnoopingEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_setApVlanEnable(INT apIndex, BOOL VlanEnabled)
UTF::Try "wifi_setApVlanEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "vlan_en"]

    UTF::Message LOG "" "wifi_setApVlanEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApVlanEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#STUB FUNCTION
#INT wifi_setApVlanID(INT apIndex, INT vlanId)
UTF::Try "wifi_setApVlanID_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "vlan_id"]

    UTF::Message LOG "" "wifi_setApVlanID_ is about to set $radio_cnf"
    $Router wifi_api wifi_setApVlanID $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_createInitialConfigFiles()
UTF::Try "wifi_createInitialConfigFiles_$radio_intf" {
    $Router wifi_api wifi_createInitialConfigFiles
}

#INT wifi_getFTResourceRequestSupported(INT apIndex, BOOL *supported)
UTF::Try "wifi_getFTResourceRequestSupported_$radio_intf" {
    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set conf_temp [$Router wifi_api wifi_getFTResourceRequestSupported $idx]
    set conf_op [lindex [split $conf_temp] end]
}
}

#STUB FUNCTION
#INT wifi_getFTR0KeyLifetime(INT apIndex, UINT *lifetime)
UTF::Try "wifi_getFTR0KeyLifetime_$radio_intf" {

#    set ftr0_key_life_time_temp [$Router wifi_api wifi_getFTR0KeyLifetime $idx]
#    set ftr0_key_life_time_op [lindex [split $ftr0_key_life_time_temp] end]

    UTF::Message LOG "" "wifi_getFTR0KeyLifetime is STUB FUNCTION"
}

#INT wifi_cancelRMBeaconRequest(UINT apIndex,UCHAR *out_DialogToken)
UTF::Try "wifi_cancelRMBeaconRequest_$radio_intf" {

    set cancel_rm_bcn_temp [$Router wifi_api wifi_cancelRMBeaconRequest $idx 0]
    set cancel_rm_beacon_op [lindex [split $cancel_rm_bcn_temp] end]
    UTF::Message LOG "" "wifi_cancelRMBeaconRequest is executed $cancel_rm_beacon_op"

    set wl_op [$Router wl -i $if_name rrm_bcn_req]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$cancel_rm_beacon_op*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        UTF::Message LOG "" "STUB FUNCTION"
        #error "wl output is not matching"
    }

}

#STUB FUNCTION
#INT wifi_getATMEnable(BOOL enable)
UTF::Try "wifi_getATMEnable_$radio_intf" {


    set atm_en_temp [$Router wifi_api wifi_getATMEnable $idx]
    set atm_en_op [lindex [split $atm_en_temp] end]
    UTF::Message LOG "" "wifi_getATMEnable is $atm_en_op"

    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set wl_op [$Router wl -i $if_name atf]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$atm_en_op == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}
}

#STUB FUNCTION
#INT wifi_getApATMAirTimePercent(BOOL enable)
UTF::Try "wifi_getApATMAirTimePercent_$radio_intf" {

    set atm_airtime_temp [$Router wifi_api wifi_getApATMAirTimePercent $idx]
    set atm_airtime_op [lindex [split $atm_airtime_temp] end]
    UTF::Message LOG "" "wifi_getApATMAirTimePercent is $atm_airtime_op"

    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set wl_op [$Router wl -i $if_name atf]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$atm_airtime_op == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}
}

#STUB FUNCTION
#INT wifi_getApATMSta(BOOL enable)
UTF::Try "wifi_getApATMSta$radio_intf" {

    set atm_sta_temp [$Router wifi_api wifi_getApATMSta $idx]
    set atm_sta_op [lindex [split $atm_sta_temp] end]
    UTF::Message LOG "" "wifi_getApATMSta is $atm_sta_op"

    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set wl_op [$Router wl -i $if_name nar_atf_us]
    UTF::Message LOG "" "wl output is $wl_op"
    if {$atm_sta_op == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}
}

#STUB FUNCTION
#INT wifi_setRadioReverseDirectionGrantEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioReverseDirectionGrantEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "reverse_grant_en"]

    UTF::Message LOG "" "wifi_setRadioReverseDirectionGrantEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioReverseDirectionGrantEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_setRadioDeclineBARequestEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioDeclineBARequestEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bar_decline_en"]

    UTF::Message LOG "" "wifi_setRadioDeclineBARequestEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDeclineBARequestEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_getBandSteeringOverloadInactiveTime (INT radioIndex, INT *overloadInactiveTime)
UTF::Try "wifi_getBandSteeringOverloadInactiveTime_$radio_intf" {
    $Router wifi_api wifi_getBandSteeringOverloadInactiveTime $idx
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_setBandSteeringOverloadInactiveTime (INT radioIndex, INT overloadInactiveTime)
UTF::Try "wifi_setBandSteeringOverloadInactiveTime_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "steer_phyrate"]

    UTF::Message LOG "" "wifi_setBandSteeringOverloadInactiveTime is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringOverloadInactiveTime $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set bs_phyrate_temp [$Router wifi_api wifi_getBandSteeringPhyRateThreshold $idx]
    set wl_op [lindex [split $bs_phyrate_temp] end]

    UTF::Message LOG "" "wl output is $wl_op"
    if {$radio_cnf == $wl_op} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "STUB FUNCTION"
#	error "wl output not matching $wl_op"
    }
}

#STUB FUNCTION
#INT wifi_setBandSteeringIdleInactiveTime (INT radioIndex, INT idleInactiveTime)
UTF::Try "wifi_setBandSteeringIdleInactiveTime_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "steer_inactive"]

    UTF::Message LOG "" "wifi_setBandSteeringIdleInactiveTime is about to set $radio_cnf"
    $Router wifi_api wifi_setBandSteeringIdleInactiveTime $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_getBandSteeringIdleInactiveTime (INT radioIndex, INT *idleInactiveTime)
UTF::Try "wifi_getBandSteeringIdleInactiveTime_$radio_intf" {
    $Router wifi_api wifi_getBandSteeringIdleInactiveTime $idx
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_getBandSteeringLog(INT record_index, ULONG *pSteeringTime, CHAR *pClientMAC, INT *pSourceSSIDIndex, INT *pDestSSIDIndex, INT *pSteeringReason)
UTF::Try "wifi_getBandSteeringLog_$radio_intf" {
    $Router wifi_api wifi_getBandSteeringLog $idx
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_setFTResourceRequestSupported(INT apIndex, BOOL *supported)
UTF::Try "wifi_setFTResourceRequestSupported_$radio_intf" {
    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set radio_cnf [extract_config_from_file $file_name "fbt_ap"]

    UTF::Message LOG "" "wifi_setFTResourceRequestSupported is about to set $radio_cnf"
    $Router wifi_api wifi_setFTResourceRequestSupported $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    UTF::Message LOG "" "STUB FUNCTION"
    set wl_op [$Router wl -i $if_name fbt_ap]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "STUB FUNCTION"
    }
}
}

#STUB FUNCTION
#INT wifi_setFTR0KeyLifetime(INT apIndex, UINT *lifetime)
UTF::Try "wifi_setFTR0KeyLifetime_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ft_key_lifetime"]

    UTF::Message LOG "" "wifi_setFTR0KeyLifetime is about to set $radio_cnf"
    $Router wifi_api wifi_setFTR0KeyLifetime $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_setATMEnable(BOOL enable)
UTF::Try "wifi_setATMEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "atf"]

    UTF::Message LOG "" "wifi_setATMEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setATMEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set wl_op [$Router wl -i $if_name atf]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}
}

#STUB FUNCTION
#INT wifi_setApATMAirTimePercent(INT apIndex, UINT ap_AirTimePercent)
UTF::Try "wifi_setApATMAirTimePercent_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "atf_perc"]

    UTF::Message LOG "" "wifi_setApATMAirTimePercent is about to set $radio_cnf"
    $Router wifi_api wifi_setApATMAirTimePercent $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    UTF::Message LOG "" "STUB FUNCTION"
if {0} {
    set wl_op [$Router wl -i $if_name atf]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}
}

#STUB FUNCTION
#INT wifi_setApATMSta(INT apIndex, UCHAR *sta_MAC, UINT sta_AirTimePercent)
UTF::Try "wifi_setApATMSta_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "radio_en"]

    UTF::Message LOG "" "wifi_setApATMSta is about to set $radio_cnf"
    $Router wifi_api wifi_setApATMSta $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
UTF::Try "wifi_getApAssociatedDeviceTidStatsResult_$radio_intf" {
        if {$idx == 0} {
                $Router wifi_api wifi_getApAssociatedDeviceTidStatsResult $idx 00:10:18:FB:D8:26
        } elseif {$idx == 1} {
                $Router wifi_api wifi_getApAssociatedDeviceTidStatsResult $idx DC:EF:CA:5F:78:22
        } elseif {$idx == 2} {
		set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
                $Router wifi_api wifi_getApAssociatedDeviceTidStatsResult $to_exec DC:EF:CA:5F:78:22
        }
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#INT wifi_getApAuthenticatedDevices(INT apIndex, mac_t **mac_array, UINT *output_array_size)
UTF::Try "wifi_getApAuthenticatedDevices_$radio_intf" {
    $Router wifi_api wifi_getApAuthenticatedDevices $idx
    UTF::Message LOG "" "STUB FUNCTION"
}

#STUB FUNCTION
#void wifi_apAuthenticatedEvent_callback_register(wifi_apAuthEvent_callback callback_proc)
UTF::Try "wifi_apAuthenticatedEvent_callback_register_$radio_intf" {
    UTF::Message LOG "" "STUB FUNCTION"
}

#P5END#
   }

}

proc test_p6_commands {Router STA} {
    upvar {} {} ;# gives access to unamed array from getopts

    puts "JST6:inside test_p6_commands "

    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(ap) 0]
    }

    UTF::Message LOG "" "JST4: Trying to execute HAL P5 commands"

    set kk [$Router wifi_api wifi_getRadioNumberOfEntries]

    set num_radios [string index $kk end]

    puts "mum radios: $num_radios"

    if {$num_radios > 3} {
        UTF::Message ERROR "" "num_radios is not correct $num_radios"
        return
    }
    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        UTF::Message LOG "" "Radio index: $idx"

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        } elseif {$idx == 2} {
                set radio_intf "6g"
		intf_down_up_restart $Router $if_name $idx
		UTF::Sleep 60
        }
#TOADDP6
UTF::Try "wifi_setCountryIe_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getCountryIe $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setCountryIe $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getCountryIe $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setCountryIe $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

}

UTF::Try "wifi_getCountryIe_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getCountryIe $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {$idx == 0} {
        set nvram_op [extract_config_from_file $nvram_show_file "wl0_reg_mode"]
    } elseif {$idx == 1} {
        set nvram_op [extract_config_from_file $nvram_show_file "wl1_reg_mode"]
    } elseif {$idx == 2} {
        set nvram_op [extract_config_from_file $nvram_show_file "wl2_reg_mode"]
    }

    UTF::Message LOG "" "is executed $nvram_op"

    if {[string match -nocase "*off*" $nvram_op]} {
	if {[string match -nocase "*FALSE*" $ap_get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
        if {[string match -nocase "*TRUE*" $ap_get_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching"
        }
    }
}

UTF::Try "wifi_setP2PCrossConnect_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getP2PCrossConnect $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setP2PCrossConnect  $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getP2PCrossConnect $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setP2PCrossConnect $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

UTF::Try "wifi_getP2PCrossConnect_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getP2PCrossConnect $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*FALSE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*TRUE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

UTF::Try "wifi_setDownStreamGroupAddress_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getDownStreamGroupAddress $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setDownStreamGroupAddress  $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getDownStreamGroupAddress $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setDownStreamGroupAddress $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

UTF::Try "wifi_getDownStreamGroupAddress_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getDownStreamGroupAddress $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*FALSE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*TRUE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

UTF::Try "wifi_setBssLoad_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getBssLoad $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setBssLoad $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getBssLoad $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setBssLoad $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

UTF::Try "wifi_getBssLoad_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getBssLoad $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*FALSE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*TRUE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

UTF::Try "wifi_setProxyArp_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getProxyArp $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setProxyArp $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getProxyArp $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setProxyArp $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

UTF::Try "wifi_getProxyArp_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getProxyArp $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*FALSE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*TRUE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

UTF::Try "wifi_setLayer2TrafficInspectionFiltering_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getLayer2TrafficInspectionFiltering $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setLayer2TrafficInspectionFiltering $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getLayer2TrafficInspectionFiltering $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setLayer2TrafficInspectionFiltering $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

UTF::Try "wifi_getLayer2TrafficInspectionFiltering_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getLayer2TrafficInspectionFiltering $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*FALSE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*TRUE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

UTF::Try "wifi_pushApHotspotElement_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getApHotspotElement $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "FALSE" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_pushApHotspotElement $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getApHotspotElement $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*TRUE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "FALSE" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_pushApHotspotElement $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

UTF::Try "wifi_getApHotspotElement_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getApHotspotElement $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*FALSE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*TRUE*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output is not matching"
    }
}

UTF::Try "wifi_getApRoamingConsortiumElement_$radio_intf" {

#root@brcm93390smwvg2:~# wifi_api wifi_getApRoamingConsortiumElement 0
#wifi_getApRoamingConsortiumElement count=11

    set ap_get_op [$Router wifi_api wifi_getApRoamingConsortiumElement $ap_index]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*wifi_getApRoamingConsortiumElement count=*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}

#wifi_api wifi_pushApRoamingConsortiumElement 0 "12345678;abcdef;0987654321;001BC504BD"
#main: index=0 string=12345678 len=4
#main: index=1 string=abcdef len=3
#main: index=2 string=0987654321 len=5
#main: index=3 string=001BC504BD len=5
#main: Skip index=3 string=001BC504BD len=5
#wifi_pushApRoamingConsortiumElement 12345678;abcdef;0987654321;001BC504BD
#root@brcm93390smwvg2:/rdklogs/logs#
#
#verify
#nvram show | grep wl0_oui
#size: 43255 bytes (87817 left)
#wl0_oui_extra=1
#wl0_ouilist=12345678:1;abcdef:1;0987654321:1
#root@brcm93390smwvg2:/rdklogs/logs#
#
UTF::Try "wifi_pushApRoamingConsortiumElement_$radio_intf" {

    set radio_cnf [extract_config_from_file $file_name "push_ap_roam_consort_element"]

    set api_op [$Router wifi_api wifi_pushApRoamingConsortiumElement $ap_index $radio_cnf]
    UTF::Sleep 5

    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    UTF::Sleep 10

    if {$idx == 0} {
	set nvram_op [extract_config_from_file $nvram_show_file "wl0_ouilist"]
    } elseif {$idx == 1} {
	set nvram_op [extract_config_from_file $nvram_show_file "wl1_ouilist"]
    } elseif {$idx == 2} {
	set nvram_op [extract_config_from_file $nvram_show_file "wl2_ouilist"]
    }

    UTF::Message LOG "" "NVRAM output is $nvram_op"
    if {[string match -nocase "*$radio_cnf*" $nvram_op]} {
	UTF::Message LOG "" "NVRAM output is matching"
    } else {
	error "NVRAM output is not matching"
    }
}


UTF::Try "wifi_setRadioDfsMoveBackEnable_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getRadioDfsMoveBackEnable $idx]
    UTF::Message LOG "" "actual value is $actual_val"
    UTF::Message LOG "" "LGI API"

if {$idx == 1} {
    if {[string match -nocase "*Disable*" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setRadioDfsMoveBackEnable $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getRadioDfsMoveBackEnable $idx]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*Enable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
	}
    } else {
	if {[string match -nocase "*Disable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
	}

    }

    #reset
    if {[string match -nocase "*Disable*" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setRadioDfsMoveBackEnable $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}
}

UTF::Try "wifi_getRadioDfsMoveBackEnable_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getRadioDfsMoveBackEnable $idx]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*disable*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*enable*" $ap_get_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
    }
}

#INT wifi_setDownlinkDataAckType(INT radio_index, wifi_dl_data_ack_type_t ack_type)
UTF::Try "wifi_setDownlinkDataAckType_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getTWTParams(CHAR *sta, wifi_twt_params_t *twt_params)
UTF::Try "wifi_getTWTParams_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_get80211axDefaultParameters(INT apIndex, wifi_80211ax_params_t *params)
UTF::Try "wifi_get80211axDefaultParameters_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_enableCSIEngine(INT apIndex, mac_address_t sta, BOOL enable)
UTF::Try "wifi_enableCSIEngine_$radio_intf" {

    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_6g"]
    }

    set en_csi_temp [$Router wifi_api wifi_enableCSIEngine $ap_index enable $radio_cnf]
    set en_csi_op [$Router wifi_api wifi_csitest $ap_index $radio_cnf]

#1) basic test
#wifi_api wifi_enableCSIEngine 0 disable 3c:77:e6:4b:28:88
#wifi_api wifi_enableCSIEngine 0 enable 3c:77:e6:4b:28:88


#wifi_api wifi_getApAssociatedDeviceDiagnosticResult3 0 3c:77:e6:4b:28:88
#wifi_api wifi_csitest 0 3c:77:e6:4b:28:88

#2) a test log w/ 2 associated STAs
# wifi_api wifi_csitest 0 3c:77:e6:4b:28:88 48:26:2C:78:9B:C9

# Enable CSI
# mac:3c:77:e6:4b:28:88
# wldm_setCsiMon Enabel CSI mode
# add Mac:3c:77:e6:4b:28:88
    if {[string match -nocase "*Enable CSI*" $en_csi_op]} {
	if {[string match -nocase "*$radio_cnf*" $en_csi_op]} {
	    UTF::Message LOG "" "CSI is enabled and the STA is present"
	} else {
	    error "CSI is  enabled but not STA"
	}
    } else {
	error "CSI is not enabled"
    }
}

#INT wifi_sendDataFrame(INT apIndex, mac_address_t sta, UCHAR *data, UINT len, BOOL insert_llc, UINT eth_proto, wifi_data_priority_t prio)
UTF::Try "wifi_sendDataFrame_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_enableGreylistAccessControl(BOOL enable)
UTF::Try "wifi_enableGreylistAccessControl_$radio_intf" {
#wifi_api wifi_enableGreylistAccessControl 1
#wifi_api wifi_apply


#root@brcm93390smwvg2:~# nvram show | grep greylist
#size: 14846 bytes (116226 left)
#wl0.2_rdk_radius_greylist=1
#wl0.4_rdk_radius_greylist=1
    if {$idx == 0} {
	set nvram_actual [extract_config_from_file $nvram_show_file "wl0.1_rdk_radius_greylist"]
    } elseif {$idx == 1} {
        set nvram_actual [extract_config_from_file $nvram_show_file "wl1.1_rdk_radius_greylist"]
    } elseif {$idx == 2} {
        set nvram_actual [extract_config_from_file $nvram_show_file "wl2.1_rdk_radius_greylist"]
    } else {
	error "Index not matching"
    }

    if {$nvram_actual == 0} {

	UTF::Message LOG "" "NVRAM actual is 0"

	$Router wifi_api wifi_enableGreylistAccessControl 1
	UTF::Sleep 20

	UTF::Message LOG "" "path info is $path_info"
	set file_name "$path_info/Test/hal_set_config"
	UTF::Message LOG "" "File name is $file_name"
	set nvram_show [$Router nvram show]

	set nvram_show_file "$path_info/nvram_show.txt"
	set fp [open "nvram_show.txt" w+]
	puts $fp $nvram_show
	close $fp

	if {$idx == 0} {
        	set nvram_op [extract_config_from_file $nvram_show_file "wl0.1_rdk_radius_greylist"]
	} elseif {$idx == 1} {
		set nvram_op [extract_config_from_file $nvram_show_file "wl1.1_rdk_radius_greylist"]
	} elseif {$idx == 2} {
		set nvram_op [extract_config_from_file $nvram_show_file "wl2.1_rdk_radius_greylist"]
	}

	if {$nvram_op == 1} {
		UTF::Message LOG "" "NVRAM output matching"
	} else {
		error "NVRAM output not matching $nvram_op"
	}

    } elseif {$nvram_actual == 1} {
	UTF::Message LOG "" "NVRAM actual is 1"

	$Router wifi_api wifi_enableGreylistAccessControl 0
	UTF::Sleep 20

	UTF::Message LOG "" "path info is $path_info"
	set file_name "$path_info/Test/hal_set_config"
	UTF::Message LOG "" "File name is $file_name"
	set nvram_show [$Router nvram show]

	set nvram_show_file "$path_info/nvram_show.txt"
	set fp [open "nvram_show.txt" w+]
	puts $fp $nvram_show
	close $fp

	if {$idx == 0} {
        	set nvram_op [extract_config_from_file $nvram_show_file "wl0.1_rdk_radius_greylist"]
	} elseif {$idx == 1} {
		set nvram_op [extract_config_from_file $nvram_show_file "wl1.1_rdk_radius_greylist"]
	} elseif {$idx == 2} {
		set nvram_op [extract_config_from_file $nvram_show_file "wl2.1_rdk_radius_greylist"]
	}

	if {$nvram_op == 0} {
		UTF::Message LOG "" "NVRAM output matching"
	} else {
		error "NVRAM output not matching $nvram_op"
	}

    }

#reset
    $Router wifi_api wifi_enableGreylistAccessControl $nvram_actual
    UTF::Sleep 20
}

#INT wifi_setApDASRadiusServer(INT apIndex, CHAR *IPAddress, UINT port, CHAR *RadiusdasSecret)
UTF::Try "wifi_setApDASRadiusServer_$radio_intf" {

    set das_rad_ip 10.0.0.123
    set das_rad_port 3799
    set das_key secret

    set rad_das_op [$Router wifi_api wifi_setApDASRadiusServer $ap_index $das_rad_ip $das_rad_port $das_key]
    $Router wifi_api wifi_apply

    UTF::Sleep 10
##wifi_api wifi_apply
##Then ran 'wifi_api wifi_getApDASRadiusServer 0', confirmed the output was correct.
##root@brcm93390smwvg2:~# wifi_api wifi_getApDASRadiusServer 0
##DAS client IP Address:192.168.1.123
##DAS Port:3799
##DAS Secret:secret
    set get_api_op [$Router wifi_api wifi_getApDASRadiusServer $ap_index]

    if {[string match -nocase "*DAS client IP Address*10.0.0*" $get_api_op]
	&& [string match -nocase "*DAS Secret:secret*" $get_api_op]} {
	UTF::Message LOG "" "get API output is matching"
    } else {
	error "get API output is not matching"
    }
}

#INT wifi_getApDASRadiusServer(INT apIndex, CHAR *IP_output, UINT *Port_output, CHAR *RadiusdasSecret_output)
UTF::Try "wifi_getApDASRadiusServer_$radio_intf" {
    set get_api_op [$Router wifi_api wifi_getApDASRadiusServer $ap_index]
#wifi_api wifi_setApDASRadiusServer 0 192.168.1.123 3799 secret
#wifi_api wifi_apply
#Then ran 'wifi_api wifi_getApDASRadiusServer 0', confirmed the output was correct.
#root@brcm93390smwvg2:~# wifi_api wifi_getApDASRadiusServer 0
#DAS client IP Address:192.168.1.123
#DAS Port:3799
#DAS Secret:secret
    if {[string match -nocase "*DAS client IP Address*10.0.0*" $get_api_op]} {
	UTF::Message LOG "" "get API output is matching"
    } else {
	error "get API output is not matching"
    }
}

#INT wifi_pushMultiPskKeys(INT apIndex, wifi_key_multi_psk_t *keys, INT keysNumber)
UTF::Try "wifi_pushMultiPskKeys_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getMultiPskKeys(INT apIndex, wifi_key_multi_psk_t *keys, INT keysNumber)
UTF::Try "wifi_getMultiPskKeys_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getMultiPskClientKey(INT apIndex, mac_address_t mac, wifi_key_multi_psk_t *key)
UTF::Try "wifi_getMultiPskClientKey_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getRadioChannelWeights(INT radioIndex, ULONG *output_weights)
UTF::Try "wifi_getRadioChannelWeights_$radio_intf" {

    set get_api_op [$Router wifi_api wifi_getRadioChannelWeights $idx]

    foreach j $get_api_op {
	if {$j <= 100} {
	     UTF::Message LOG "" "channel weight is less than 100"
	} else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
	}
    }
}

#INT wifi_setRadioChannelWeights(INT radioIndex, const ULONG *output_weights)
UTF::Try "wifi_setRadioChannelWeights_$radio_intf" {

    set get_api_val [$Router wifi_api wifi_getRadioChannelWeights $idx]

    set api_op [$Router wifi_api wifi_setRadioChannelWeights $idx 1 11 21]
    UTF::Sleep 10

    set get_api_op [$Router wifi_api wifi_getRadioChannelWeights $idx]

    foreach j $get_api_op {
        if {$j <= 100} {
             UTF::Message LOG "" "channel weight is less than 100"
        } else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
        }
    }

    set api_op [$Router wifi_api wifi_setRadioChannelWeights $idx $get_api_val]
    UTF::Sleep 10
}

#INT wifi_getRadioExcludeDfs(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioExcludeDfs_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getRadioExcludeDfs $idx]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {$idx == 0} {
        set nvram_op [extract_config_from_file $nvram_show_file "wl0_reg_mode"]
    } elseif {$idx == 1} {
        set nvram_op [extract_config_from_file $nvram_show_file "wl1_reg_mode"]
    } elseif {$idx == 2} {
        set nvram_op [extract_config_from_file $nvram_show_file "wl2_reg_mode"]
    }

    UTF::Message LOG "" "is executed $nvram_op"

    if {[string match -nocase "*off*" $nvram_op]} {
        if {[string match -nocase "*Disable*" $ap_get_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
        }
    } else {
        if {[string match -nocase "*Enable*" $ap_get_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
        }
    }
}

#INT wifi_setRadioExcludeDfs(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioExcludeDfs_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getRadioExcludeDfs $idx]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "*Disable*" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setRadioExcludeDfs $idx $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getRadioExcludeDfs $idx]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*Enable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
	}
    } else {
	if {[string match -nocase "*disable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
	}

    }

    #reset
    if {[string match -nocase "*Disable*" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setRadioExcludeDfs $idx $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

#INT wifi_getRADIUSAcctEnable(INT band, BOOL *enable)
UTF::Try "wifi_getRADIUSAcctEnable_$radio_intf" {
    set ap_get_op [$Router wifi_api wifi_getRADIUSAcctEnable $idx]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*Disable*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*Enable*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
#        error "wl output is not matching"
    }
}

#INT wifi_setRADIUSAcctEnable(INT band, BOOL enable)
UTF::Try "wifi_setRADIUSAcctEnable_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getRADIUSAcctEnable $idx]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "*Disable*" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setRADIUSAcctEnable $idx $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getRADIUSAcctEnable $idx]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*Enable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	UTF::Message LOG "" "LGI API"
#        error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*disable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	UTF::Message LOG "" "LGI API"
#        error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "*Disable*" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setRADIUSAcctEnable $idx $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

#INT wifi_getApSecurityAcctServer(INT apIndex, CHAR *IP_output, UINT *Port_output, CHAR *AcctSecret_output)
UTF::Try "wifi_getApSecurityAcctServer_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

#Checked hostapd was running, below items were added to hostapd config file.
##acct_server_addr=10.0.0.22
##acct_server_port=1814
##acct_server_shared_secret=primary

}

#INT wifi_setApSecurityAcctServer(INT apIndex, CHAR *IPAddress, UINT port, CHAR *AcctSecret)
UTF::Try "wifi_setApSecurityAcctServer_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"
#nvram set wl0_radius_acc_enabled=1
#nvram set wl0_radius_acc_ipaddr=10.0.0.22
#nvram set wl0_radius_acc_port=1814
#nvram set wl0_radius_acc_secret=primary
#rc restart

#Checked hostapd was running, below items were added to hostapd config file.
#acct_server_addr=10.0.0.22
#acct_server_port=1814
#acct_server_shared_secret=primary

}

#INT wifi_getApSecuritySecondaryAcctServer(INT apIndex, CHAR *IP_output, UINT *Port_output, CHAR *AcctSecret_output)
UTF::Try "wifi_getApSecuritySecondaryAcctServer_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

#Checked hostapd was running, below items were added to hostapd config file.
#acct_server_addr=10.0.0.22
#acct_server_port=1814
#acct_server_shared_secret=primary
#acct_server_addr=10.0.0.33
#acct_server_port=1815
#acct_server_shared_secret=secondary

}

#INT wifi_setApSecuritySecondaryAcctServer(INT apIndex, CHAR *IPAddress, UINT port, CHAR *AcctSecret)
UTF::Try "wifi_setApSecuritySecondaryAcctServer_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"
#Continued to run below commands to configure secondary primary accouting server.
#wl0_radius_acc2_ipaddr=10.0.0.33
#wl0_radius_acc2_port=1815
#wl0_radius_acc2_secret=secondary
#rc restart

}

#INT wifi_getApSecurityAcctInterimInterval(INT apIndex, UINT *Interval_output)
UTF::Try "wifi_getApSecurityAcctInterimInterval_$radio_intf" {

}

#INT wifi_setApSecurityAcctInterimInterval(INT apIndex, UINT NewInterval)
UTF::Try "wifi_setApSecurityAcctInterimInterval_$radio_intf" {

}

#INT wifi_setApRadiusTransportInterface(UINT RadiusInterface)
UTF::Try "wifi_setApRadiusTransportInterface_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getSupportRatesBitmapControlFeature(BOOL *enable)
UTF::Try "wifi_getSupportRatesBitmapControlFeature_$radio_intf" {
    set ap_get_op [$Router wifi_api wifi_getSupportRatesBitmapControlFeature $idx]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*Disable*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*Enable*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
#        error "wl output is not matching"
    }
}

#INT wifi_setSupportRatesBitmapControlFeature(BOOL enable)
UTF::Try "wifi_setSupportRatesBitmapControlFeature_$radio_intf" {
    set actual_val [$Router wifi_api wifi_getSupportRatesBitmapControlFeature $idx]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "*Disable*" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setSupportRatesBitmapControlFeature $idx $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getSupportRatesBitmapControlFeature $idx]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*Enable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#            error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*disable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#            error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "*Disable*" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setSupportRatesBitmapControlFeature $idx $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

}

#INT wifi_getSupportRatesDisableBasicRates(INT ssidIndex, CHAR *rate)
UTF::Try "wifi_getSupportRatesDisableBasicRates_$radio_intf" {

}

#INT wifi_setSupportRatesDisableBasicRates(INT ssidIndex, CHAR *rate)
UTF::Try "wifi_setSupportRatesDisableBasicRates_$radio_intf" {

#So, for example to disable 1Mbps and 2Mbps rates on 2.4G, one can use:
#wifi_setSupportRatesDisableBasicRates(0, "0xFFFC")
#and the example disable  the rate 6Mbps on 5GHz is:
#wifi_setSupportRatesDisableBasicRates(1, "0xFFFE")

}

if {0} {
#INT wifi_getSupportRatesDisableSupportedRates(INT ssidIndex, CHAR *rate)
UTF::Try "wifi_getSupportRatesDisableSupportedRates_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_setSupportRatesDisableSupportedRates(INT ssidIndex, CHAR *rate)
UTF::Try "wifi_setSupportRatesDisableSupportedRates_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"
#https://bcawlan-rb.sj.broadcom.net/r/175576/
#
}

#INT wifi_getSoftBlockEnable(BOOL *enable)
UTF::Try "wifi_getSoftBlockEnable_$radio_intf" {

    set ap_get_op [$Router wifi_api wifi_getSoftBlockEnable $idx]
    UTF::Message LOG "" "is executed $ap_get_op"

    if {[string match -nocase "*Disable*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*Enable*" $ap_get_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "API is NOT SUPPORTED"
#	error "wl output is not matching"
    }
}

#INT wifi_setSoftBlockEnable(BOOL enable)
UTF::Try "wifi_setSoftBlockEnable_$radio_intf" {

#nvram set ssd_enable=1
#nvram set wl1_ssd_type=1

#nvram set wl0_ssd_type=2
#nvram set wl1.2_ssd_type=2

#nvram set wl0_ssid=Broadcom-Tom-2G
#nvram set wl1_ssid=Broadcom-Tom-5G

#(some condition for ssd)
#nvram set wl1.2_bss_enabled=1
#nvram set wl1.2_mode=ap

    set actual_val [$Router wifi_api wifi_getSoftBlockEnable $idx]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "*Disable*" $actual_val]} {
	set to_set 1
    } else {
	set to_set 0
    }

    set ap_set_op [$Router wifi_api wifi_setSoftBlockEnable $idx $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getSoftBlockEnable $idx]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 1} {
	if {[string match -nocase "*Enable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "API is NOT SUPPORTED"
#	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*disable*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "API is NOT SUPPORTED"
#	    error "wl output is not matching"
	}

    }

    #reset
    if {[string match -nocase "*Disable*" $actual_val]} {
        set to_set 0
    } else {
        set to_set 1
    }

    set ap_reset_op [$Router wifi_api wifi_setSoftBlockEnable $idx $to_set]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

#INT wifi_clearSoftBlockBlacklist()
UTF::Try "wifi_clearSoftBlockBlacklist_$radio_intf" {
    $Router wifi_api wifi_clearSoftBlockBlacklist
    UTF::Sleep 20

    set wl_op [$Router wl -i $if_name mac]

    if {[string match -nocase "" $wl_op]} {
	UTF::Message LOG "" "wl output matching"
    } else {
	UTF::Message LOG "" "API is NOT SUPPORTED"
#	error "wl output not matching"
    }
}

#INT wifi_getSoftBlockBlacklistEntries(INT band, ULONG *num, wifi_softblock_mac_table_t **table)
UTF::Try "wifi_getSoftBlockBlacklistEntries_$radio_intf" {
#wifi_api wifi_getSoftBlockBlacklistEntries 5
#SoftBlock number=1
#i=0 time=2020-9-21@18:8:2 mac=F0:99:BF:76:FF:54
#root@brcm93390smwvg2:~#
    set num_entries 5
    set api_op [$Router wifi_api wifi_getSoftBlockBlacklistEntries $num_entries]

    if {[string match -nocase "*SoftBlock number=1*" $api_op]} {
	UTF::Message LOG "" "wl output matching"
    } else {
	UTF::Message LOG "" "LGI API"
#	error "wl output not matching $api_op"
    }
}

#INT wifi_getApWmmOgAckPolicy(INT apIndex, BOOL *output)
UTF::Try "wifi_getApWmmOgAckPolicy_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is STUB FUNCTION"

}

#INT wifi_getRadioConfiguredChannel(INT radioIndex,ULONG *cfgdChannel)
UTF::Try "wifi_getRadioConfiguredChannel_$radio_intf" {
#root@brcm93390smwvg2:~# wifi_api wifi_getRadioConfiguredChannel 0
#wifi_getRadioConfiguredChannel: 0

    set api_op [$Router wifi_api wifi_getRadioConfiguredChannel $idx]

    if {[string match -nocase "*ConfiguredChannel: 0*" $api_op]} {
        UTF::Message LOG "" "wl output matching"
    } else {
	UTF::Message LOG "" "LGI API"
#        error "wl output not matching $api_op"
    }
}

#INT wifi_getRadioRunningChannel(INT radioIndex,ULONG *cfgdChannel)
UTF::Try "wifi_getRadioRunningChannel_$radio_intf" {
#root@brcm93390smwvg2:~# wifi_api wifi_getRadioRunningChannel 0
#wifi_getRadioRunningChannel: 11

    set api_op [$Router wifi_api wifi_getRadioRunningChannel $idx]

    set chan_temp [$Router wl -i $if_name chanspec]
    set chan_op [lindex [split $chan_temp] 0]

    if {[string match -nocase "*RunningChannel: $chan_op*" $api_op]} {
        UTF::Message LOG "" "wl output matching"
    } else {
	UTF::Message LOG "" "LGI API"
#        error "wl output not matching $api_op"
    }
}

#INT wifi_setRadiusOperatorName(INT band, CHAR *op_name)
UTF::Try "wifi_setRadiusOperatorName_$radio_intf" {

#Ran 'wifi_api wifi_getRadiusOperatorName 0' to get RADIUS operator name before setting it, confirmed the result is expected.
#root@brcm93390smwvg2:~# wifi_api wifi_getRadiusOperatorName 0
#wifi_getRadiusOperatorName returned error
#Usage : wifi_api wifi_getRadiusOperatorName <AP Index>

#Ran below commands to config operator name on 2G, and confirmed the result is correct
#wifi_api wifi_setRadiusOperatorName 0 operator
#wifi_api wifi_apply


#wifi_api wifi_getRadiusOperatorName 0
#root@brcm93390smwvg2:~# wifi_api wifi_getRadiusOperatorName 0
#RADIUS operator name: operator


#nvram get wl0_radius_operator_name
#root@brcm93390smwvg2:~# nvram get wl0_radius_operator_name
#126:s:operator

    set op_name_temp "operator"
    set api_op [$Router wifi_api wifi_setRadiusOperatorName $idx $op_name_temp]
    UTF::Message LOG "" "executed command to set operator name $op_name_temp"
    UTF::Sleep 2

    set get_api_op [$Router wifi_api wifi_getRadiusOperatorName $idx]

    if {[string match -nocase "*$op_name_temp*" $get_api_op]} {
	UTF::Message LOG "" "wl output matching"
    } else {
	UTF::Message LOG "" "LGI API"
#	error "wl output not matching $get_api_op"
    }
}

#INT wifi_getRadiusOperatorName(INT index, CHAR *op_name)
UTF::Try "wifi_getRadiusOperatorName_$radio_intf" {

    set get_api_op [$Router wifi_api wifi_getRadiusOperatorName $idx]
    UTF::Message LOG "" "LGI API"

    if {$idx == 0} {
	set nvram_op [extract_config_from_file $nvram_show_file "wl0_radius_operator_name"]
    } elseif {$idx == 1} {
	set nvram_op [extract_config_from_file $nvram_show_file "wl1_radius_operator_name"]
    } elseif {$idx == 2} {
	set nvram_op [extract_config_from_file $nvram_show_file "wl2_radius_operator_name"]
    }
    UTF::Sleep 2

    if {[[string match -nocase "*$nvram_op*" $get_api_op]]} {
        UTF::Message LOG "" "wl output matching"
    } else {
	UTF::Message LOG "" "LGI API"
#        error "wl output not matching $get_api_op $nvram_op"
    }
}

#INT wifi_getRadiusLocationData(INT index, CHAR *loc_data)
UTF::Try "wifi_getRadiusLocationData_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_setRadiusLocationData(INT band, CHAR *loc_data)
UTF::Try "wifi_setRadiusLocationData_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getApRadiusReAuthInterval(INT apIndex, UINT *interval)
UTF::Try "wifi_getApRadiusReAuthInterval_$radio_intf" {
#Then ran below command 'wifi_api wifi_getApRadiusReAuthInterval 8', confirmed the setting is correct
#root@brcm93390smwvg2:~# wifi_api wifi_getApRadiusReAuthInterval 8
#RADIUS reauth interval: 7200

#Then ran 'nvram get wl0.4_radius_reauth_interval', confirmed nvram is correct
#root@brcm93390smwvg2:~# nvram get wl0.4_radius_reauth_interval
#7200

    UTF::Message LOG "" "API is NOT SUPPORTED"
    set actual_val [$Router wifi_api wifi_getApRadiusReAuthInterval $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    set nvram_op [extract_config_from_file $nvram_show_file "radius_reauth_interval"]

    UTF::Message LOG "" "is executed $nvram_op"

    if {[string match -nocase "*$nvram_op*" $actual_val]} {
            UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
#        error "wl output is not matching"
    }

}

#INT wifi_setApRadiusReAuthInterval(INT apIndex, UINT interval)
UTF::Try "wifi_setApRadiusReAuthInterval_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getApRadiusReAuthInterval $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "*3600*" $actual_val]} {
	set to_set 7200
    } else {
	set to_set 3600
    }

    set ap_set_op [$Router wifi_api wifi_setApRadiusReAuthInterval $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getApRadiusReAuthInterval $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 7200} {
	if {[string match -nocase "*7200*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*3600*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#	    error "wl output is not matching"
	}

    }

    #reset
    set ap_reset_op [$Router wifi_api wifi_setApRadiusReAuthInterval $ap_index $actual_val]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

#INT wifi_getDefaultSsid(INT index, CHAR *default_ssid)
UTF::Try "wifi_getDefaultSsid_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getDefaultPassword(INT index, CHAR *default_password)
UTF::Try "wifi_getDefaultPassword_$radio_intf" {
#NOT SUPPORTED
    UTF::Message LOG "" "API is NOT SUPPORTED"

}

#INT wifi_getApPMKCacheInterval(INT apIndex, UINT *output_uint)
UTF::Try "wifi_getApPMKCacheInterval_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getApPMKCacheInterval $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    set nvram_op [extract_config_from_file $nvram_show_file "wpa_pmk_lifetime"]

    UTF::Message LOG "" "is executed $nvram_op"

    if {[string match -nocase "*$nvram_op*" $actual_val]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
#	error "wl output is not matching"
    }

}

#INT wifi_setApPMKCacheInterval(INT apIndex, UINT number)
UTF::Try "wifi_setApPMKCacheInterval_$radio_intf" {

    set actual_val [$Router wifi_api wifi_getApPMKCacheInterval $ap_index]
    UTF::Message LOG "" "actual value is $actual_val"

    if {[string match -nocase "*3600*" $actual_val]} {
	set to_set 7200
    } else {
	set to_set 3600
    }

    set ap_set_op [$Router wifi_api wifi_setApPMKCacheInterval $ap_index $to_set]
    UTF::Message LOG "" "is executed $ap_set_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set get_op [$Router wifi_api wifi_getApPMKCacheInterval $ap_index]
    UTF::Message LOG "" "wl output is $get_op"

    if {$to_set == 7200} {
	if {[string match -nocase "*7200*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#	    error "wl output is not matching"
	}
    } else {
	if {[string match -nocase "*3600*" $get_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#	    error "wl output is not matching"
	}

    }

    #reset
    set ap_reset_op [$Router wifi_api wifi_setApPMKCacheInterval $ap_index $actual_val]
    UTF::Message LOG "" "is executed $ap_reset_op"
    UTF::Sleep 2
}

#BOOL wifi_api_is_device_associated(int ap_index, char *mac)
UTF::Try "wifi_api_is_device_associated_$radio_intf" {

#root@brcm93390smwvg2:~#  wifi_api wifi_api_is_device_associated 1 3e:2d:3A:CA:2A:C5
#wifi_api_is_device_associated: Associated

#root@brcm93390smwvg2:~#wifi_api wifi_api_is_device_associated 1 44:2d:3A:CA:2A:C5
#wifi_api_is_device_associated: Not associated

    if {$idx == 0} {
	set assoc_sta [extract_config_from_file $file_name "rssi_MAC_2g"]
    } elseif {$idx == 1} {
        set assoc_sta [extract_config_from_file $file_name "rssi_MAC_5g"]
    } elseif {$idx == 2} {
	set assoc_sta [extract_config_from_file $file_name "rssi_MAC_6g"]
    }

    set api_op [$Router wifi_api wifi_api_is_device_associated $ap_index $assoc_sta]

    set assoclist_op [$Router wl -i $if_name assoclist]
    UTF::Message LOG "" "wl output is $assoclist_op"

    if {[string match -nocase "*not associated*" $api_op]} {
	if {[string match -nocase "*$assoc_sta*" $assoclist_op]} {
	    UTF::Message LOG "" "LGI API"
#	    error "sta is list but shows not associated"
	} else {
            UTF::Message LOG "" "wl output is matching"
	}
    } else {
	if {[string match -nocase "*$assoc_sta*" $assoclist_op]} {
            UTF::Message LOG "" "wl output is matching"
	} else {
	    UTF::Message LOG "" "LGI API"
#	    error "sta is not in list but shows associated"
	}
    }
}

#INT wifi_getWpsStatus(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getWpsStatus_$radio_intf" {

#WPS status: Unknown
#WPS status: In_progress
#WPS status: Success
#WPS status: Failed
    set api_op [$Router wifi_api wifi_getWpsStatus $idx]

    if {[string match -nocase "*Unknown*" $api_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*progress*" $api_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*Success*" $api_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*Failed*" $api_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
#	error "API output not matching $api_op"
    }

}

#INT wifi_kickAllAssociatedDevice(INT apIndex)
UTF::Try "wifi_kickAllAssociatedDevice_$radio_intf" {
    set api_op [$Router wifi_api wifi_kickAllAssociatedDevice $idx]

    set assoclist_op [$Router wl -i $if_name assoclist]

    if {[string match -nocase "" $assoclist_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	UTF::Message LOG "" "LGI API"
#	error "Some sta is in associated list $assoclist_op"
    }
}
}

UTF::Try "wifi_getAPCapabilities_$radio_intf" {

#wifi_api wifi_getAPCapabilities 0
#AP 0 Capabilities:
# rtsThresholdSupported: TRUE
# SecurityModes: 0x0ff9 None WPA-Personal WPA2-Personal WPA-WPA2-Personal WPA-Enterprise WPA2-Enterprise WPA-WPA2-Enterprise WPA3-Personal WPA3-Personal-Transition WPA3-Enterprise
# OnBoardingMethods: 0x1f8c Label Display PushButton Keypad PhysicalPushButton PhysicalDisplay VirtualPushButton VirtualDisplay
# WMMSupported: TRUE
# UAPSDSupported: TRUE
# interworkingServiceSupported: TRUE
# BSSTransitionImplemented: TRUE
#
    set ap_cap_op [$Router wifi_api wifi_getAPCapabilities $ap_index]
    UTF::Message LOG "" "wifi_getAPCapabilities is executed $ap_cap_op"

    set wl_op [$Router wl -i $if_name cap]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*SecurityModes*WPA*Personal*" $ap_cap_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        UTF::Message LOG "" "No Security Modes supported"
        #error "wl output is not matching"
    }

}

#INT wifi_getHalCapability(UINT apIndex,UCHAR *out_DialogToken)
UTF::Try "wifi_getHalCapability_$radio_intf" {

#root@Docsis-Gateway:~# wifi_api wifi_getHalCapability

#Hal Capability:
#   version major: 3 minor: 0
#   BandSteeringSupported: TRUE
#   numRadios: 3
#   Radio 0 Capabilities:
#        numSupportedFreqBand: 1

    set ap_hal_cap_op [$Router wifi_api wifi_getHalCapability]
    UTF::Message LOG "" "is executed $ap_hal_cap_op"

    set wl_op [$Router wl -i $if_name cap]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*version major:*2*" $ap_hal_cap_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*version major:*3*" $ap_hal_cap_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

if {0} {
#INT wifi_getRadioCapabilities(UINT apIndex,UCHAR *out_DialogToken)
UTF::Try "wifi_getRadioCapabilities_$radio_intf" {

#root@brcm93390smwvg2:~# wifi_api wifi_getRadioCapabilities 1

#Radio 1 Capabilities:
#        bands: 0x0002 5G

#        ChannelList num: 28 list: 36 40 44 48 52 56 60 64 100 104 108 112 116 120 124 128 132 136 140 144 149 153 157 161 165 169 173 177
#        channelWidth: 0x000f 20 40 80 160 MHz
#        80211_variants: 0x00b9 a n h ac ax
#        uMaxBitRate: 4804 Mbps
#        BitRates: 0x0fd8 6 9 12 18 24 36 48 54 Mbps
#        bAutoChannelSupported: TRUE
#        bDCSSupported: TRUE
#        transmitPowerSupported_list: num: 5 list: 0 25 50 75 100
#        bZeroDFSSupported: FALSE
#        bBSSColoringSupported: FALSE
#        CSI: maxDevices: 10 soudingFrameSupported = TRUE
#        Cipher Capability: 0x000c TKIP CCMP

    set ap_rad_cap_op [$Router wifi_api wifi_getRadioCapabilities $ap_index]
    UTF::Message LOG "" "is executed $ap_rad_cap_op"

    if {[string match -nocase "*80211_variants:*a*n*ac*" $ap_rad_cap_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#	error "wl output not matching"
	UTF::Message LOG "" "DUPLICATE NOT SUPPORTED STUB FUNCTION"
    }

}
}

#INT wifi_getApSecurity(UINT apIndex,UCHAR *out_DialogToken)
UTF::Try "wifi_getApSecurity_$radio_intf" {

#root@brcm93390smwvg2:~# wifi_api wifi_getApSecurity 0
#security mode: WPA2-Personal
#mfp: 0
#encryption: AESEncryption
#wpa passphrase: 123456789

    set ap_ap_sec_op [$Router wifi_api wifi_getApSecurity $ap_index]
    UTF::Message LOG "" "is executed $ap_ap_sec_op"

    if {[string match -nocase "*security mode:*WPA*" $ap_ap_sec_op]} {
        UTF::Message LOG "" "wl output is matching"
    } elseif {[string match -nocase "*security mode:*None*" $ap_ap_sec_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getApWpsConfiguration(UINT apIndex,UCHAR *out_DialogToken)
UTF::Try "wifi_getApWpsConfigurationState_$radio_intf" {

    set ap_wps_config_st_temp [$Router wifi_api wifi_getApWpsConfigurationState $ap_index]

    UTF::Message LOG "" "output from wifi_getApWpsConfigurationState is $ap_wps_config_st_temp"

    set nvram_lan_oob_op [extract_config_from_file $nvram_show_file "lan_wps_oob"]

    if {[string match -nocase "*Not configured*" $ap_wps_config_st_temp]} {
	if {[string match -nocase "*enabled*" $nvram_lan_oob_op]} {
	    UTF::Message LOG "" "output from wifi_getApWpsConfigurationState and wl matching"
	} else {
	    error "output from wifi_getApWpsConfigurationState and wl not matching $nvram_lan_oob_op"
	}
    } elseif {[string match -nocase "*Configured*" $ap_wps_config_st_temp]} {
        if {[string match -nocase "*disabled*" $nvram_lan_oob_op]} {
            UTF::Message LOG "" "output from wifi_getApWpsConfigurationState and wl matching"
        } else {
            error "output from wifi_getApWpsConfigurationState and wl not matching $nvram_lan_oob_op"
        }
    }
}

#INT wifi_getAvailableBSSColor(INT radio_index, INT maxNumberColors, UCHAR* colorList, INT *numColorReturned)
UTF::Try "wifi_getAvailableBSSColor_$radio_intf" {

    set ap_bss_color_op [$Router wifi_api wifi_getAvailableBSSColor $idx]
    UTF::Message LOG "" "is executed $ap_bss_color_op"

    if {[string match -nocase "*color*" $ap_bss_color_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#        UTF::Message LOG "" "No color mentioned"
	error "wl output is not matching"
    }

}

#INT wifi_setMuEdca(INT radio_index, wifi_access_category_t ac, wifi_edca_t *edca)
UTF::Try "wifi_setMuEdca_$radio_intf" {

    set mu_edca_op [$Router wifi_api wifi_setMuEdca $idx 0 1 5 11 8]
    UTF::Sleep 10
    $Router wifi_api wifi_apply
    UTF::Message LOG "" "is executed $mu_edca_op"

#
#wifi_api wifi_getMuEdca 0 0
#root@brcm93390smwvg2:~# wifi_api wifi_getMuEdca 0 0
#WLDM-DBG >> [wifi_api] wldm_set_wldm_msglevel wldm_msglevel = 0xf
#WLDM-DBG >> is11AXCapable: 11ax supported
#MuEdca aci=0, aifsn=1, cw_min=5, cw_max=11, timer=0
#
    set aci 0
    set wl_op [$Router wifi_api wifi_getMuEdca $idx $aci]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*cw_min=5, cw_max=11*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getMuEdca(INT radio_index, wifi_access_category_t ac, wifi_edca_t *edca)
UTF::Try "wifi_getMuEdca_$radio_intf" {

    set mu_edca_op [$Router wifi_api wifi_setMuEdca $idx 0 1 4 10 8]
    UTF::Sleep 5
    $Router wifi_api wifi_apply
    UTF::Message LOG "" "is executed $mu_edca_op"

    set aci 0
    set mu_edca_op [$Router wifi_api wifi_getMuEdca $idx $aci]
    UTF::Message LOG "" "is executed $mu_edca_op"

#
#wifi_api wifi_getMuEdca 0 0
#root@brcm93390smwvg2:~# wifi_api wifi_getMuEdca 0 0
#WLDM-DBG >> [wifi_api] wldm_set_wldm_msglevel wldm_msglevel = 0xf
#WLDM-DBG >> is11AXCapable: 11ax supported
#MuEdca aci=0, aifsn=1, cw_min=5, cw_max=11, timer=0
#
    if {[string match -nocase "*cw_min=4, cw_max=10*" $mu_edca_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getRadioFrequencyBand(wifi_radio_index_t index, wifi_freq_bands_t *band)
UTF::Try "wifi_getRadioFrequencyBand_$radio_intf" {

#root@brcm93390smwvg2:~# wifi_api wifi_getRadioFrequencyBand 1
#bands: 0x0002 5

    set rad_freq_band_op [$Router wifi_api wifi_getRadioFrequencyBand $idx]
    UTF::Message LOG "" "is executed $rad_freq_band_op"

    if {$idx == 0} {
	if {[string match -nocase "*bands:*2*" $rad_freq_band_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching $idx 0"
	}
    } elseif {$idx == 1} {
        if {[string match -nocase "*bands:*5*" $rad_freq_band_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching $idx 1"
        }
    } elseif {$idx == 2} {
        if {[string match -nocase "*bands:*6*" $rad_freq_band_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching $idx 2"
        }
    } else {
	error "wl output is not matching"
    }

}

#INT wifi_getRadioOperatingParameters(wifi_radio_index_t index, wifi_radio_operationParam_t *operationParam)
UTF::Try "wifi_getRadioOperatingParameters_$radio_intf" {

#wifi_getRadioOperatingParameters
#wifi_api wifi_getRadioOperatingParameters 0
#WLDM-DBG >> [wifi_api] wldm_set_wldm_msglevel wldm_msglevel = 0xf
#wifi_getRadioOperatingParameters: Enter, index = 0
#wifi_getRadioOperatingParameters: radioIndex=0 bAutoChannelEnabled=1
#wifi_getRadioOperatingParameters: radioIndex=0 OperatingStandards=g,n
#wifi_getRadioOperatingParameters: radioIndex=0 operationParam->variant=0xc
#wifi_getRadioOperatingParameters: radioIndex=0 wldm_Radio_IEEE80211hEnabled=1
#WLDM-DBG >> dm_chanspec: get: chanspec = 1006 ch = 6 bw = 20MHz
#wifi_getRadioOperatingParameters: radioIndex=0 wldm_xbrcm_Radio_Chanspec channel=6 bandwidth=20MHz
#wifi_getRadioOperatingParameters: radioIndex=0 wl_map_str2enum_fromTable bw=1
#bAutoChannelEnabled: 1
#uChannel: 6
#channelWidth: 0x0001 20 MHz
#80211_variants: 0x001c g n h
#csa_beacon_count: 0

    set rad_op_param_op [$Router wifi_api wifi_getRadioOperatingParameters $idx]
    UTF::Message LOG "" "is executed $rad_op_param_op"

    set wl_chan_temp [$Router wl -i $if_name channel]
    set wl_chan_op [lindex [split $wl_chan_temp] end]
    UTF::Message LOG "" "wl channel is $wl_chan_op"

    if {[string match -nocase "*Channel: $wl_chan_op*" $rad_op_param_op]} {
	UTF::Message LOG "" "wl channel is matching"
    } else {
	error "wl channel is not matching"
    }

    set wl_bw_op [$Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx]
    UTF::Message LOG "" "wl  bw is $wl_bw_op"

    if {[string match -nocase "*20*MHz*" $wl_bw_op]} {
	if {[string match -nocase "*channelWidth:*20*" $rad_op_param_op]} {
	    UTF::Message LOG "" "wl BW is matching 20MHz"
	} else {
	    error "wl BW is not matching 20MHz"
	}
    } elseif {[string match -nocase "*40*MHz*" $wl_bw_op]} {
        if {[string match -nocase "*channelWidth:*40*" $rad_op_param_op]} {
            UTF::Message LOG "" "wl BW is matching 40MHz"
        } else {
            error "wl BW is not matching 40MHz"
        }
    } elseif {[string match -nocase "*80*MHz*" $wl_bw_op]} {
        if {[string match -nocase "*channelWidth:*80*" $rad_op_param_op]} {
            UTF::Message LOG "" "wl BW is matching 80MHz"
        } else {
            error "wl BW is not matching 80MHz"
        }
    } elseif {[string match -nocase "*160*MHz*" $wl_bw_op]} {
        if {[string match -nocase "*channelWidth:*160*" $rad_op_param_op]} {
            UTF::Message LOG "" "wl BW is matching 160MHz"
        } else {
            error "wl BW is not matching 160MHz"
        }
    } else {
	error "wl BW is not matching Any"
    }

}

#INT wifi_getRadioVapInfoMap(wifi_radio_index_t index, wifi_vap_info_map_t *map)
UTF::Try "wifi_getRadioVapInfoMap_$radio_intf" {

#wifi_api wifi_getRadioVapInfoMap 0
#ap_index=14, ap_name=wl0.7, ssid=vap-noSec-14, 02:90:4c:34:31:46
#        enabled=0, showSsid=1, isolation=0
#        mgmtPowerControl=5, bssMaxSta=64, bssTransitionActivated=0
#        nbrReportActivated=1, mac_filter_enable=0
#        mac_filter_mode=0, wmm_enabled=1
#        InterworkingElement:
#interworkingEnabled:    1
#accessNetworkType:      2
#internetAvailable:      1

    set rad_vap_info_op [$Router wifi_api wifi_getRadioVapInfoMap $idx]
    UTF::Message LOG "" "is executed $rad_vap_info_op"

    set wl_op [$Router wifi_api wifi_getApWmmEnable $idx]
    UTF::Message LOG "" "wl  Wmm is $wl_op"

    if {[string match -nocase "*wmm_enabled=$wl_op*" $rad_op_param_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

    set wl_op [$Router wifi_api wifi_getApIsolationEnable $idx]
    UTF::Message LOG "" "wl  Isolation is $wl_op"

    if {[string match -nocase "*isolation=$wl_op*" $rad_op_param_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }
}

#INT wifi_getTWTsessions(INT ap_index, UINT maxNumberSessions, wifi_twt_sessions_t * twtSessions, UINT* numSessionReturned)
UTF::Try "wifi_getTWTsessions_$radio_intf" {

    set max_sessions 3
    set twt_session_op [$Router wifi_api wifi_getTWTsessions $ap_index $max_sessions]
    UTF::Message LOG "" "is executed $twt_session_op"

    if {[string match -nocase "*TWT numSessions =*" $twt_session_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApSecurity(INT ap_index, wifi_vap_security_t security)
UTF::Try "wifi_setApSecurity_$radio_intf" {
#wifi_api wifi_setApSecurity 0 WPA2-Enterprise aes 10.0.0.2 1812 sharedkey 10.0.0.3 1813 sharedkey2 wifi_api wifi_apply

    set ap_sec_op [$Router wifi_api wifi_setApSecurity $ap_index WPA2-Personal 1 aes psk 01234567890]
    UTF::Message LOG "" "is executed $ap_sec_op"
    wifi_apply_test_suite $Router

    set wl_op [$Router wifi_api wifi_getApSecurity $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*sharedkey2*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#        UTF::Message LOG "" "No color mentioned"
	error "wl output is not matching"
    }

}

#INT wifi_setApWpsConfiguration(INT ap_index, wifi_ap_Wps_t wpsConfig)
UTF::Try "wifi_setApWpsConfiguration_$radio_intf" {

#wifi_api wifi_setApWpsConfiguration 0 1 16507869 Label
#
    set actual_val [$Router wifi_api wifi_getApWpsConfiguration $ap_index]
    set ap_sec_op [$Router wifi_api wifi_setApWpsConfiguration $ap_index 1 16507869 Label]
    UTF::Message LOG "" "is executed $ap_sec_op"
    UTF::Sleep 20
    wifi_apply_test_suite $Router

    set wl_op [$Router wifi_api wifi_getApWpsConfiguration $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*Label*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#        UTF::Message LOG "" "No color mentioned"
	error "wl output is not matching"
    }

    #reset
    if {[string match -nocase "*PushButton*" $actual_val]} {
	set ap_sec_op [$Router wifi_api wifi_setApWpsConfiguration $ap_index "PushButton"]
	UTF::Message LOG "" "is executed $ap_sec_op"
	UTF::Sleep 20
	wifi_apply_test_suite $Router
    }
}

#INT wifi_setTeardDownTWTSession(INT ap_index,  INT sessionID)
UTF::Try "wifi_setTeardDownTWTSession_$radio_intf" {

    set twt_op [$Router wl -i $if_name twt]

    if {$twt_op == 0} {
	UTF::Message LOG "" "Enable feature"
	$Router wl -i $if_name twt 1
	UTF::Sleep 2
    }

    set ap_sec_op [$Router wifi_api wifi_setTeardDownTWTSession $ap_index 0]
    UTF::Message LOG "" "is executed $ap_sec_op"
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_op [$Router wl -i $if_name twt list]
    UTF::Message LOG "" "wl output is $wl_op $twt_op"

    if {[string match -nocase "*TWT schedules available*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setBroadcastTWTSchedule(INT ap_index , wifi_twt_params_t twtParams, BOOL create, INT* sessionID)
UTF::Try "wifi_setBroadcastTWTSchedule_$radio_intf" {
#wifi_api wifi_setBroadcastTWTSchedule 1 0 0 1 24576 737280 1 3
#wifi_api wifi_setBroadcastTWTSchedule 1 0 0 1 31290 614400 1 4

    set ap_sec_op [$Router wifi_api wifi_setBroadcastTWTSchedule $ap_index 0 0 1 24576 737280 1 3]
    UTF::Message LOG "" "is executed $ap_sec_op"
    wifi_apply_test_suite $Router

    set wl_op [$Router wl -i $if_name twt list]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*737280*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#        UTF::Message LOG "" "No color mentioned"
	error "wl output is not matching"
    }

}

#INT wifi_setBSSColor(INT radio_index, UCHAR color)
UTF::Try "wifi_setBSSColor_$radio_intf" {
#root@brcm93390smwvg2:~# wifi_api wifi_getBSSColor 0
#WLDM-DBG >> [wifi_api] wldm_set_wldm_msglevel wldm_msglevel = 0xf
#BSSColor=1

    set actual_val [$Router wifi_api wifi_getBSSColor $idx]
    set color 18
    set set_color_op [$Router wifi_api wifi_setBSSColor $idx $color]
    UTF::Message LOG "" "is executed $set_color_op"
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getBSSColor $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$color*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#	UTF::Message LOG "" "No color mentioned"
	error "wl output is not matching"
    }

    #reset
    set set_color_op [$Router wifi_api wifi_setBSSColor $idx $actual_val]
    UTF::Message LOG "" "is executed $set_color_op"
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_setRadioOperatingParameters(wifi_radio_index_t index, wifi_radio_operationParam_t operationParam)
UTF::Try "wifi_setRadioOperatingParameters_$radio_intf" {
#wifi_api wifi_setRadioOperatingParameters 0 1 1 1 12 10
#root@Docsis-Gateway:~# wl -i wl0 chanspec
#6 (0x1006)
#
#root@Docsis-Gateway:~#
#root@Docsis-Gateway:~# wl -i wl0 bw_cap 2g
#0x1
#root@Docsis-Gateway:~#
#root@Docsis-Gateway:~# nvram show | grep wl0_oper_stands
#
#size: 48296 bytes (82776 left)
#wl0_oper_stands=g,n
#root@Docsis-Gateway:~#
#root@Docsis-Gateway:~# nvram show | grep wl0_channel
#
#size: 48296 bytes (82776 left)
#wl0_channel=0
#root@Docsis-Gateway:~#
#root@Docsis-Gateway:~# nvram show | grep wl0_chanspec
#
#size: 48296 bytes (82776 left)
#wl0_chanspec=0
#root@Docsis-Gateway:~#
#root@Docsis-Gateway:~# nvram show | grep wl0_bw_cap
#size: 48296 bytes (82776 left)
#wl0_bw_cap=1
#
#
###5G Autochannel enabled + bw change from 80 to 160 + mode change to ax-only
#wifi_api wifi_setRadioOperatingParameters 1 1 36 8 128 10
#
#root@Docsis-Gateway:~# nvram show | grep wl1_oper_stands
#
#size: 48292 bytes (82780 left)
#wl1_oper_stands=ax
#root@Docsis-Gateway:~# nvram show | grep wl1_bw_cap
#size: 48292 bytes (82780 left)
#wl1_bw_cap=15
#

# wifi_api wifi_setRadioOperatingParameters <RadioIndex> <Enable/Disable(1/0)> <AutoChannelEnabled(0/1)> <Channel> <Bandwidth(1/2/4/8/16)> <OperatingMode> <CsaBeaconCount>
# wifi_api wifi_setRadioOperatingParameters <RadioIndex> <AutoChannelEnabled(0/1)><Channel> <Bandwidth(1/2/4/8/16)> <OperatingMode> <CsaBeaconCount>
    if {$idx == 0} {
	set rad_op_param_op [$Router wifi_api wifi_setRadioOperatingParameters $idx 1 6 2 140 10]
    } elseif {$idx == 1} {
        set rad_op_param_op [$Router wifi_api wifi_setRadioOperatingParameters $idx 1 36 3 128 10]
    } elseif {$idx == 2} {
        set rad_op_param_op [$Router wifi_api wifi_setRadioOperatingParameters $idx 1 1 4 128 10]
    }
    UTF::Message LOG "" "is executed $rad_op_param_op"
    wifi_apply_test_suite $Router
    UTF::Sleep 30

    set wl_op [$Router wifi_api wifi_getRadioOperatingParameters $idx]
    UTF::Message LOG "" "wl output is $wl_op"

#uChannel: 58
#channelWidth: 0x0004 80 MHz
#80211_variants: 0x0090

    if {$idx == 0} {
	if {[string match -nocase "*channel: 6*" $wl_op] &&
		[string match -nocase "*autoChannelEnabled: 1*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } elseif {$idx == 1} {
	if {[string match -nocase "*channel: 36*" $wl_op] &&
		[string match -nocase "*autoChannelEnabled: 1*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching"
        }
    } elseif {$idx == 2} {
	if {[string match -nocase "*channel: 1*" $wl_op] &&
		[string match -nocase "*autoChannelEnabled: 1*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching"
        }
    }

}

#INT wifi_setGuardInterval(INT radio_index, wifi_guard_interval_t guard_interval)
UTF::Try "wifi_setGuardInterval_$radio_intf" {

    set gi 2
    set ap_gi_op [$Router wifi_api wifi_setGuardInterval $idx $gi]
    UTF::Message LOG "" "is executed $ap_sec_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router

    set wl_op [$Router wifi_api wifi_getGuardInterval $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*guard_interval*$gi*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        UTF::Message LOG "" "No color mentioned"
        #error "wl output is not matching"
    }

    set gi 16
    set ap_gi_op [$Router wifi_api wifi_setGuardInterval $idx $gi]
    UTF::Message LOG "" "is executed $ap_sec_op"
    UTF::Sleep 2
    wifi_apply_test_suite $Router
}

#INT wifi_getGuardInterval(INT radio_index, wifi_guard_interval_t *guard_interval)
UTF::Try "wifi_getGuardInterval_$radio_intf" {

    set ap_gi_op [$Router wifi_api wifi_getGuardInterval $idx]
    UTF::Message LOG "" "is executed $ap_sec_op"

    set wl_op [$Router wl -i $if_name sgi_tx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*guard_interval=*" $ap_gi_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	if {$wl_op == -1} {
	    UTF::Message LOG "" "wl output is matching Auto"
	} else {
	    error "wl output is not matching $wl_op"
	}
    }

}

#P6END#
    }

}

#
#This is to test the commands supported in HAL 2.15 version.
#
proc wifi_test_hal_p1_commands {Router STA} {

    UTF::Message LOG "" "JST9: Trying to execute HAL 2.15 set of commands"

#    set init_called [$Router wifi_api wifi_init]
#    UTF::Sleep 160

    set kk [$Router wifi_api wifi_getRadioNumberOfEntries]

    set num_radios [string index $kk end]

    puts "mum radios: $num_radios"

    set path_info [exec pwd]

if {0} {
    set nvram_cmd [$Router nvram set wl0_ssid=ssid_test_2g]]
    set nvram_cmd [$Router nvram set wl1_ssid=ssid_test_5g]
    set nvram_cmd [$Router nvram set wl0_hw_rxchain=15]
    set nvram_cmd [$Router nvram set wl1_hw_rxchain=15]
    set nvram_cmd [$Router nvram set wl0_hw_txchain=15]
    set nvram_cmd [$Router nvram set wl1_hw_txchain=15]
    set nvram_cmd [$Router nvram set wl0_txpwr_sup=0,12,25,31,50,75,100]
    set nvram_cmd [$Router nvram set wl1_txpwr_sup=0,12,25,31,50,75,100]
    set nvram_cmd [$Router nvram set wl0_wps_device_pin=12345678]
    set nvram_cmd [$Router nvram set wl1_wps_device_pin=12345678]
    set nvram_cmd [$Router nvram set wl0_force_bcn_rspec=4]
    set nvram_cmd [$Router nvram set wl1_force_bcn_rspec=12]
    set nvram_cmd [$Router nvram set wl0_channel=1]
    set nvram_cmd [$Router nvram set wl0_chanspec=1]
    set nvram_cmd [$Router nvram set wl1_channel=36]
    set nvram_cmd [$Router nvram set wl1_chanspec=36]
    set nvram_cmd [$Router nvram set wl0_mimo_preamble=1]
    set nvram_cmd [$Router nvram set wl1_mimo_preamble=1]
    set nvram_cmd [$Router nvram commit]
    set nvram_cmd [$Router rc restart]
    UTF::Sleep 120
}

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    if {$num_radios > 3} {
        UTF::Message ERROR "" "num_radios is not correct $num_radios"
        return
    }

    for {set indx 0} {$indx < $num_radios} {incr indx} {

        UTF::Message LOG "" "Radio index: $indx"
        if {$indx == 0} {
                set radio_intf_0 "2g"

		set radioName_0 [$Router wifi_api wifi_getRadioIfName $indx]
		set str_len [string length $radioName_0]
		set if_name_0 [string range $radioName_0 $str_len-3 $str_len]

        } elseif {$indx == 1} {
                set radio_intf_1 "5g"
		set radioName_1 [$Router wifi_api wifi_getRadioIfName $indx]
		set str_len [string length $radioName_1]
		set if_name_1 [string range $radioName_1 $str_len-3 $str_len]

        } elseif {$indx == 2} {
                set radio_intf_2 "6g"
		set radioName_2 [$Router wifi_api wifi_getRadioIfName $indx]
		set str_len [string length $radioName_2]
		set if_name_2 [string range $radioName_2 $str_len-3 $str_len]
	}

    }

UTF::Try "wifi_DriverVersion" {
    $Router wl -i $if_name_0 ver
    $Router wl -i $if_name_1 ver

    if {$num_radios == 3} {
	$Router wl -i $if_name_2 ver
    }
}

UTF::Try "wifi_getHalVersion" {
     $Router wifi_api wifi_getHalVersion
}

UTF::Try "wifi_getRadioNumberOfEntries" {
     $Router wifi_api wifi_getRadioNumberOfEntries
}

UTF::Try "wifi_StaSetup" {
    $STA wl ver
    UTF::Sleep 120
    $STA wl status
}

if {0} {
UTF::Try "wifi_reset" {

	set api_ret_val [$Router wifi_api wifi_reset]
	UTF::Sleep 120
	UTF::Message LOG "" "API return value is $api_ret_val"


	$Router wl -i $if_name_0 ssid $wl0_ssid_init
	UTF::Sleep 10
	$Router wl -i $if_name_1 ssid $wl1_ssid_init
	UTF::Sleep 10
        if {$num_radios == 3} {
		$Router wl -i $if_name_2 ssid $wl2_ssid_init
		UTF::Sleep 5
	}
	#wifi_apply_test_suite $Router

        set wl_isup_check_0 [lindex [$Router wl -i $if_name_0 isup] end]

        if {$wl_isup_check_0 == 1} {
		$Router wl -i $if_name_0 status
                UTF::Message LOG "" "wl0 is wifi_reset $wl_isup_check_0"
        } else {
		$Router wl -i $if_name_0 status
		$Router wl -i $if_name_0 radio on
		$Router wl -i $if_name_0 bss up
                UTF::Message LOG "" "wl0 is not reset wifi_reset $wl_isup_check_0"
		UTF::Sleep 20

		$Router wl -i $if_name_0 ssid $wl0_ssid_init
		UTF::Sleep 30
        }

        set wl_isup_check_1 [lindex [$Router wl -i $if_name_1 isup] end]

        if {$wl_isup_check_1 == 1} {
		$Router wl -i $if_name_1 status
                UTF::Message LOG "" "wl1 is wifi_reset $wl_isup_check_1"
        } else {
		$Router wl -i $if_name_1 status
		$Router wl -i $if_name_1 radio on
		$Router wl -i $if_name_1 bss up
                UTF::Message LOG "" "wl1 is not reset wifi_reset $wl_isup_check_1"

                UTF::Sleep 20

                $Router wl -i $if_name_1 ssid $wl1_ssid_init
                UTF::Sleep 30
        }

	if {$num_radios == 3} {

	        set wl_isup_check_2 [lindex [$Router wl -i $if_name_2 isup] end]

		if {$wl_isup_check_2 == 1} {
			$Router wl -i $if_name_2 status
			UTF::Message LOG "" "wl1 is wifi_reset $wl_isup_check_2"
		} else {
			$Router wl -i $if_name_2 status
			$Router wl -i $if_name_2 radio on
			$Router wl -i $if_name_2 bss up
			UTF::Message LOG "" "wl2 is not reset wifi_reset $wl_isup_check_2"
			UTF::Sleep 20

			$Router wl -i $if_name_2 ssid $wl2_ssid_init
			UTF::Sleep 30
		}
	}
}

UTF::Try "wifi_down" {
    $Router wifi_api wifi_down
    UTF::Sleep 1
    wifi_apply_test_suite $Router
    UTF::Sleep 60

    for {set init_idx 0} {$init_idx < [expr $num_radios - 1]} {incr init_idx} {

        set wl_bss_check_0 [lindex [$Router wl -i $if_name_0 bss] end]
        if {[string match -nocase "down" $wl_bss_check_0]} {
        	UTF::Sleep 10
                UTF::Message LOG "" "wl0 is down wifi_down $wl_bss_check_0"
        } else {

                $Router wl -i $if_name_0 status
                error "wl0 is not down wifi_down $wl_bss_check_0"
        }

        set wl_bss_check_1 [lindex [$Router wl -i $if_name_1 bss] end]
        if {[string match -nocase "down" $wl_bss_check_1]} {
        	UTF::Sleep 10
                UTF::Message LOG "" "wl1 is wifi_down $wl_bss_check_1"
        } else {
                $Router wl -i $if_name_1 status
                error "wl1 is not down wifi_down $wl_bss_check_1"
        }
	if {$init_idx == 2} {
            set wl_bss_check_2 [lindex [$Router wl -i $if_name_2 bss] end]
            if {[string match -nocase "down" $wl_bss_check_2]} {
        	UTF::Sleep 10
		$Router wl -i $if_name_2 force_bcn_rspec 6
		$Router wl -i $if_name_2 nrate 8
                UTF::Message LOG "" "wl2 is wifi_down $wl_bss_check_2"
            } else {
                $Router wl -i $if_name_2 status
                error "wl2 is not down wifi_down $wl_bss_check_2"
            }
	}
    }

}

UTF::Try "wifi_init" {

        $Router wifi_api wifi_setRadioEnable 0 1
        wifi_apply_test_suite $Router
        UTF::Sleep 20
        $Router wifi_api wifi_setRadioEnable 1 1
        wifi_apply_test_suite $Router
        UTF::Sleep 20
        if {$num_radios == 3} {
                $Router wifi_api wifi_setRadioEnable 2 1
        }
        wifi_apply_test_suite $Router
        UTF::Sleep 20

        $Router wifi_api wifi_init
        UTF::Sleep 120
	#Check SSID


    for {set init_idx 0} {$init_idx < $num_radios} {incr init_idx} {

        if {$init_idx == 0} {
                set radio_intf_init "2g"
        } elseif {$init_idx == 1} {
                set radio_intf_init "5g"
        } elseif {$init_idx == 2} {
                set radio_intf_init "6g"
        } else {
                error "NOT valid radio index"
	}

	set radioName_init [$Router wifi_api wifi_getRadioIfName $init_idx]
	set str_len_init [string length $radioName_init]
	set if_name_init [string range $radioName_init $str_len_init-3 $str_len_init]

	if {$init_idx == 2} {
		set to_exec [convert_radio_idx_to_ap_idx $Router $init_idx]
	        set ssid_status_temp [$Router wifi_api wifi_getSSIDName $to_exec]
	} else {
        	set ssid_status_temp [$Router wifi_api wifi_getSSIDName $init_idx]
	}

        set ssid_status_out [lindex [split $ssid_status_temp] end]

        UTF::Message LOG "" "total output string length $ssid_status_out"

        set ssid_init_check [lindex [$Router wl -i $if_name_init ssid] end]

        if {[string match $ssid_status_out $ssid_init_check]} {
                UTF::Message LOG "" "SSID Matching strings in wifi_init $ssid_status_out"
		$Router wl -i $if_name_init status
        } else {
		$Router wl -i $if_name_init status
                error "SSID NOT Matching output in wifi_init $ssid_status_out"
        }

        set bss_check [lindex [$Router wl -i $if_name_init bss] end]

        if {[string match -nocase "*up*" $bss_check]} {
                UTF::Message LOG "" "BSS is up"
                $Router wl -i $if_name_init status
        } else {
                $Router wl -i $if_name_init status
                error "BSS NOT up $bss_check"
        }
    }
}
}

UTF::Try "wifi_getSSIDNumberOfEntries" {
    set ssid_num_temp [$Router wifi_api wifi_getSSIDNumberOfEntries]
    set ssid_num [lindex [split $ssid_num_temp] end]

#wl0_vifs=wl0.1 wl0.2 wl0.3 wl0.4 wl0.5 wl0.6 wl0.7
#wl1_vifs=wl1.1 wl1.2 wl1.3 wl1.4 wl1.5 wl1.6 wl1.7
#wl2_vifs=wl2.1 wl2.2 wl2.3 wl2.4 wl2.5 wl2.6 wl2.7

    set nvram_entries $num_radios
    set nvram_vifs_0 [extract_config_from_file $nvram_show_file "wl0_vifs"]
    set nvram_vifs_1 [extract_config_from_file $nvram_show_file "wl1_vifs"]
    UTF::Message LOG "" "nvram entries $nvram_entries $nvram_vifs_0 $nvram_vifs_1"
    if {$num_radios == 3} {
	set nvram_vifs_2 [extract_config_from_file $nvram_show_file "wl2_vifs"]
	UTF::Message LOG "" "nvram entries for 3 rd radio $nvram_vifs_2"
    }

    if {[string match -nocase "" $nvram_vifs_0]} {
	UTF::Message LOG "" "No virtual interface for 0"
    } else {
	UTF::Message LOG "" "vifs entries are $nvram_vifs_0"
	set vifs_entries [split $nvram_vifs_0 " "]
	foreach v $vifs_entries {
		incr nvram_entries
	}
#	set nvram_entries [expr $nvram_entries + 7]
    }
    UTF::Message LOG "" "nvram entries after 0 vifs $nvram_entries"

    if {[string match -nocase "" $nvram_vifs_1]} {
	UTF::Message LOG "" "No virtual interface for 1"
    } else {
	UTF::Message LOG "" "vifs entries are $nvram_vifs_1"
        set vifs_entries [split $nvram_vifs_1 " "]
        foreach v $vifs_entries {
                incr nvram_entries
        }
#	set nvram_entries [expr $nvram_entries + 7]
    }
    UTF::Message LOG "" "nvram entries after 1 vifs $nvram_entries"

    if {$num_radios > 2} {
	if {[string match -nocase "" $nvram_vifs_2]} {
	    UTF::Message LOG "" "No virtual interface for 2"
	} else {
		UTF::Message LOG "" "vifs entries are $nvram_vifs_2"
	        set vifs_entries [split $nvram_vifs_2 " "]
        	foreach v $vifs_entries {
	                incr nvram_entries
       		}
#		set nvram_entries [expr $nvram_entries + 7]
	}
	UTF::Message LOG "" "nvram entries after 2 vifs $nvram_entries"
    }

    if {$ssid_num  == $nvram_entries} {
	UTF::Message LOG "" "SSID Number Matching $ssid_num"
    } else {
	error "SSID Number NOT Matching $ssid_num temp is $ssid_num_temp $nvram_entries"
    }

}

    for {set idx 0} {$idx < $num_radios} {incr idx} {

#START2G5G6G
        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {

                set radio_intf "5g"
		set radioName_1 [$Router wifi_api wifi_getRadioIfName $idx]
		set str_len [string length $radioName_1]
		set if_name_1 [string range $radioName_1 $str_len-3 $str_len]

	        $Router wl -i $if_name_1 radio on
	        UTF::Sleep 10
		intf_down_up_restart $Router $if_name_1 $idx

        } elseif {$idx == 2} {
                set radio_intf "6g"
                set radioName_2 [$Router wifi_api wifi_getRadioIfName $idx]
                set str_len [string length $radioName_2]
                set if_name_2 [string range $radioName_2 $str_len-3 $str_len]

                $Router wl -i $if_name_2 radio on
                UTF::Sleep 10
                intf_down_up_restart $Router $if_name_2 $idx
        }

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

	UTF::Message LOG "" "path info is $path_info"
	set file_name "$path_info/Test/hal_set_config"
	UTF::Message LOG "" "File name is $file_name"
	set nvram_show [$Router nvram show]

	set nvram_show_file "$path_info/nvram_show.txt"
	set fp [open "nvram_show.txt" w+]
	puts $fp $nvram_show
	close $fp

	set acs_ver [extract_config_from_file $file_name "acs_ver"]

UTF::Try "wifi_getBaseBSSID_$radio_intf" {

	set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
        set bssid_temp [$Router wifi_api wifi_getBaseBSSID $to_exec]

        set bssid_output [lindex [split $bssid_temp] end]

	$Router wl -i $if_name status
	if {$idx == 1} {
	    $Router wl -i  wl1.1 status
	}
        set bssid_check [lindex [$Router wl -i $if_name bssid] end]
        if {![string match $bssid_output $bssid_check]} {
                error "BSSID mismatch output is $bssid_output wl is $bssid_check"
        }
}

#INT wifi_getSSIDMACAddress(INT ssidIndex, CHAR *output_string)
UTF::Try "wifi_getSSIDMACAddress_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    set ssid_macaddr_temp [$Router wifi_api wifi_getSSIDMACAddress $to_exec]

    set wl_maccaddr_op [$Router wl -i $if_name bssid]

    UTF::Message LOG "" "output from wl bssid is $wl_maccaddr_op"

    if {[string match -nocase "*$wl_maccaddr_op*" $ssid_macaddr_temp]} {
	UTF::Message LOG "" "output from is matching wifi_getSSIDMACAddress wl output"
    } else {
	error "wifi_getSSIDMACAddress output and wl output is not matching"
    }
}

#INT wifi_setApRtsThreshold(INT apIndex, UINT threshold)
UTF::Try "wifi_setApRtsThreshold_$radio_intf" {

    set wl_temp [$Router wl -i $if_name rtsthresh]
    set wl_actual [lindex [split $wl_temp] 0]

    set radio_cnf [extract_config_from_file $file_name "rtsthresh"]

    if {$wl_actual == $radio_cnf} {
        set radio_cnf [expr $radio_cnf - 100]
    }

    UTF::Message LOG "" "wifi_setApRtsThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setApRtsThreshold $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_temp [$Router wl -i $if_name rtsthresh]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setApRtsThreshold and wl output is matching"
    } else {
        error "wifi_setApRtsThreshold and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setApRtsThreshold reset back"
    $Router wifi_api wifi_setApRtsThreshold $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20

}

UTF::Try "wifi_getRadioChannelsInUse_$radio_intf" {
        set channel_in_use_ptr [$Router wifi_api wifi_getRadioChannelsInUse $idx]
	UTF::Sleep 10
	UTF::Message LOG "" "channel_in_use_ptr is $channel_in_use_ptr"
	set channel_in_use_temp [lindex [split $channel_in_use_ptr] end]
	UTF::Message LOG "" "channel_in_use_temp is $channel_in_use_temp"

	if {[string match -nocase "*output_string*" $channel_in_use_temp]} {
#            set channels_in_use_op [extract_api_output $channel_in_use_temp "output_string = " 0]
	    set channels_in_use_op [lindex [split $channel_in_use_ptr] 0]
	} else {
	    set channels_in_use_op [lindex [split $channel_in_use_temp] end]
	}

        UTF::Message LOG "" "wifi_getRadioChannelsInUse output parsed is $channels_in_use_op"

        set wl_chan_temp [$Router wl -i $if_name channel]
        set wl_chan_op [lindex [split $wl_chan_temp] end]

        UTF::Message LOG "" "wifi_getRadioChannelsInUse wl output is $wl_chan_op"

        if {[string match -nocase "*$wl_chan_op*" $channels_in_use_op]} {
		 UTF::Message LOG "" "wl out is matching"
	} else {
                error "Channels mismatch in wifi_getRadioChannelsInUse"
        }
}

UTF::Try "wifi_setRadioChannel_$radio_intf" {
    set wl_actual [$Router wifi_api wifi_getRadioChannel $idx]

    set channels_check [lindex [split [$Router wifi_api wifi_getRadioPossibleChannels $idx]] end]
    UTF::Message LOG "" "The channel check is $channels_check"
    set channels_temp [split $channels_check ","]
    UTF::Message LOG "" "The channel temp is $channels_temp"
    set first_check [lindex [split $channels_temp] 0]
    set last_check [lindex [split $channels_temp] end]


    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "rad_chan_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "rad_chan_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "rad_chan_6g"]
    } else {
        error "Not a valid radio index"
    }

    if {$radio_cnf == $wl_actual} {
	if {$idx == 0} {
		set radio_cnf 1
	} elseif {$idx == 1} {
                set radio_cnf 36
        } elseif {$idx == 2} {
		set radio_cnf 177
	}
	UTF::Message LOG "" "Changing the current channel to $radio_cnf"
    }

    $Router wl -i $if_name status
    $Router wl -i $if_name bss

    set auto_channel_en_op [$Router wifi_api wifi_getRadioAutoChannelEnable $idx]

    if {$auto_channel_en_op == 1} {
	$Router wifi_api wifi_setRadioAutoChannelEnable $idx 0
	wifi_apply_test_suite $Router
	UTF::Sleep 20
    }

    $Router wl -i $if_name status

    UTF::Message LOG "" "wifi_setRadioChannel is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioChannel $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 60

    $Router wl -i $if_name status
    $Router wl -i $if_name bss

    set wl_temp [$Router wifi_api wifi_getRadioChannel $idx]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioChannel and wl output is matching"
    } else {
        error "wifi_setRadioChannel and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setRadioChannel reset back"
    $Router wifi_api wifi_setRadioChannel $idx $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    if {$auto_channel_en_op == 1} {
        $Router wifi_api wifi_setRadioAutoChannelEnable $idx 1
        wifi_apply_test_suite $Router
        UTF::Sleep 20
    }
}

#INT wifi_setRadioMCS(INT radioIndex, INT MCS)
UTF::Try "wifi_setRadioMCS_$radio_intf" {
    set act_temp [$Router wifi_api wifi_getRadioMCS $idx]
    set act_val [lindex [split $act_temp] end]
    UTF::Message LOG "" "Actual value is $act_val"

    if {$act_val != -1} {
	set auto_rate -1

	$Router wifi_api wifi_setRadioMCS $idx $auto_rate
	wifi_apply_test_suite $Router
	UTF::Sleep 5

	set wl_temp [$Router wifi_api wifi_getRadioMCS $idx]
	set wl_op [lindex [split $wl_temp] end]
	UTF::Message LOG "" "wl output get is $wl_op"

	if {$wl_op == $auto_rate} {
		UTF::Message LOG "" "wifi_setRadioMCS and wl output is matching"
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
	} else {
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
		error "wifi_setRadioMCS NOT AUTO"
	}

    } else {

	set txchain_op [$Router wifi_api wifi_getRadioTxChainMask $idx]
	UTF::Message LOG "" "wl txchain op is $txchain_op"
	if {$txchain_op == 2} {
		UTF::Message LOG "" "HT case"
		if {$idx == 0} {
			set radio_cnf [extract_config_from_file $file_name "radio_ht_mcs_2g"]
		} elseif {$idx == 1} {
			set radio_cnf [extract_config_from_file $file_name "radio_ht_mcs_5g"]
		} elseif {$idx == 2} {
			set radio_cnf [extract_config_from_file $file_name "radio_ht_mcs_6g"]
		} else {
			error "NOT valid radio index"
		}
	} elseif {$txchain_op > 2}  {
		UTF::Message LOG "" "VHT case"
		if {$idx == 0} {
			set radio_cnf [extract_config_from_file $file_name "radio_vht_mcs_2g"]
		} elseif {$idx == 1} {
			set radio_cnf [extract_config_from_file $file_name "radio_vht_mcs_5g"]
		} elseif {$idx == 2} {
			set radio_cnf [extract_config_from_file $file_name "radio_vht_mcs_6g"]
		} else {
			error "NOT valid radio index"
		}
	}
#6G
#   Either "auto", or a simple OFDM rate value:
#      6 9 12 18 24 36 48 54
    if {$idx == 2} {
        UTF::Message LOG "" "6G radio MCS to set $radio_cnf"
        set nrate_temp [$Router wl -i $if_name 6g_rate $radio_cnf]
        UTF::Sleep 5
	set radio_cnf [expr $radio_cnf * 2]
    } else {
	UTF::Message LOG "" "radio MCS to set $radio_cnf"
	set nrate_temp [$Router wl -i $if_name nrate -m $radio_cnf]
	UTF::Sleep 5
    }

	set wl_temp [$Router wifi_api wifi_getRadioMCS $idx]
	set wl_op [lindex [split $wl_temp] end]
	UTF::Message LOG "" "wl output get is $wl_op radio conf is $radio_cnf"

	if {$radio_cnf == $wl_op} {
		UTF::Message LOG "" "wifi_setRadioMCS and wl output is matching"
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
	} else {
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
		error "NOT matching $wl_op in auto rate default case"
	}
    }

}

#INT wifi_setRadioFragmentationThreshold(INT apIndex, UINT threshold)
UTF::Try "wifi_setRadioFragmentationThreshold_$radio_intf" {

    set wl_temp [$Router wl -i $if_name fragthresh]
    set wl_actual [lindex [split $wl_temp] 0]

    set radio_cnf [extract_config_from_file $file_name "fragthresh"]

    if {$wl_actual == $radio_cnf} {
        set radio_cnf [expr $radio_cnf - 100]
    }

    UTF::Message LOG "" "wifi_setRadioFragmentationThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioFragmentationThreshold $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_temp [$Router wl -i $if_name fragthresh]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioFragmentationThreshold and wl output is matching"
    } else {
        error "wifi_setRadioFragmentationThreshold and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setRadioFragmentationThreshold reset back"
    $Router wifi_api wifi_setRadioFragmentationThreshold $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20

}

#INT wifi_setApDTIMInterval(INT apIndex, INT dtimInterval)
UTF::Try "wifi_setApDTIMInterval_$radio_intf" {

    set wl_actual [$Router wl -i $if_name dtim]

    set radio_cnf [extract_config_from_file $file_name "dtim_int"]

    if {$wl_actual == $radio_cnf} {
        set radio_cnf [expr $radio_cnf + 1]
    }

    UTF::Message LOG "" "wifi_setApDTIMInterval is about to set $radio_cnf"
    $Router wifi_api wifi_setApDTIMInterval $ap_index $radio_cnf
    $Router wifi_api wifi_apply
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_op [$Router wl -i $if_name dtim]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setApDTIMInterval and wl output is matching"
    } else {
        error "wifi_setApDTIMInterval and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setApDTIMInterval reset back"
    $Router wifi_api wifi_setApDTIMInterval $ap_index $wl_actual
    $Router wifi_api wifi_apply
    wifi_apply_test_suite $Router
    UTF::Sleep 10
}

if {0} {
UTF::Try "wifi_applySSIDSettings_$radio_intf" {
        $Router wifi_api wifi_applySSIDSettings $idx
	UTF::Sleep 5
}

UTF::Try "wifi_applyRadioSettings_$radio_intf" {
	wifi_apply_test_suite $Router
	UTF::Sleep 5
}
}

#INT wifi_getApDeviceRSSI(INT ap_index, CHAR *MAC, INT *output_RSSI)
UTF::Try "wifi_getApDeviceRSSI_$radio_intf" {

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    if {$ap_index == 0} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_2g"]
    } elseif {$ap_index == 1} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_5g"]
    } elseif {$ap_index == $to_exec} {
        set radio_cnf [extract_config_from_file $file_name "rssi_MAC_6g"]
    } else {
	error "NOT valid radio index"
    }

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
	if {[string match -nocase "*$radio_cnf*" $wl_assoclist_list]} {

	    set found_sta 1
	    set get_rssi_temp [$Router wifi_api wifi_getApDeviceRSSI $ap_index $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "smoothed rssi:"
	    UTF::Message LOG "" "output from smoothed RSSI is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*$get_rssi_op*" $wl_rssi_op]} {
	        UTF::Message LOG "" "output from is matching wifi_getApDeviceRSSI wl output"
	    } else {
	        error "wifi_getApDeviceRSSI output and wl output is not matching"
	    }

	} else {
            incr no_of_assoc_sta
	}
    }
    if {$found_sta == 0} {

	UTF::Message LOG "" "NO STA is associated"
	if {$idx == 0} {
		set ssid_to_join [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$idx == 1} {
                set ssid_to_join [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$idx == 2} {
		set ssid_to_join [extract_config_from_file $file_name "wl2_ssid"]
	}

	$STA wl join $ssid_to_join
	UTF::Sleep 60
	set sta_status_op [$STA wl status]
	UTF::Sleep 1

        if {[string match -nocase "*Not associated*" $sta_status_op]} {
	    UTF::Message LOG "" "STA could not be associated"
	} else {
	    set get_rssi_temp [$Router wifi_api wifi_getApDeviceRSSI $ap_index $radio_cnf]
	    set get_rssi_op [lindex [split $get_rssi_temp] end]

	    set wl_rssi_op [$Router wl -i $if_name sta_info $radio_cnf]

	    UTF::Message LOG "" "output from wl sta_info is $wl_rssi_op"
	    #string to compare is
	    set smooth_rssi_temp "smoothed rssi:"
	    UTF::Message LOG "" "output from rx data pkt is $smooth_rssi_temp"
	    #Need to verify against smoothed rssi value
	    if {[string match -nocase "*$smooth_rssi_temp*$get_rssi_op*" $wl_rssi_op]} {
		UTF::Message LOG "" "output from is matching wifi_getApDeviceRSSI wl output"
	    } else {
		error "wifi_getApDeviceRSSI output and wl output is not matching"
	    }
        }

    } elseif {$found_sta != 1} {
	error "wifi_getApDeviceRSSI no STA with $radio_cnf is in associated list"
    }

}

# STATUS CHECK 0
#STUB FUNCTION
UTF::Try "wifi_getAllAssociatedDeviceDetail_$radio_intf" {
    set ap_max_assoc_temp [$Router wifi_api wifi_getAllAssociatedDeviceDetail $ap_index]
    set ap_all_assoc_op [lindex [split $ap_max_assoc_temp] end]

    UTF::Message LOG "" "output from wifi_getAllAssociatedDeviceDetail is $ap_all_assoc_op"

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]

    if {[string match -nocase "*Total_STA:0*" $ap_max_assoc_temp]} {

	if {[string match -nocase "" $wl_assoclist_temp]} {
	    UTF::Message LOG "" "No Associated STA"
	} else {
	    UTF::Message LOG "" "Associated STA mismatch - STUB function"
	}

    } else {

	set wl_assoclist_list [split $wl_assoclist_temp "\n"]

        UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

        set no_of_assoc_sta 0

        foreach j $wl_assoclist_list {
            puts "$j STA from assoclist is $no_of_assoc_sta in list"
	    set sta_mac_addr [lindex [split $j] end]
	    UTF::Message LOG "" "STA mac address from list is $sta_mac_addr"
            $Router wl -i $if_name sta_info $sta_mac_addr
            incr no_of_assoc_sta
        }

        if {$no_of_assoc_sta != 0} {
            UTF::Message LOG "" "No of Associated STA from wl output is $no_of_assoc_sta"

            if {$no_of_assoc_sta == $ap_all_assoc_op} {
                UTF::Message LOG "" "output from wifi_getAllAssociatedDeviceDetail and wl matching"
            } else {
	        UTF::Message LOG "" "Associated STA NOT in list - STUB function"
            }

        }

    }

}

#wifi_getBasicTrafficStats
UTF::Try "wifi_getBasicTrafficStats_$radio_intf" {
	#$Router wifi_api wifi_getBasicTrafficStats $idx

	set basic_traffic_info_output [$Router wifi_api wifi_getBasicTrafficStats $ap_index]
	set basic_traffic_info [lindex [split $basic_traffic_info_output] end]

	UTF::Message LOG "" "The Associated STA info in $if_name is $basic_traffic_info"

	set assoclist_output [$Router wl -i $if_name assoclist]
	UTF::Message LOG "" "wl assoclist output is $assoclist_output"

	set assoclist_split [split $assoclist_output "\n"]
	UTF::Message LOG "" "wl assoclist split output is $assoclist_split"

	set assoclist_check 0
	foreach j $assoclist_split {
		UTF::Message LOG "" "$j STA from assoclist is $assoclist_check in list"
		incr assoclist_check
		set sta_check [lindex [split $assoclist_split] $assoclist_check]
		UTF::Message LOG "" "STA from assoclist obtained is $sta_check"
		set sta_info_output [$Router wl -i $if_name sta_info $sta_check]
	}

	UTF::Message LOG "" "The number of Associated STAs from assoclist is $assoclist_check"

	if {$assoclist_check != 0} {
            if {$basic_traffic_info == $assoclist_check} {
		UTF::Message LOG "" "The number of Associated STAs from assoclist is $assoclist_check"
	    } else {
		error "Numbers are not matching $basic_traffic_info $assoclist_check"
	    }
	}
}

#INT wifi_getRadioTrafficStats2(INT radioIndex, wifi_radioTrafficStats2_t *output_struct)
UTF::Try "wifi_getRadioTrafficStats2_$radio_intf" {
    set ap_traf_stats_op [$Router wifi_api wifi_getRadioTrafficStats2 $idx]

    UTF::Message LOG "" "output from wifi_getRadioTrafficStats2 is $ap_traf_stats_op"

    set wl_assoclist_op [$Router wl -i $if_name assoclist]

    if {[string match -nocase "*Packets Other Received*" $ap_traf_stats_op]} {
        UTF::Message LOG "" "output from wifi_getRadioTrafficStats2 and wl matching"
    } else {
        error "output from wifi_getRadioTrafficStats2 and wl is not matching"
    }
}

UTF::Try "wifi_getSSIDTrafficStats2_$radio_intf" {
    $Router wifi_api wifi_getSSIDTrafficStats2 $idx
    UTF::Message LOG "" "SSID traffic stats $idx"
}

# END OF STATUS CHECK 0

#ORDER CHECK 0

#INT wifi_setSSIDEnable(INT ssidIndex, BOOL enable)
UTF::Try "wifi_setSSIDEnable_$radio_intf" {
    set current_radio_status [$Router wifi_api wifi_getSSIDEnable $idx]

#Toggle state and verify
    if {[string match -nocase "TRUE" $current_radio_status]} {
	set radio_cnf 0
    } else {
	set radio_cnf 1
    }

    UTF::Message LOG "" "wifi_setSSIDEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setSSIDEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
#    $Router wifi_api wifi_applySSIDSettings $idx
    UTF::Sleep 100

    set wl_op [$Router wifi_api wifi_getSSIDEnable $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 1} {
	if {[string match -nocase "*TRUE*" $wl_op]} {
	    UTF::Message LOG "" "wifi_setSSIDEnable and wl output is matching"
	} else {
	    error "wifi_setSSIDEnable TRUE and wl output is not matching"
	}
    } else {
	if {[string match -nocase "*FALSE*" $wl_op]} {
            UTF::Message LOG "" "wifi_setSSIDEnable and wl output is matching"
        } else {
            error "wifi_setSSIDEnable FALSE and wl output is not matching"
        }
    }

    UTF::Message LOG "" "wifi_setSSIDEnable is about to reset to old state"
    set radio_cnf 1

    $Router wifi_api wifi_setSSIDEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
#    $Router wifi_api wifi_applySSIDSettings $idx
    UTF::Sleep 20
    set isup_check [$Router wl -i $if_name bss]
}

if {0} {
#INT wifi_setApRtsThreshold(INT apIndex, UINT threshold)
UTF::Try "wifi_setApRtsThreshold_$radio_intf" {

    set wl_temp [$Router wl -i $if_name rtsthresh]
    set wl_actual [lindex [split $wl_temp] 0]

    set radio_cnf [extract_config_from_file $file_name "rtsthresh"]

    if {$wl_actual == $radio_cnf} {
        set radio_cnf [expr $radio_cnf - 100]
    }

    UTF::Message LOG "" "wifi_setApRtsThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setApRtsThreshold $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_temp [$Router wl -i $if_name rtsthresh]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setApRtsThreshold and wl output is matching"
    } else {
        error "wifi_setApRtsThreshold and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setApRtsThreshold reset back"
    $Router wifi_api wifi_setApRtsThreshold $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20

}

UTF::Try "wifi_getRadioChannelsInUse_$radio_intf" {
        set channel_in_use_ptr [$Router wifi_api wifi_getRadioChannelsInUse $idx]
	UTF::Sleep 10
	UTF::Message LOG "" "channel_in_use_ptr is $channel_in_use_ptr"
	set channel_in_use_temp [lindex [split $channel_in_use_ptr] end]
	UTF::Message LOG "" "channel_in_use_temp is $channel_in_use_temp"

	if {[string match -nocase "*output_string*" $channel_in_use_temp]} {
#            set channels_in_use_op [extract_api_output $channel_in_use_temp "output_string = " 0]
	    set channels_in_use_op [lindex [split $channel_in_use_ptr] 0]
	} else {
	    set channels_in_use_op [lindex [split $channel_in_use_temp] end]
	}

        UTF::Message LOG "" "wifi_getRadioChannelsInUse output parsed is $channels_in_use_op"

        set wl_chan_temp [$Router wl -i $if_name channel]
        set wl_chan_op [lindex [split $wl_chan_temp] end]

        UTF::Message LOG "" "wifi_getRadioChannelsInUse wl output is $wl_chan_op"

        if {[string match -nocase "*$wl_chan_op*" $channels_in_use_op]} {
		 UTF::Message LOG "" "wl out is matching"
	} else {
                error "Channels mismatch in wifi_getRadioChannelsInUse"
        }
}

#INT wifi_setRadioMCS(INT radioIndex, INT MCS)
UTF::Try "wifi_setRadioMCS_$radio_intf" {
    set act_temp [$Router wifi_api wifi_getRadioMCS $idx]
    set act_val [lindex [split $act_temp] end]
    UTF::Message LOG "" "Actual value is $act_val"

    if {$act_val != -1} {
	set auto_rate -1

	$Router wifi_api wifi_setRadioMCS $idx $auto_rate
	wifi_apply_test_suite $Router
	UTF::Sleep 5

	set wl_temp [$Router wifi_api wifi_getRadioMCS $idx]
	set wl_op [lindex [split $wl_temp] end]
	UTF::Message LOG "" "wl output get is $wl_op"

	if {$wl_op == $auto_rate} {
		UTF::Message LOG "" "wifi_setRadioMCS and wl output is matching"
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
	} else {
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
		error "wifi_setRadioMCS NOT AUTO"
	}

    } else {

	set txchain_op [$Router wifi_api wifi_getRadioTxChainMask $idx]
	UTF::Message LOG "" "wl txchain op is $txchain_op"
	if {$txchain_op == 2} {
		UTF::Message LOG "" "HT case"
		if {$idx == 0} {
			set radio_cnf [extract_config_from_file $file_name "radio_ht_mcs_2g"]
		} elseif {$idx == 1} {
			set radio_cnf [extract_config_from_file $file_name "radio_ht_mcs_5g"]
		} elseif {$idx == 2} {
			set radio_cnf [extract_config_from_file $file_name "radio_ht_mcs_6g"]
		} else {
			error "NOT valid radio index"
		}
	} elseif {$txchain_op > 2}  {
		UTF::Message LOG "" "VHT case"
		if {$idx == 0} {
			set radio_cnf [extract_config_from_file $file_name "radio_vht_mcs_2g"]
		} elseif {$idx == 1} {
			set radio_cnf [extract_config_from_file $file_name "radio_vht_mcs_5g"]
		} elseif {$idx == 2} {
			set radio_cnf [extract_config_from_file $file_name "radio_vht_mcs_6g"]
		} else {
			error "NOT valid radio index"
		}
	}
	UTF::Message LOG "" "radio MCS to set $radio_cnf"
	set nrate_temp [$Router wl -i $if_name nrate -m $radio_cnf]
	UTF::Sleep 5

	set wl_temp [$Router wifi_api wifi_getRadioMCS $idx]
	set wl_op [lindex [split $wl_temp] end]
	UTF::Message LOG "" "wl output get is $wl_op"

	if {$radio_cnf == $wl_op} {
		UTF::Message LOG "" "wifi_setRadioMCS and wl output is matching"
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
	} else {
		#reset back to auto
		$Router wifi_api wifi_setRadioMCS $idx $act_val
		wifi_apply_test_suite $Router
		UTF::Sleep 5
		error "NOT matching $wl_op in auto rate default case"
	}
    }

    set status_check [$Router wl -i $if_name status]
}

#INT wifi_setRadioFragmentationThreshold(INT apIndex, UINT threshold)
UTF::Try "wifi_setRadioFragmentationThreshold_$radio_intf" {

    set wl_temp [$Router wl -i $if_name fragthresh]
    set wl_actual [lindex [split $wl_temp] 0]

    set radio_cnf [extract_config_from_file $file_name "fragthresh"]

    if {$wl_actual == $radio_cnf} {
        set radio_cnf [expr $radio_cnf - 100]
    }

    UTF::Message LOG "" "wifi_setRadioFragmentationThreshold is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioFragmentationThreshold $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_temp [$Router wl -i $if_name fragthresh]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioFragmentationThreshold and wl output is matching"
    } else {
        error "wifi_setRadioFragmentationThreshold and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setRadioFragmentationThreshold reset back"
    $Router wifi_api wifi_setRadioFragmentationThreshold $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20
    set isup_check [$Router wl -i $if_name bss]

}

#INT wifi_setApDTIMInterval(INT apIndex, INT dtimInterval)
UTF::Try "wifi_setApDTIMInterval_$radio_intf" {

    set wl_actual [$Router wl -i $if_name dtim]

    set radio_cnf [extract_config_from_file $file_name "dtim_int"]

    if {$wl_actual == $radio_cnf} {
        set radio_cnf [expr $radio_cnf + 1]
    }

    UTF::Message LOG "" "wifi_setApDTIMInterval is about to set $radio_cnf"
    $Router wifi_api wifi_setApDTIMInterval $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_op [$Router wl -i $if_name dtim]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setApDTIMInterval and wl output is matching"
    } else {
        error "wifi_setApDTIMInterval and wl output is not matching"
    }

    set status_check [$Router wl -i $if_name status]
    UTF::Message LOG "" "wifi_setApDTIMInterval reset back"
    $Router wifi_api wifi_setApDTIMInterval $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 10

}

}
#INT wifi_setApBeaconInterval(INT apIndex, INT beaconInterval)
UTF::Try "wifi_setApBeaconInterval_$radio_intf" {

    set wl_actual [$Router wl -i $if_name bi]
    set radio_cnf [extract_config_from_file $file_name "bcn_interval"]

    if {$wl_actual == $radio_cnf} {
	set radio_cnf [expr $radio_cnf + 100]
    }

    UTF::Message LOG "" "wifi_setApBeaconInterval is about to set $radio_cnf"
    $Router wifi_api wifi_setApBeaconInterval $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_op [$Router wl -i $if_name bi]
    UTF::Message LOG "" "output from wifi_setApBeaconInterval wl force_bcn_rspec is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setApBeaconInterval and wl output is matching"
    } else {
        error "wifi_setApBeaconInterval and wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setApBeaconInterval reset back"
    $Router wifi_api wifi_setApBeaconInterval $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set status_check [$Router wl -i $if_name status]
    set wl_op [$Router wl -i $if_name bi]
    set isup_check [$Router wl -i $if_name bss]
    UTF::Message LOG "" "output from wifi_setApBeaconInterval after reset $wl_op"
}

#INT wifi_setRadioChannelMode(INT radioIndex, CHAR *channelMode, BOOL gOnlyFlag, BOOL nOnlyFlag, BOOL acOnlyFlag)
#Usage : wifi_api wifi_setRadioChannelMode <RadioIndex> <Channel Mode> <802.11g> <802.11n> <802.11a,c>(E.g: wifi_setRadioChannelMode 0 11A 1 1 0)
UTF::Try "wifi_setRadioChannelMode_$radio_intf" {

#wifi_api wifi_setRadioChannelMode 0 "11NGHT40PLUS" 0 1 0
#
    if {$idx == 0} {
	set band_cnf [extract_config_from_file $file_name "band_2g"]
    } elseif {$idx == 1} {
        set band_cnf [extract_config_from_file $file_name "band_5g"]
    } elseif {$idx == 2} {
        set band_cnf [extract_config_from_file $file_name "band_6g"]
    } else {
	error "Not a valid Radio Index"
    }

    if {$idx == 0} {
	set 11g_en 0
	set 11n_en 1
	set 11ac_en 0
    } elseif {$idx == 1} {
        set 11g_en 0
        set 11n_en 0
        set 11ac_en 1
    } elseif {$idx == 2} {
	set 11g_en 0
	set 11n_en 0
	set 11ac_en 0
	set 11ax_en 1
    }

    UTF::Message LOG "" " wifi_setRadioChannelMode is about to set $band_cnf"
    $Router wifi_api wifi_setRadioChannelMode $idx "$band_cnf" $11g_en $11n_en $11ac_en
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_band_op [$Router wifi_api wifi_getRadioStandard $idx]
    UTF::Message LOG "" "wl output is $wl_band_op"

    if {$idx == 0} {
	if {[string match -nocase "*nOnly=1*" $wl_band_op]} {
	    UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
	} elseif {[string match -nocase "*acOnly=1*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=ac*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=ax*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=n*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } else {
	    error "Output is not matching"
	}
    } elseif {$idx == 1} {
        if {[string match -nocase "*nOnly=1*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*acOnly=1*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=ac*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=ax*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=n*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } else {
            error "Output is not matching"
        }
    } elseif {$idx == 2} {
	if {[string match -nocase "*nOnly=1*" $wl_band_op]} {
	    UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
	} elseif {[string match -nocase "*acOnly=1*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=ac*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=ax*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } elseif {[string match -nocase "*standard=n*" $wl_band_op]} {
            UTF::Message LOG "" "wifi_setRadioChannelMode and wl output is matching"
        } else {
	    error "Output is not matching"
	}
    }

#RESET back radio configuration
    if {$idx == 0} {
        set 11g_en 0
        set 11n_en 1
        set 11ac_en 1
    } elseif {$idx == 1} {
        set 11g_en 0
        set 11n_en 1
        set 11ac_en 1
    } else {
        set 11g_en 0
        set 11n_en 0
        set 11ac_en 1
    }
    $Router wifi_api wifi_setRadioChannelMode $idx "$band_cnf" $11g_en $11n_en $11ac_en
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set status_check [$Router wl -i $if_name status]
}

#END OF ORDER CHECK 0

UTF::Try "wifi_getSSIDEnable_$radio_intf" {
	set api_op [$Router wifi_api wifi_getSSIDEnable $idx]

        if {[string match -nocase "*TRUE*" $api_op]} {
            UTF::Message LOG "" "wifi_getSSIDEnable and wl output is matching TRUE"
        } elseif {[string match -nocase "*FALSE*" $api_op]} {
            UTF::Message LOG "" "wifi_getSSIDEnable and wl output is matching FALSE"
        } else {
            error "wifi_getSSIDEnable and wl output is not matching $api_op"
        }

}

#wifi_getApWmmEnable
UTF::Try "wifi_getApWmmEnable_$radio_intf" {
    set ap_wmm_en_temp [$Router wifi_api wifi_getApWmmEnable $ap_index]

    if {[string match -nocase "*Not supported*" $ap_wmm_en_temp]} {
	error "wifi_getApWmmEnable NOT SUPPORTED"
    }
    set ap_wmm_en_op [lindex [split $ap_wmm_en_temp] end]

    UTF::Message LOG "" "output from wifi_getApWmmEnable is $ap_wmm_en_op"
    set wl_wme_op [$Router wl -i $if_name wme]

    UTF::Message LOG "" "output from wl lrl is $wl_wme_op"

    if {[string match -nocase "TRUE" $ap_wmm_en_op]} {
        if {$wl_wme_op == 1} {
            UTF::Message LOG "" "output from wifi_getApWmmEnable and wl matching"
        } else {
            error "output from wifi_getApWmmEnable TRUE and wl is not matching"
        }
    } elseif {[string match -nocase "FALSE" $ap_wmm_en_op]} {
        if {$wl_wme_op == 0} {
            UTF::Message LOG "" "output from wifi_getApWmmEnable and wl matching"
        } else {
            error "output from wifi_getApWmmEnable FALSE and wl is not matching"
        }
    }

    set status_check [$Router wl -i $if_name status]
    $Router nvram show
    UTF::Sleep 20
}

#INT wifi_setLED(INT radioIndex, BOOL enable)
UTF::Try "wifi_setLED_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "led_en"]

    UTF::Message LOG "" "wifi_setLED is about to set $radio_cnf"
    $Router wifi_api wifi_setLED $idx $radio_cnf

    set wl_op [$Router wl -i $if_name leds]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApBasicAuthenticationMode(INT apIndex, INT mode)
UTF::Try "wifi_setApBasicAuthenticationMode_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ap_auth"]

    set wl_auth_actual [$Router wifi_api wifi_getApBasicAuthenticationMode $ap_index]
    set wl_bcn_type [$Router wifi_api wifi_getApBeaconType $ap_index]
    UTF::Message LOG "" "original value is $wl_auth_actual $wl_bcn_type"

    if {[string match -nocase "*None*" $wl_auth_actual]} {
	set wl_auth_actual "None"
    } elseif {[string match -nocase "*PSK*" $wl_auth_actual]} {
        set wl_auth_actual "PSKAuthentication"
    }

    if {[string match -nocase "*None*" $radio_cnf]} {

	set bcn_type "None"
	$Router wifi_api wifi_setApBeaconType $ap_index $bcn_type
	UTF::Sleep 2

	UTF::Message LOG "" "wifi_setApBasicAuthenticationMode is about to set $radio_cnf"
	set ap_auth_mode_temp [$Router wifi_api wifi_setApBasicAuthenticationMode $ap_index $radio_cnf]
	wifi_apply_test_suite $Router
	UTF::Sleep 20

	set wl_op [$Router wifi_api wifi_getApBasicAuthenticationMode $ap_index]
	UTF::Message LOG "" "wl output is $wl_op"
        if {[string match -nocase "*$radio_cnf*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching None"
        }
    } elseif {[string match -nocase "*PSK*" $radio_cnf]} {

	set bcn_type "11i"
	$Router wifi_api wifi_setApBeaconType $ap_index $bcn_type
	UTF::Sleep 2

	UTF::Message LOG "" "wifi_setApBasicAuthenticationMode is about to set $radio_cnf"
	set ap_auth_mode_temp [$Router wifi_api wifi_setApBasicAuthenticationMode $ap_index $radio_cnf]
	wifi_apply_test_suite $Router
	UTF::Sleep 20

	set wl_op [$Router wifi_api wifi_getApBasicAuthenticationMode $ap_index]
	UTF::Message LOG "" "wl output is $wl_op"
        if {[string match -nocase "*$radio_cnf*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching None"
        }
    } else {
        error "inout METHOD or Mode is not correct"
    }

    $Router wifi_api wifi_setApBeaconType $ap_index $wl_bcn_type
    wifi_apply_test_suite $Router
    set isup_check [$Router wl -i $if_name bss]
    UTF::Sleep 2
    set status_check [$Router wl -i $if_name status]
    $Router wifi_api wifi_setApBasicAuthenticationMode $ap_index $wl_auth_actual
    UTF::Sleep 20
}

#INT wifi_getApBasicAuthenticationMode
UTF::Try "wifi_getApBasicAuthenticationMode_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    set ap_basic_auth_temp [$Router wifi_api wifi_getApBasicAuthenticationMode $ap_index]
    if {[string match -nocase "*Not supported*" $ap_basic_auth_temp]} {
	error "wifi_getApBasicAuthenticationMode NOT SUPPORTED"
    }
    set ap_basic_auth_op [lindex [split $ap_basic_auth_temp] 0]
    UTF::Message LOG "" "wifi_getApBasicAuthenticationMode is about to read $ap_basic_auth_op"

    if {$ap_index == 0} {
	set wl_op [extract_config_from_file $nvram_show_file "wl0_akm"]
    } elseif {$ap_index == 1} {
        set wl_op [extract_config_from_file $nvram_show_file "wl1_akm"]
    } elseif {$ap_index == $to_exec} {
        set wl_op [extract_config_from_file $nvram_show_file "wl2_akm"]
    } else {
	error "Not a valid Radio Index"
    }

    set wl_op [$Router wifi_api wifi_getApBeaconType $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*None*" $ap_basic_auth_op]} {
	if {[string match -nocase "*None*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching None"
	}
    } elseif {[string match -nocase "*Open*" $ap_basic_auth_op]} {
	if {[string match -nocase "*None*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching Open"
	}
    } elseif {[string match -nocase "*Shared*" $ap_basic_auth_op]} {
	if {[string match -nocase "*11i*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching Shared"
	}
    } elseif {[string match -nocase "*Open*Shared*" $ap_basic_auth_op]} {
	if {[string match -nocase "*11i*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching OPEN or SHARED"
	}
    } elseif {[string match -nocase "*PSK*" $ap_basic_auth_op]} {
        if {[string match -nocase "*11i*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching PSK"
        }
    } elseif {[string match -nocase "*EAP*" $ap_basic_auth_op]} {
        if {[string match -nocase "*11i*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching PSK"
        }
    } else {
	error "wl output is not matching ANY METHOD"
    }

}

UTF::Try "wifi_getRadioCountryCode_$radio_intf" {
	set country_temp [$Router wifi_api wifi_getRadioCountryCode $idx]

	set country_output [lindex [split $country_temp] end]

	set country_check [lindex [$Router wl -i $if_name country] 0]

	if {![string equal -length 2 $country_output $country_check]} {
	    if {[string match -nocase "#a" $country_check]} {
		UTF::Message LOG "" "wl output is country All"
	    } else {
		error "Radio auto channel output mismatch $country_output $country_check"
	    }
	}
    set status_check [$Router wl -i $if_name status]
}


#INT wifi_setRadioCountryCode(INT radioIndex, CHAR *CountryCode)
UTF::Try "wifi_setRadioCountryCode_$radio_intf" {
    set country_code_in [extract_config_from_file $file_name "country_code"]

    $Router wl -i $if_name status
    UTF::Message LOG "" "Country code read from the config file is $country_code_in"
    set country_temp [$Router wifi_api wifi_setRadioCountryCode $idx $country_code_in]
    if {[string match -nocase "*Not supported*" $country_temp]} {
	error "wifi_setRadioCountryCode  NOT SUPPORTED"
    }

    wifi_apply_test_suite $Router
    UTF::Sleep 2

    $Router wl -i $if_name status
    set wl_country_check [$Router wl -i $if_name country]
    set isup_check [$Router wl -i $if_name bss]
    set ccode_temp [$Router wifi_api wifi_getRadioCountryCode $idx]
    set ccode_op [lindex [split $ccode_temp] end]
    UTF::Message LOG "" "wifi_getRadioCountryCode output is $ccode_op"

    if {[string match -nocase "*$country_code_in*" $ccode_op]} {
	UTF::Message LOG "" "Country code set and read is matching"
	set country_code_in [extract_config_from_file $file_name "ccode"]
	set country_temp [$Router wifi_api wifi_setRadioCountryCode $idx $country_code_in]
	wifi_apply_test_suite $Router
	UTF::Sleep 5
    } else {
	error "Country code set and read is not matching"
    }
}

UTF::Try "wifi_getRadioEnable_$radio_intf" {
	set radio_enable_output [$Router wifi_api wifi_getRadioEnable $idx]
	set is_radio_enable [lindex [split $radio_enable_output] end]

	set isup_check [$Router wl -i $if_name bss]
	set status_check [$Router wl -i $if_name status]

	if {[string match -nocase "*down*" $isup_check]} {
		if {[string match "*TRUE*" $is_radio_enable]} {
			error "Radio enable output mismatch $is_radio_enable $isup_check"
		}
	} elseif {[string match -nocase "*up*" $isup_check]} {
                if {[string match -nocase "*FALSE*" $is_radio_enable]} {
                        error "Radio enable output mismatch $is_radio_enable $isup_check"
                }
	}
}

#INT wifi_setRadioEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioEnable_$radio_intf" {
    set radio_en_cnf [extract_config_from_file $file_name "radio_en"]

    UTF::Message LOG "" "wifi_setRadioEnable is about to set $radio_en_cnf"
    $Router wifi_api wifi_setRadioEnable $idx $radio_en_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set bss_stats [$Router wl -i $if_name bss]

    set wl_isup_op [$Router wifi_api wifi_getRadioEnable $idx]
    UTF::Message LOG "" "wl output is $wl_isup_op $bss_stats"

    if {$radio_en_cnf == 1} {
        if {[string match -nocase "*TRUE*" $wl_isup_op]} {
            UTF::Message LOG "" "wifi_setRadioEnable and wl output is matching"
        } else {
            error "wifi_setRadioEnable 1 and wl output is not matching"
        }
    } else {
        if {[string match -nocase "*FALSE*" $wl_isup_op]} {
            UTF::Message LOG "" "wifi_setRadioEnable and wl output is matching"
        } else {
            error "wifi_setRadioEnable 0 and wl output is not matching"
        }
    }

}

UTF::Try "wifi_getRadioStatus_$radio_intf" {

        set radio_status_output [$Router wifi_api wifi_getRadioStatus $idx]
        set is_radio_enable [lindex [split $radio_status_output] end]

        set isup_check [$Router wl -i $if_name bss]
	set status_check [$Router wl -i $if_name status]

        if {[string match -nocase "*up*" $isup_check]} {
                if {[string match $is_radio_enable "FALSE"]} {
                        error "Radio enable output mismatch $is_radio_enable $isup_check"
                }
        } else {
                if {[string match $is_radio_enable "TRUE"]} {
                        error "Radio enable output mismatch $is_radio_enable $isup_check"
                }
        }
}

UTF::Try "wifi_getRadioIfName_$radio_intf" {
	set radioName [$Router wifi_api wifi_getRadioIfName $idx]
	set str_len [string length $radioName]
	set if_name_api [string range $radioName $str_len-3 $str_len]
	UTF::Message LOG "" "interface name is $if_name_api"
	if {[string match $if_name_api $if_name]} {
	    UTF::Message LOG "" "wifi_getRadioIfName interface name matches"
	} else {
	    error "wifi_getRadioIfName interface name does not match wl $if_name"
	}
}

UTF::Try "wifi_getRadioMaxBitRate_$radio_intf" {
        $Router wifi_api wifi_getRadioMaxBitRate $idx

        set radio_maxbitrate_output [$Router wifi_api wifi_getRadioMaxBitRate $idx]
        set radio_maxbitrate [lindex [split $radio_maxbitrate_output] 0]

        UTF::Message LOG "" "wifi_getRadioMaxBitRate output parsed is $radio_maxbitrate"

        set wl_rate_check_op [$Router wl -i $if_name rate]
	set wl_rate_check [lindex [split $wl_rate_check_op] 0]

        UTF::Message LOG "" "wifi_getRadioMaxBitRate output parsed is $wl_rate_check"
        if {$wl_rate_check < 0 || $wl_rate_check > [expr $radio_maxbitrate + 1]} {
		error "Radio output mismatch wl: $wl_rate_check cmd: $radio_maxbitrate"
        }
}

UTF::Try "wifi_getRadioSupportedFrequencyBands_$radio_intf" {

        set radio_freqband_output [$Router wifi_api wifi_getRadioSupportedFrequencyBands $idx]
        set freqband_output [lindex [split $radio_freqband_output] end]

        if {$radio_intf == 0} {
                if {[string match $freqband_output "5GHz"]} {
                        error "Radio band output mismatch 2G"
                }
        } elseif {$radio_intf == 1} {
                if {[string match $freqband_output "2.4GHz"]} {
                        error "Radio band output mismatch 5G"
                }
        }

}

UTF::Try "wifi_getRadioOperatingFrequencyBand_$radio_intf" {
    set band_temp [$Router wifi_api wifi_getRadioOperatingFrequencyBand $idx]
    set band [lindex [split $band_temp] end]

    if {$idx == 0} {
	if {[string match -nocase "*2.4GHz*" $band]} {
	    UTF::Message LOG "" "It is 2.4G band"
	}
    } elseif {$idx == 1} {
        if {[string match -nocase "*5GHz*" $band]} {
	    UTF::Message LOG "" "It is 5G band"
	}
    } elseif {$idx == 2} {
        if {[string match -nocase "*6GHz*" $band]} {
            UTF::Message LOG "" "It is 6G band"
        }
    } else {
	error "Not a valid radio index"
    }
}

UTF::Try "wifi_getRadioSupportedStandards_$radio_intf" {

	set radio_suppstand_temp [$Router wifi_api wifi_getRadioSupportedStandards $idx]
	set radio_suppstand_output [lindex [split $radio_suppstand_temp] end]

	if {[string match -nocase "*g*" $radio_suppstand_output]} {
	    UTF::Message LOG "" "Supported standards are $radio_suppstand_output"
	} elseif {[string match -nocase "*n*" $radio_suppstand_output]} {
	    UTF::Message LOG "" "Supported standards are $radio_suppstand_output"
	} elseif {[string match -nocase "*ac*" $radio_suppstand_output]} {
	    UTF::Message LOG "" "*ac*" "Supported standards are $radio_suppstand_output"
	} elseif {[string match -nocase "*ax*" $radio_suppstand_output]} {
	    UTF::Message LOG "" "Supported standards are $radio_suppstand_output"
	} else {
	    error "Radio supported standard output mismatch $if_name $radio_suppstand_output"
	}

}

UTF::Try "wifi_getRadioStandard_$radio_intf" {
	set radio_std_temp [$Router wifi_api wifi_getRadioStandard $idx]
	set radio_std_op [lindex [split $radio_std_temp] end]

	set rad_mode_op [$Router wifi_api wifi_getRadioMode $idx]

	if {[string match -nocase "*standard*g*" $rad_mode_op]} {
	    UTF::Message LOG "" "Supported standards are $radio_std_op"
	} elseif {[string match -nocase "*standard*n*" $rad_mode_op]} {
	    UTF::Message LOG "" "Supported standards are $radio_std_op"
	} elseif {[string match -nocase "*standard*ac*" $rad_mode_op]} {
	    UTF::Message LOG "" "Supported standards are $radio_std_op"
	} elseif {[string match -nocase "*standard*ax*" $rad_mode_op]} {
	    UTF::Message LOG "" "Supported standards are $radio_std_op"
	} else {
	    error "Radio supported standard output mismatch $if_name $radio_std_op"
	}

}

UTF::Try "wifi_getRadioPossibleChannels_$radio_intf" {
	set channels_check [lindex [split [$Router wifi_api wifi_getRadioPossibleChannels $idx]] end]
	UTF::Message LOG "" "The channel check is $channels_check"
	set channels_temp [split $channels_check ","]
	UTF::Message LOG "" "The channel temp is $channels_temp"
	set first_check [lindex [split $channels_temp] 0]
	set last_check [lindex [split $channels_temp] end]

	UTF::Message LOG "" "The first channel in list is $first_check and last channel is $last_check"
	if {$idx == 0} {
		if {$first_check >= 1 && $last_check <= 14} {
			UTF::Message LOG "" "The possible channels are correct"
		} else {
			 error "Channels output mismatch"
		}
	} elseif {$idx == 1} {
                if {$first_check >= 36 && $last_check <= 177} {
                        UTF::Message LOG "" "The possible channels are correct"
                } else {
                         error "Channels output mismatch"
                }
	} elseif {$idx == 2} {
                if {$first_check >= 1 && $last_check <= 233} {
                        UTF::Message LOG "" "The possible channels are correct"
                } else {
                         error "Channels output mismatch"
                }
        } else {
		error "Not a valid radio index"
	}

#6g1 (0x5001)
#6g217/160 (0x6ecf)
#6g221/160 (0x6fcf)
#
}

UTF::Try "wifi_getRadioChannel_$radio_intf" {
	set radio_channel_output [$Router wifi_api wifi_getRadioChannel $idx]

	set status_check [$Router wl -i $if_name status]
	set bss_check [$Router wl -i $if_name bss]
	set radio_channel [lindex [split $radio_channel_output] end]

        set channel_check [lindex [$Router wl -i $if_name channel] end]
        if {$radio_channel != $channel_check} {
                error "Radio channel output mismatch $radio_channel_output $channel_check"
        }
}

#INT wifi_setRadioChannelWeights(INT radioIndex, const ULONG *output_weights)
UTF::Try "wifi_setRadioChannelWeights_$radio_intf" {

    set get_api_val [$Router wifi_api wifi_getRadioChannelWeights $idx]

    set api_op [$Router wifi_api wifi_setRadioChannelWeights $idx 1 11 21]
    UTF::Sleep 10

    set get_api_op [$Router wifi_api wifi_getRadioChannelWeights $idx]

    foreach j $get_api_op {
        if {$j <= 100} {
             UTF::Message LOG "" "channel weight is less than 100"
        } else {
	    UTF::Message LOG "" "LGI specific"
#	    error "channel weight is not less than 100"
        }
    }

    set api_op [$Router wifi_api wifi_setRadioChannelWeights $idx $get_api_val]
    UTF::Sleep 10
    $Router nvram show
    UTF::Sleep 5
}
#INT wifi_setRadioAutoChannelEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioAutoChannelEnable_$radio_intf" {
    set auotchan_cnf [extract_config_from_file $file_name "autochannel"]

    UTF::Sleep 5
    UTF::Message LOG "" "wifi_setRadioAutoChannelEnable is about to set $auotchan_cnf"
    $Router wifi_api wifi_setRadioAutoChannelEnable $idx $auotchan_cnf
    $Router wifi_api wifi_apply
    UTF::Sleep 60

#root@Docsis-Gateway:~# acs_cli -i wl0 info
#time: Thu Jan  1 00:06:52 1970
#
#acsd version: 1
#acsd ticks: 13
#acsd poll_interval: 1 seconds
#ifname: wl0, mode: disabled
#ifname: wl1, mode: disabled
#
    set wl_autochan_temp [$Router $acs_ver -i $if_name info]
    set wl_autochan_op [lindex [split $wl_autochan_temp] end]
    UTF::Message LOG "" "wl output is $wl_autochan_temp"

    set auto_channel_en_op [$Router wifi_api wifi_getRadioAutoChannelEnable $idx]

    if {$auotchan_cnf == 1} {
	if {[string match -nocase "*acsd version*" $wl_autochan_temp]} {
	    if {$auto_channel_en_op == 1} {
		UTF::Message LOG "" "and wl output is matching as montiored"
	    } else {
		error "wl output is not matching as montiored $auto_channel_en_op"
	    }
	} else {
	    error "and wl output is not matching with monitor"
	}
    } elseif {$auotchan_cnf == 0} {
        if {![string match -nocase "*auto*" $wl_autochan_temp]} {
	    if {$auto_channel_en_op == 0} {
                UTF::Message LOG "" "and wl output is matching not monitored"
	    } else {
		error "wl output is not matching as monitored $auto_channel_en_op"
	    }
        } else {
            error "and wl output is not matching with not monitor"
        }
    }

}

UTF::Try "wifi_getRadioAutoChannelEnable_$radio_intf" {
    set auto_channel_temp [$Router wifi_api wifi_getRadioAutoChannelEnable $idx]

    set auto_channel_output [lindex [split $auto_channel_temp] end]

    set wl_autochan_temp [$Router $acs_ver -i $if_name info]
    UTF::Message LOG "" "wl output is $wl_autochan_temp"

    if {$auto_channel_output == 1} {
        if {[string match -nocase "*auto*" $wl_autochan_temp]} {
            UTF::Message LOG "" "and wl output is matching as monitored"
        } else {
            error "and wl output is not matching with monitor"
        }
    } elseif {$auto_channel_output == 0} {
        if {![string match -nocase "*auto*" $wl_autochan_temp]} {
            UTF::Message LOG "" "and wl output is matching not monitored"
        } elseif {[string match -nocase "*monitor*" $wl_autochan_temp]} {
            UTF::Message LOG "" "and wl monitor output is matching"
        } else {
            error "and wl output is not matching with not monitor"
        }
    }
}

#INT wifi_getRadioAutoChannelRefreshPeriodSupported(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioAutoChannelRefreshPeriodSupported_$radio_intf" {
    #$Router wifi_api wifi_getRadioAutoChannelRefreshPeriodSupported $idx
    #error "wifi_getRadioAutoChannelRefreshPeriodSupported is NOT SUPPORTED"
    set auto_chan_refresh_temp [$Router wifi_api wifi_getRadioAutoChannelRefreshPeriodSupported $idx]
    set auto_chan_supp_op [lindex [split $auto_chan_refresh_temp] end]

    if {[string match -nocase "*Not supported*" $auto_chan_refresh_temp]} {
	error "wifi_getRadioAutoChannelRefreshPeriodSupported NOT SUPPORTED"
    }
    #currentlty not supported in 2.12
    #error "wifi_getRadioAutoChannelRefreshPeriodSupported is NOT SUPPORTED"
    UTF::Message LOG "" "wifi_getRadioAutoChannelRefreshPeriodSupported output parsed is $auto_chan_supp_op"
    $Router nvram show
    UTF::Sleep 5
}

#INT wifi_getRadioAutoChannelRefreshPeriod(INT radioIndex, ULONG *output_ulong)
UTF::Try "wifi_getRadioAutoChannelRefreshPeriod_$radio_intf" {
    #$Router wifi_api wifi_getRadioAutoChannelRefreshPeriod $idx
    #error "wifi_getRadioAutoChannelRefreshPeriod is NOT SUPPORTED"
    set auto_chan_period_temp [$Router wifi_api wifi_getRadioAutoChannelRefreshPeriod $idx]
    set auto_chan_period_op [lindex [split $auto_chan_period_temp] end]
    if {[string match -nocase "*Not supported*" $auto_chan_period_temp]} {
	error "wifi_getRadioAutoChannelRefreshPeriodSupported NOT SUPPORTED"
    }
    #currentlty not supported in 2.12
    #error "wifi_getRadioAutoChannelRefreshPeriod is NOT SUPPORTED"
    UTF::Message LOG "" "wifi_getRadioAutoChannelRefreshPeriod output parsed is $auto_chan_period_op"
}

#INT wifi_getRadioOperatingChannelBandwidth(INT radioIndex, CHAR *output_string)
UTF::Try "wifi_getRadioOperatingChannelBandwidth_$radio_intf" {

    set radio_op_channel_bw_op [$Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx]

#        0x1 - 20MHz
#        0x3 - 20/40MHz
#        0x7 - 20/40/80MHz
#        0xff - Unrestricted

    if {$idx == 0} {
	set wl_bw_cap_op [$Router wl -i $if_name bw_cap 2g]
    } elseif {$idx == 1} {
        set wl_bw_cap_op [$Router wl -i $if_name bw_cap 5g]
    } elseif {$idx == 2} {
	set wl_bw_cap_op [$Router wl -i $if_name bw_cap 6g]
    } else {
	error "Not a valid radio index"
    }

    UTF::Message LOG "" "wl output is $wl_bw_cap_op radio output is $radio_op_channel_bw_op"

    if {[string match -nocase "*160MHz*" $radio_op_channel_bw_op]} {

        UTF::Message LOG "" "Bandwidth matches for 160Mhz"
        if {$wl_bw_cap_op == 0xf} {
            UTF::Message LOG "" "Bandwidth matches for 160MHz"
        } else {
            error "Mismatch in supported bandwitd of 160MHz and wl output"
        }
    } elseif {[string match -nocase "*80MHz*" $radio_op_channel_bw_op]} {

	UTF::Message LOG "" "Bandwidth matches for 80Mhz"
	if {$wl_bw_cap_op == 0x7 || $wl_bw_cap_op == 0xf} {
	    UTF::Message LOG "" "Bandwidth matches for 80MHz"
	} else {
	    error "Mismatch in supported bandwitd of 80MHz and wl output"
	}
    } elseif {[string match -nocase "*40MHz*" $radio_op_channel_bw_op]} {
        if {$wl_bw_cap_op == 0x3 || $wl_bw_cap_op == 0x7 || $wl_bw_cap_op == 0xf} {
            UTF::Message LOG "" "Bandwidth matches for 40MHz"
	} else {
            error "Mismatch in supported bandwitd of 40MHz and wl output"
        }
    } elseif {[string match -nocase "*20MHz*" $radio_op_channel_bw_op]} {
        if {$wl_bw_cap_op == 0x1 || $wl_bw_cap_op == 0x3 || $wl_bw_cap_op == 0x7 || $wl_bw_cap_op == 0xf} {
            UTF::Message LOG "" "Bandwidth matches for 20MHz"
        } else {
            error "Mismatch in supported bandwitd of 20MHz and wl output"
        }
    } else {
	error "Not a valid channel supported bandwidth"
    }
    $Router nvram show
    UTF::Sleep 5
}

#INT wifi_setRadioOperatingChannelBandwidth(INT radioIndex, CHAR *bandwidth)
UTF::Try "wifi_setRadioOperatingChannelBandwidth_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx]

    if {$idx == 0} {
        set wl_bw_cap_op [$Router wl -i $if_name bw_cap 2g]
    } elseif {$idx == 1} {
        set wl_bw_cap_op [$Router wl -i $if_name bw_cap 5g]
    } elseif {$idx == 2} {
        set wl_bw_cap_op [$Router wl -i $if_name bw_cap 6g]
    } else {
        error "Not a valid radio index"
    }

    if {$idx == 0} {
	set radio_en_cnf [extract_config_from_file $file_name "bw_2g"]
    } elseif {$idx == 1} {
        set radio_en_cnf [extract_config_from_file $file_name "bw_5g"]
    } elseif {$idx == 2} {
	set radio_en_cnf [extract_config_from_file $file_name "bw_6g"]
    } else {
        error "Not a valid radio index"
    }

    UTF::Message LOG "" "wifi_setRadioOperatingChannelBandwidth is about to set $radio_en_cnf $wl_bw_cap_op"
    set auto_chan_op [$Router wifi_api wifi_getRadioAutoChannelEnable $idx]

    if {$auto_chan_op == 1} {
	#disable auto channel
	$Router wifi_api wifi_setRadioAutoChannelEnable $idx 0
	wifi_apply_test_suite $Router
	UTF::Sleep 20
    }

    UTF::Message LOG "" "wifi_setRadioOperatingChannelBandwidth is about to set $radio_en_cnf"
    $Router wifi_api wifi_setRadioOperatingChannelBandwidth $idx $radio_en_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_bw_op [$Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx]
    UTF::Message LOG "" "wl output is $wl_bw_op"

    if {[string match -nocase "*$radio_en_cnf*" $wl_bw_op]} {
            UTF::Message LOG "" "wifi_setRadioOperatingChannelBandwidth and wl output is matching"
    } else {
        error "wifi_setRadioOperatingChannelBandwidth and wl output is not matching $wl_bw_op"
    }

#reset
    $Router wifi_api wifi_setRadioOperatingChannelBandwidth $idx $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    if {$auto_chan_op == 1} {
	$Router wifi_api wifi_setRadioAutoChannelEnable $idx $auto_chan_op
	wifi_apply_test_suite $Router
	UTF::Sleep 20
    }
}

#INT wifi_getRadioExtChannel(INT radioIndex, CHAR *output_string)
UTF::Try "wifi_getRadioExtChannel_$radio_intf" {
    set rad_ext_chan_op [$Router wifi_api wifi_getRadioExtChannel $idx]

    if {[string match -nocase "*AboveControlChannel*" $rad_ext_chan_op]} {
	UTF::Message LOG "" "wifi_getRadioExtChannel output is AboveControlChannel"
    } elseif {[string match -nocase "*BelowControlChannel*" $rad_ext_chan_op]} {
	UTF::Message LOG "" "wifi_getRadioExtChannel output is BelowControlChannel"
    } elseif {[string match -nocase "*Auto*" $rad_ext_chan_op]} {
        UTF::Message LOG "" "wifi_getRadioExtChannel output is Auto"
    } else {
	error "Not a valid extension channel output like AboveControlChannel or Below Control Channel"
    }
}

#INT wifi_getRadioGuardInterval(INT radioIndex, CHAR *output_string)
UTF::Try "wifi_getRadioGuardInterval_$radio_intf" {
    set radio_gi_op [$Router wifi_api wifi_getRadioGuardInterval $idx]

    set wl_sgi_tx_op [$Router wl -i $if_name sgi_tx]

    UTF::Message LOG "" "wl output is $wl_sgi_tx_op"

    if {[string match -nocase "*Auto*" $radio_gi_op]} {

        UTF::Message LOG "" "Guard interval matches Auto"
        if {$wl_sgi_tx_op == -1} {
            UTF::Message LOG "" "sgi_tx is also Auto setting -1"
        } else {
            error "Mismatch in supported Guard interval wl output"
        }
    } elseif {$radio_gi_op == $wl_sgi_tx_op} {
	UTF::Message LOG "" "Guard interval matches $radio_gi_op"
    } else {
        error "Not a valid Guard interval value"
    }

}

#INT wifi_getRadioMCS(INT radioIndex, INT *output_INT)
UTF::Try "wifi_getRadioMCS_$radio_intf" {
    set radio_mcs_op [$Router wifi_api wifi_getRadioMCS $idx]

    if {[string match -nocase "*Not supported*" $radio_mcs_op]} {
	error "wifi_getRadioMCS NOT SUPPORTED"
    }

    if {[string match -nocase "*Auto*" $radio_mcs_op]} {
	if {$idx == 0} {
	    set wl_2g_rate_op [$Router wl -i $if_name 2g_rate]
	    if {[string match -nocase "*Auto*" $wl_2g_rate_op]} {
		UTF::Message LOG "" "2g_rate is also Auto setting"
	    } else {
		error "2g rate mismatch"
	    }
	} elseif {$idx == 1} {
            set wl_5g_rate_op [$Router wl -i $if_name 5g_rate]
            if {[string match -nocase "*Auto*" $wl_5g_rate_op]} {
                UTF::Message LOG "" "5g_rate is also Auto setting"
            } else {
                error "5g rate mismatch"
            }
	} elseif {$idx == 2} {
            set wl_6g_rate_op [$Router wl -i $if_name 6g_rate]
            if {[string match -nocase "*Auto*" $wl_6g_rate_op]} {
                UTF::Message LOG "" "5g_rate is also Auto setting"
            } else {
                error "5g rate mismatch"
            }
	}
    }
}

#INT wifi_getRadioTransmitPowerSupported(INT radioIndex, CHAR *output_list)
UTF::Try "wifi_getRadioTransmitPowerSupported_$radio_intf" {
    set radio_txpwr_sup_op [$Router wifi_api wifi_getRadioTransmitPowerSupported $idx]

    if {[string match -nocase "**100*" $radio_txpwr_sup_op]} {
	UTF::Message LOG "" "Matched values from wifi_getRadioTransmitPowerSupported"
    } else {
	error "Not matching values from wifi_getRadioTransmitPowerSupported output"
    }
}

UTF::Try "wifi_getRadioTransmitPower_$radio_intf" {
    set radio_tx_pwr_op [$Router wifi_api wifi_getRadioTransmitPower $idx]

    UTF::Message LOG "" "wifi_getRadioTransmitPower output is $radio_tx_pwr_op"

    set wl_txpwr1_op [$Router wl -i $if_name txpwr_percent]
    if {[string match -nocase "*$radio_tx_pwr_op*" $radio_tx_pwr_op]} {
	UTF::Message LOG "" "Matched values from wifi_getRadioTransmitPower"
    } else {
	error "Not matching values from wifi_getRadioTransmitPower output $wl_txpwr1_op"
    }

}


#INT wifi_setRadioTransmitPower(INT radioIndex, ULONG TransmitPower)
UTF::Try "wifi_setRadioTransmitPower_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "txpwr1"]

    UTF::Message LOG "" "wifi_setRadioTransmitPower is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioTransmitPower $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    #TOCHECK Need to verifu the % changed in curpower output
    set wl_temp [$Router wifi_api wifi_getRadioPercentageTransmitPower $idx]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$wl_op == $radio_cnf} {
        UTF::Message LOG "" "wifi_setRadioTransmitPower and wl output is matching"
    } else {
        error "wifi_setRadioTransmitPower and wl output is not matching"
    }

}

#INT wifi_setRadioIEEE80211hEnabled(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioIEEE80211hEnabled_$radio_intf" {
  if {$idx == 1} {
    set radio_cnf [extract_config_from_file $file_name "spect"]

    set radar_val [$Router wl -i $if_name radar]

    if {[string match -nocase "*Off*" $wl_op]} {
	set radar_op [$Router wl -i $if_name radar 0]
    } else {
	set radar_op [$Router wl -i $if_name radar 1]
    }
    UTF::Sleep 10

    UTF::Message LOG "" "wifi_setRadioIEEE80211hEnabled is about to set $radio_cnf"
    set set_11h_op [$Router wifi_api wifi_setRadioIEEE80211hEnabled $idx $radio_cnf]
    if {[string match -nocase "*Not supported*" $set_11h_op]} {
        error "wifi_setRadioIEEE80211hEnabled API NOT SUPPORTED"
    }
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_op [$Router wifi_api wifi_getRadioIEEE80211hEnabled $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    set radar_op [$Router wl -i $if_name radar $radar_val]

    if {$radio_cnf == 1} {
	if {[string match -nocase "*TRUE*" $wl_op]} {
	    UTF::Message LOG "" "wifi_setRadioIEEE80211hEnabled and wl output is matching On"
	} else {
	    error "wifi_setRadioIEEE80211hEnabled and wl output is not matchingi On"
	}
    } else {
        if {[string match -nocase "*FALSE*" $wl_op]} {
            UTF::Message LOG "" "wifi_setRadioIEEE80211hEnabled and wl output is matching Off"
        } else {
            error "wifi_setRadioIEEE80211hEnabled and wl output is not matchingi Off"
        }
    }

    #reset back to disable
    $Router wl -i $if_name radar $radar_val
    $Router nvram show
    UTF::Sleep 5
  }
}

#INT wifi_getRadioIEEE80211hSupported(INT radioIndex, BOOL *Supported)
UTF::Try "wifi_getRadioIEEE80211hSupported_$radio_intf" {

    set 11h_supp_op [$Router wifi_api wifi_getRadioIEEE80211hSupported $idx]
    if {[string match -nocase "*Not supported*" $11h_supp_op]} {
        error "wifi_getRadioIEEE80211hSupported API NOT SUPPORTED"
    }

#        1 - Loose interpretation of 11h spec - may join non-11h APs
#        2 - Strict interpretation of 11h spec - may not join non-11h APs
#        3 - Disable 11h and enable 11d
#        4 - Loose interpretation of 11h+d spec - may join non-11h APs

    set wl_spect_op [$Router wl -i $if_name cap]
    if {[string match -nocase "*may join non*11h*" $11h_supp_op]} {

	if {[string match -nocase "*802.11h*" $wl_spect_op]} {
	    UTF::Message LOG "" "Matched values from wl spect output"
	} else {
	    error "Not matching values from wifi_getRadioIEEE80211hSupported "
	}

    } elseif {[string match -nocase "*TRUE*" $11h_supp_op]} {
        if {[string match -nocase "*802.11h*" $wl_spect_op]} {
            UTF::Message LOG "" "Matched values from wl spect output"
        } else {
            error "Not matching values from wifi_getRadioIEEE80211hSupported "
        }
    } elseif {[string match -nocase "*FALSE*" $11h_supp_op]} {
        if {[string match -nocase "*802.11h*" $wl_spect_op]} {
            error "Not matching values from wifi_getRadioIEEE80211hSupported "
        } else {
            UTF::Message LOG "" "Matched values from wl spect output"
        }
    } else {
	error "wl spect output not matching"
    }
}

#INT wifi_getRadioIEEE80211hEnabled(INT radioIndex, BOOL *enable)
UTF::Try "wifi_getRadioIEEE80211hEnabled_$radio_intf" {

  if {$idx != 0} {
    set 11h_supp_op [$Router wifi_api wifi_getRadioIEEE80211hEnabled $idx]
    if {[string match -nocase "*Not supported*" $11h_supp_op]} {
        error "wifi_getRadioIEEE80211hEnabled API NOT SUPPORTED"
    }

    set wl_spect_op [$Router wl -i $if_name spect]
    if {[string match -nocase "*may join non*11h*" $11h_supp_op]} {

        if {[string match -nocase "*may join non*11h*" $wl_spect_op]} {
            UTF::Message LOG "" "Matched values from wl spect output"
        } else {
            error "Not matching values from wifi_getRadioIEEE80211hSupported "
        }

    } elseif {[string match -nocase "*TRUE*" $11h_supp_op]} {
        if {[string match -nocase "*may join non*11h*" $wl_spect_op]} {
            UTF::Message LOG "" "Matched values from wl spect output"
        } else {
            error "Not matching values from wifi_getRadioIEEE80211hSupported "
        }
    } elseif {[string match -nocase "*FALSE*" $11h_supp_op]} {
        if {[string match -nocase "*off*" $wl_spect_op]} {
            UTF::Message LOG "" "Matched values from wl spect output"
        } else {
            error "Not matching values from wifi_getRadioIEEE80211hSupported "
        }
    } else {
	error "wl spect output not matching"
    }

  }
}

#INT wifi_getRadioBeaconPeriod(INT radioIndex, UINT *output)
UTF::Try "wifi_getRadioBeaconPeriod_$radio_intf" {

    set radio_bcn_period_temp [$Router wifi_api wifi_getRadioBeaconPeriod $idx]

    set radio_bcn_period_op [lindex [split $radio_bcn_period_temp] end]
    if {[string match -nocase "*Not supported*" $radio_bcn_period_temp]} {
        error "wifi_getRadioBeaconPeriod API NOT SUPPORTED"
    }

    UTF::Sleep 2
    UTF::Message LOG "" "outputi from wifi_getRadioBeaconPeriod is $radio_bcn_period_op"

    set wl_bcn_period_op [$Router wl -i $if_name bi]

    UTF::Message LOG "" "output from wl bi is $wl_bcn_period_op"

    if {$radio_bcn_period_op == $wl_bcn_period_op} {
	UTF::Message LOG "" "output from wifi_getRadioBeaconPeriod is matching wl output"
    } else {
	error "Values from wifi_getRadioBeaconPeriod and wl is not matching NOT SUPPORTED"
    }
}

#INT wifi_setRadioBeaconPeriod(INT radioIndex, UINT BeaconPeriod)
UTF::Try "wifi_setRadioBeaconPeriod_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bi"]

    UTF::Message LOG "" "wifi_setRadioBeaconPeriod is about to set $radio_cnf"
    set bcn_period_temp [$Router wifi_api wifi_setRadioBeaconPeriod $idx $radio_cnf]
    if {[string match -nocase "*Not supported*" $bcn_period_temp]} {
        error "wifi_setRadioBeaconPeriod API NOT SUPPORTED"
    }
    wifi_apply_test_suite $Router
    UTF::Sleep 20

    set wl_temp [$Router wifi_api wifi_getRadioBeaconPeriod $idx]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioBeaconPeriod and wl output is matching"
    } else {
        error "wifi_setRadioBeaconPeriod and wl output is not matching"
    }

}

#INT wifi_getRadioBasicDataTransmitRates(INT radioIndex, CHAR *output)
UTF::Try "wifi_getRadioBasicDataTransmitRates_$radio_intf" {
    set basic_rate_temp [$Router wifi_api wifi_getRadioBasicDataTransmitRates $idx]
    set basic_rate_op [lindex [split $basic_rate_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioBasicDataTransmitRates is $basic_rate_op"

    set wl_rateset_op [$Router wl -i $if_name rateset]
    UTF::Message LOG "" "output from wl rateset is $wl_rateset_op"

    #split based on comma
    set rates_split [split $basic_rate_op ","]
    UTF::Message LOG "" "wl rates split output is $rates_split"

    set rates_check 0
    foreach j $rates_split {
	UTF::Message LOG "" "j is $j rates_check is $rates_check split is $rates_split"
	set to_apnd $j
	set rate_op [append $to_apnd "(b)"]
	UTF::Message LOG "" "output from combined string is $rate_op"
	if {[string match -nocase $rate_op $wl_rateset_op]} {
            incr rates_check
	}
    }

    #if {[string match -nocase "*$basic_rate_op*" $wl_rateset_op]} {
    #	UTF::Message LOG "" "output from wifi_getRadioBasicDataTransmitRates is matching wl output"
    #} else {
    #	error "Values from wifi_getRadioBasicDataTransmitRates and wl is not matching"
    #}
}


#INT wifi_setRadioBasicDataTransmitRates(INT radioIndex, CHAR *TransmitRates)
UTF::Try "wifi_setRadioBasicDataTransmitRates_$radio_intf" {
    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $file_name "basicrate_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "basicrate_5g"]
    } elseif {$idx == 2} {
	set radio_cnf [extract_config_from_file $file_name "basicrate_6g"]
    } else {
	error "Not a valid radio index"
    }

    UTF::Message LOG "" "wifi_setRadioBasicDataTransmitRates is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioBasicDataTransmitRates $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set basic_rate_temp [$Router wifi_api wifi_getRadioBasicDataTransmitRates $idx]
    set basic_rate_op [lindex [split $basic_rate_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioBasicDataTransmitRates is $basic_rate_op"

    set wl_rateset_op [$Router wl -i $if_name rateset]
    UTF::Message LOG "" "output from wl rateset is $wl_rateset_op"

    #split based on comm
    set rates_split [split $basic_rate_op ","]
    UTF::Message LOG "" "wl rates split output is $rates_split"

    set rates_check 0
    foreach j $rates_split {
        UTF::Message LOG "" "j is $j rates_check is $rates_check split is $rates_split"
        set to_apnd $j
        set rate_op [append $to_apnd "(b)"]
        UTF::Message LOG "" "output from combined string is $rate_op"
        if {[string match -nocase $rate_op $wl_rateset_op]} {
            incr rates_check
        }
    }

}

#INT wifi_getRadioSupportedDataTransmitRates(INT radioIndex, char *output_rates)
UTF::Try "wifi_getRadioSupportedDataTransmitRates_$radio_intf" {
    set supp_radio_txrate_op [$Router wifi_api wifi_getRadioSupportedDataTransmitRates $idx]

    set wl_rateset_op [$Router wl -i $if_name rateset]
    UTF::Message LOG "" "output from wl rateset is $wl_rateset_op"

    #split based on comm
    set rates_split [split $supp_radio_txrate_op ","]
    UTF::Message LOG "" "wl rates split output is $rates_split"

    set rates_check 0
    foreach j $rates_split {
        UTF::Message LOG "" "j is $j rates_check is $rates_check split is $rates_split"
        set to_apnd $j
        set rate_op [append $to_apnd "(b)"]
        UTF::Message LOG "" "output from combined string is $rate_op"
        if {[string match -nocase $rate_op $wl_rateset_op]} {
            incr rates_check
        }
    }

}

#INT wifi_getRadioOperationalDataTransmitRates(INT radioIndex, char *output_rates)
UTF::Try "wifi_getRadioOperationalDataTransmitRates_$radio_intf" {
    set oper_txrate_op [$Router wifi_api wifi_getRadioOperationalDataTransmitRates $idx]

    set wl_rateset_op [$Router wl -i $if_name rateset]
    UTF::Message LOG "" "output from wl rateset is $wl_rateset_op"

    #split based on comm
    set rates_split [split $oper_txrate_op ","]
    UTF::Message LOG "" "wl rates split output is $rates_split"

    set rates_check 0
    foreach j $rates_split {
        UTF::Message LOG "" "j is $j rates_check is $rates_check split is $rates_split"
        set to_apnd $j
        set rate_op [append $to_apnd "(b)"]
        UTF::Message LOG "" "output from combined string is $rate_op"
        if {[string match -nocase $rate_op $wl_rateset_op]} {
            incr rates_check
        }
    }

}

#INT wifi_setRadioObssCoexistenceEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setRadioObssCoexistenceEnable_$radio_intf" {

if {$idx == 0} {
    set radio_cnf [extract_config_from_file $file_name "obss_coex"]

    UTF::Message LOG "" "wifi_setRadioObssCoexistenceEnable is about to set $radio_cnf"

    if {$ap_index == 0} {
	set bw_cap_val [$Router nvram get wl0_bw_cap]
    } elseif {$ap_index == 1} {
        set bw_cap_val [$Router nvram get wl1_bw_cap]
    } elseif {$ap_index == 2} {
	set bw_cap_val [$Router nvram get wl2_bw_cap]
    } else {
	error "Not a valid radio index"
    }

    set nvram_show [$Router nvram show]

    if {$bw_cap_val < 3} {
	$Router wifi_api wifi_setRadioOperatingChannelBandwidth $idx "40MHz"
	wifi_apply_test_suite $Router
	UTF::Sleep 5

	$Router wifi_api wifi_getRadioOperatingChannelBandwidth $idx
    }

    $Router wifi_api wifi_setRadioObssCoexistenceEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_op [$Router wl -i $if_name obss_coex]
    UTF::Message LOG "" "wl output is $wl_op"

    set nvram_show [$Router nvram show]

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioObssCoexistenceEnable and wl output is matching"
    } else {
        error "wifi_setRadioObssCoexistenceEnable and wl output is not matching"
    }
}

}

#INT wifi_getRadioAMSDUEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioAMSDUEnable_$radio_intf" {
    set radio_msdu_en_temp [$Router wifi_api wifi_getRadioAMSDUEnable $idx]

    set wl_amsdu_op [$Router wl -i $if_name amsdu]

    UTF::Message LOG "" "output from wl amsdu is $wl_amsdu_op"

    set radio_msdu_en_op [lindex [split $radio_msdu_en_temp] end]

    if {$radio_msdu_en_op == $wl_amsdu_op} {
	UTF::Message LOG "" "output from wifi_getRadioAMSDUEnable is matching"
    } else {
	error "wifi_getRadioAMSDUEnable output and wl output is not matching"
    }
}

#INT wifi_setRadioAMSDUEnable(INT radioIndex, BOOL amsduEnable)
UTF::Try "wifi_setRadioAMSDUEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "amsdu"]

    set amsdu_val [$Router wifi_api wifi_getRadioAMSDUEnable $idx]

    if {$radio_cnf == $amsdu_val} {
	if {$radio_cnf == 0} {
	    set $radio_cnf 1
	} else {
	    set $radio_cnf 0
	}
    }

    UTF::Message LOG "" "wifi_setRadioAMSDUEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioAMSDUEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name amsdu]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wifi_setRadioAMSDUEnable and wl output is matching"
    } else {
        error "wifi_setRadioAMSDUEnable and wl output is not matching"
    }

    $Router wifi_api wifi_setRadioAMSDUEnable $idx $amsdu_val
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_getRadioTxChainMask(INT radioIndex, INT *output_int)
UTF::Try "wifi_getRadioTxChainMask_$radio_intf" {

    set radio_chain_temp [$Router wifi_api wifi_getRadioTxChainMask $idx]

    set radio_chain_op [lindex [split $radio_chain_temp] end]

    UTF::Message LOG "" "output from wifi API is $radio_chain_op"

    set wl_txchain_temp [$Router wl -i $if_name txchain]

    set wl_txchain_num [lindex [split $wl_txchain_temp] 0]

    set num_bits 0
    while {$wl_txchain_num} {

        set num_bits [expr $num_bits + [expr $wl_txchain_num & 1]]
        set temp $wl_txchain_num
        set wl_txchain_num [expr $temp >> 1]
    }

    UTF::Message LOG "" "output from num_bits is $num_bits"

    if {$radio_chain_op == $num_bits} {
        UTF::Message LOG "" "output from wifi_getRadioTxChainMask is matching"
    } else {
        error "wifi_getRadiorTxChainMask output and wl output is not matching"
    }

}

#INT wifi_getRadioRxChainMask(INT radioIndex, INT *output_int)
UTF::Try "wifi_getRadioRxChainMask_$radio_intf" {
    set radio_chain_temp [$Router wifi_api wifi_getRadioRxChainMask $idx]

    set radio_chain_op [lindex [split $radio_chain_temp] end]

    UTF::Message LOG "" "output from wifi API is $radio_chain_op"

    if {$idx == 0} {
	set wl_rxchain_num [extract_config_from_file $nvram_show_file "wl0_hw_rxchain"]
    } elseif {$idx == 1} {
        set wl_rxchain_num [extract_config_from_file $nvram_show_file "wl1_hw_rxchain"]
    } elseif {$idx == 2} {
        set wl_rxchain_num [extract_config_from_file $nvram_show_file "wl2_hw_rxchain"]
    }

    UTF::Message LOG "" "output from NVRAM is $wl_rxchain_num"

    set num_bits 0
    while {$wl_rxchain_num} {

	set num_bits [expr $num_bits + [expr $wl_rxchain_num & 1]]
	set temp $wl_rxchain_num
	set wl_rxchain_num [expr $temp >> 1]
    }

    UTF::Message LOG "" "output from num_bits is $num_bits"

    if {$radio_chain_op == $num_bits} {
        UTF::Message LOG "" "output from wifi_getRadioRxChainMask is matching"
    } else {
        error "wifi_getRadioRxChainMask output and wl output is not matching"
    }

    set ap_status [$Router wl -i $if_name status]
}

#INT wifi_pushSSID(INT apIndex, CHAR *ssid)
UTF::Try "wifi_pushSSID_$radio_intf" {

    set wl_actual [$Router wl -i $if_name ssid]
    UTF::Message LOG "" "wl output is $wl_actual"

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    if {$ap_index == 0} {
	set radio_cnf [extract_config_from_file $file_name "push_wl0_ssid"]
    } elseif {$ap_index == 1} {
        set radio_cnf [extract_config_from_file $file_name "push_wl1_ssid"]
    } elseif {$ap_index == $to_exec} {
        set radio_cnf [extract_config_from_file $file_name "push_wl2_ssid"]
    } else {
	error "Not a valid radio index"
    }

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushSSID $ap_index $radio_cnf
    UTF::Sleep 60

    set wl_op [$Router wl -i $if_name ssid]
    UTF::Message LOG "" "wl output is $wl_op"

    set ap_status [$Router wl -i $if_name status]
    if {[string match -nocase "*$radio_cnf*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"

	#Reset back to original SSID
	if {$ap_index == 0} {
	    set radio_cnf [extract_config_from_file $file_name "wl0_ssid"]
	} elseif {$ap_index == 1} {
            set radio_cnf [extract_config_from_file $file_name "wl1_ssid"]
        } elseif {$ap_index == 2} {
	    set radio_cnf [extract_config_from_file $file_name "wl2_ssid"]
	}

	UTF::Message LOG "" "about to set $radio_cnf"
	$Router wifi_api wifi_pushSSID $ap_index $radio_cnf
	UTF::Sleep 20

	set wl_op [$Router wl -i $if_name ssid]
	UTF::Message LOG "" "wl output is $wl_op"

    } else {
	$Router wifi_api wifi_pushSSID $ap_index $wl_actual
	UTF::Sleep 60
        error "wl output is not matching"
    }

    set ap_status [$Router wl -i $if_name status]

}

UTF::Try "wifi_getSSIDRadioIndex_$radio_intf" {
    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    set radio_idx [$Router wifi_api wifi_getSSIDRadioIndex $to_exec]

    if {$radio_idx == $idx } {
	UTF::Message LOG "" "wl output matching $idx $radio_idx"
    } else {
	error "wl output not matching $idx $radio_idx"
    }
}

#INT wifi_getRadioUpTime(INT radioIndex, ULONG *uptime)
UTF::Try "wifi_getRadioUpTime_$radio_intf" {
    set uptime_1 [$Router wifi_api wifi_getRadioUpTime $idx]

    UTF::Sleep 5

    set uptime_2 [$Router wifi_api wifi_getRadioUpTime $idx]

    if {$uptime_1 < $uptime_2} {
	UTF::Message LOG "" "uptime is increasing"
    } else {
	error "uptime is not increasing $uptime_1 $uptime_2"
    }
}

#Radio interface name is returned as output, not sure if this necessary
#as we have "wifi_getRadioIfName"
UTF::Try "wifi_getApName_$radio_intf" {
    set if_name_check [$Router wifi_api wifi_getApName $ap_index]

    if {[string match -nocase $if_name $if_name_check]} {
	UTF::Message LOG "" "Interface name is increasing"
    } else {
	error "Interface name is not increasing $if_name_check"
    }
}

#INT wifi_getApRtsThresholdSupported(INT apIndex, BOOL *output_bool)
UTF::Try "wifi_getApRtsThresholdSupported_$radio_intf" {
    set rts_thresh_temp [$Router wifi_api wifi_getApRtsThresholdSupported $ap_index]

    set rts_thresh_op [lindex [split $rts_thresh_temp] end]

    UTF::Message LOG "" "output from wifi_getApRtsThresholdSupported is $rts_thresh_op"

    set wl_rtsthresh_temp [$Router wl -i $if_name rtsthresh]
    set wl_rtsthresh_op [lindex [split $wl_rtsthresh_temp] 0]
    UTF::Message LOG "" "output from wl rtsthresh is $wl_rtsthresh_op"

    if {[string match -nocase "TRUE" $rts_thresh_op]} {
	if {$wl_rtsthresh_op != 0} {
	    UTF::Message LOG "" "output from wifi_getApRtsThresholdSupported and wl matching"
	} else {
	    error "output from wifi_getApRtsThresholdSupported TRUE and wl is not matching"
	}
    } elseif {[string match -nocase "FALSE" $rts_thresh_op]} {
        if {$wl_rtsthresh_op == 0} {
            UTF::Message LOG "" "output from wifi_getApRtsThresholdSupported and wl matching"
        } else {
            error "output from wifi_getApRtsThresholdSupported FALSE and wl is not matching"
        }
    }
}

#INT wifi_getApWpaEncryptionMode(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApWpaEncryptionMode_$radio_intf" {
    set wpa_encr_temp [$Router wifi_api wifi_getApWpaEncryptionMode $ap_index]
    set wpa_encr_op [lindex [split $wpa_encr_temp] end]

    UTF::Message LOG "" "output from wifi_getApWpaEncryptionMode is $wpa_encr_op"

#wl0_crypto=aes

    #set wl_wsec_op [$Router wl -i $if_name wsec]
    if {$idx == 0} {
	set wl_wsec_op [extract_config_from_file $file_name "wl0_crypto"]
    } elseif {$idx == 1} {
        set wl_wsec_op [extract_config_from_file $file_name "wl1_crypto"]
    } elseif {$idx == 2} {
	set wl_wsec_op [extract_config_from_file $file_name "wl2_crypto"]
    }

    UTF::Message LOG "" "output from NVRAM is $wl_wsec_op"

#wsec    wireless security bit vector
#        1 - WEP enabled
#        2 - TKIP enabled
#        4 - AES enabled
#        8 - WSEC in software
#        0x80 - FIPS enabled
#        0x100 - WAPI enabled
    if {[string match -nocase "*$wl_wsec_op*" $wpa_encr_op]} {
	    UTF::Message LOG "" "output from wifi_getApWpaEncryptionMode and nvram matching"
    } else {
	error "None of the existing encryption matches"
    }
}

UTF::Try "wifi_getApNumDevicesAssociated_$radio_intf" {
	set no_of_assoc_stas_output [$Router wifi_api wifi_getApNumDevicesAssociated $ap_index]
	set no_of_assoc_stas [lindex [split $no_of_assoc_stas_output] end]

	UTF::Message LOG "" "The number of Associated STAs in $if_name is $no_of_assoc_stas"

	set assoclist_output [$Router wl -i $if_name assoclist]
	UTF::Message LOG "" "wl assoclist output is $assoclist_output"

	set assoclist_split [split $assoclist_output "\n"]
	UTF::Message LOG "" "wl assoclist split output is $assoclist_split"

	set assoclist_check 0
	foreach j $assoclist_split {
		puts "$j STA from assoclist is $assoclist_check in list"
		incr assoclist_check
	}

	UTF::Message LOG "" "The number of Associated STAs from assoclist is $assoclist_check"

	if {$no_of_assoc_stas == $assoclist_check} {
		UTF::Message LOG "" "The number of Associated STAs are matching"
	} else {
		error "Number of associated STAa are not matching"
	}
}

#
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_OPEN "None"
#//   wifi_setApBeaconType <93>None<94>                      wifi_setApBasicAuthenticationMode("None")
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WEP_64 "WEP-64"
#//   wifi_setApBeaconType RDKB do not support WEP
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WEP_128 "WEP-128"
#//   wifi_setApBeaconType RDKB do not support WEP
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WPA_Personal "WPA-Personal"
#//   wifi_setApBeaconType <93>WPA<94>                       wifi_setApBasicAuthenticationMode("PSKAuthentication")
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WPA2_Personal "WPA2-Personal"
#//   wifi_setApBeaconType "11i"                          wifi_setApBasicAuthenticationMode("PSKAuthentication ")
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WPA_WPA2_Personal "WPA-WPA2-Personal"
#//   wifi_setApBeaconType "WPAand11i"          wifi_setApBasicAuthenticationMode("PSKAuthentication ")
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WPA_Enterprise "WPA-Enterprise"
#//   wifi_setApBeaconType <93>WPA<94>                       wifi_setApBasicAuthenticationMode("EAPAuthentication")
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WPA2_Enterprise "WPA2-Enterprise"
#//   wifi_setApBeaconType "11i"                          wifi_setApBasicAuthenticationMode("EAPAuthentication")
#// #define WIFIACCESSPOINTSECURITY_MODEENABLED_WPA_WPA2_Enterprise "WPA-WPA2-Enterprise"
#//   wifi_setApBeaconType "WPAand11i"          wifi_setApBasicAuthenticationMode("EAPAuthentication")
#
#
#INT wifi_setApWpaEncryptionMode(INT apIndex, CHAR *encMode)
UTF::Try "wifi_setApWpaEncryptionMode_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wpa_enc_mode"]

    UTF::Message LOG "" "wifi_setApWpaEncryptionMode is about to set $radio_cnf"
    $Router wifi_api wifi_setApWpaEncryptionMode $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

#    set wl_op [$Router wl -i $if_name wsec]
#    UTF::Message LOG "" "wl output is $wl_op"

    if {$idx == 0} {
        set wl_op [extract_config_from_file $file_name "wl0_crypto"]
    } elseif {$idx == 1} {
        set wl_op [extract_config_from_file $file_name "wl1_crypto"]
    } elseif {$idx == 2} {
        set wl_op [extract_config_from_file $file_name "wl2_crypto"]
    } else {
	error "Not a valid radio index"
    }

    UTF::Message LOG "" "wl output is $wl_op"
    if {[string match -nocase "*AES*" $radio_cnf]} {
        if {[string match -nocase "*aes*" $wl_op]} {
            UTF::Message LOG "" "output AES from wifi_setApWpaEncryptionMode and wl matching"
        } else {
            error "output from wifi_setApWpaEncryptionMode and wl is not matching"
        }
    } elseif {[string match -nocase "*WEP*" $radio_cnf]} {
        if {[string match -nocase "*wep*" $wl_op]} {
            UTF::Message LOG "" "output AES from wifi_setApWpaEncryptionMode and wl matching"
        } else {
            error "output from wifi_setApWpaEncryptionMode and wl is not matching"
        }
    } elseif {[string match -nocase "*tkip*" $radio_cnf]} {
        if {[string match -nocase "*tkip*" $wl_op]} {
            UTF::Message LOG "" "output AES from wifi_setApWpaEncryptionMode and wl matching"
        } else {
            error "output from wifi_setApWpaEncryptionMode and wl is not matching"
        }
    } elseif {[string match -nocase "*fips*" $radio_cnf]} {
        if {[string match -nocase "*fips*" $wl_op]} {
            UTF::Message LOG "" "output AES from wifi_setApWpaEncryptionMode and wl matching"
        } else {
            error "output from wifi_setApWpaEncryptionMode and wl is not matching"
        }
    } elseif {[string match -nocase "*wapi*" $radio_cnf]} {
        if {[string match -nocase "*wapi*" $wl_op]} {
            UTF::Message LOG "" "output AES from wifi_setApWpaEncryptionMode and wl matching"
        } else {
            error "output from wifi_setApWpaEncryptionMode and wl is not matching"
        }
    } elseif {[string match -nocase "*disable*" $radio_cnf]} {
        if {[string match -nocase "*disable*" $wl_op]} {
            UTF::Message LOG "" "output AES from wifi_setApWpaEncryptionMode and wl matching"
        } else {
            error "output from wifi_setApWpaEncryptionMode and wl is not matching"
        }
    } else {
        error "None of the existing encryption matches"
    }

}

#to add MAC device address to filter list
UTF::Try "wifi_addApAclDevice_$radio_intf" {

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    if {$ap_index == 0} {
	set radio_cnf [extract_config_from_file $file_name "add_acl_2g"]
    } elseif {$ap_index == 1} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_5g"]
    } elseif {$ap_index == $to_exec} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_6g"]
    } else {
	error "Not a valid radio index"
    }

    $Router wifi_api wifi_addApAclDevice $ap_index $radio_cnf
    UTF::Sleep 10

    set acl_devices_op [$Router wifi_api wifi_getApAclDevices $ap_index]

    if {[string match -nocase "*$radio_cnf*" $acl_devices_op]} {
	UTF::Message LOG "" "Added ACL devices to list"
    } else {
	error "Added ACL devices not in list"
    }
}

UTF::Try "wifi_getApAclDevices_$radio_intf" {
    set acl_dev_get_op [$Router wifi_api wifi_getApAclDevices $ap_index]

    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_6g"]
    } else {
	error "Not a valid radio index"
    }

    if {[string match -nocase "*$radio_cnf*" $acl_dev_get_op]} {
        UTF::Message LOG "" "Added ACL devices to list"
    } else {
        error "Added ACL devices not in list"
    }
}

#to delete all MAC device address from filter list
UTF::Try "wifi_delApAclDevices_$radio_intf" {
    set get_acl_op [$Router wifi_api wifi_getApAclDevices $ap_index]
    UTF::Sleep 2

    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_6g"]
    } else {
        error "Not a valid radio index"
    }

    if {[string match -nocase "*$radio_cnf*" $get_acl_op]} {

	set del_acl_op [$Router wifi_api wifi_delApAclDevices $ap_index]

	set get_acl_op [$Router wifi_api wifi_getApAclDevices $ap_index]
	UTF::Sleep 2

	if {[string match -nocase "*$radio_cnf*" $get_acl_op]} {
		error "Delete ACL devices have not removed"
	} else {
		UTF::Message LOG "" "Delete ACL devices have removed"
	}
    } else {
	UTF::Message LOG "" "No associated STA in list"
    }
}

#INT wifi_getApAclDeviceNum(INT apIndex, UINT *output_uint)
UTF::Try "wifi_getApAclDeviceNum_$radio_intf" {
    set acl_dev_num [$Router wifi_api wifi_getApAclDeviceNum $ap_index]
    UTF::Sleep 2

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
    if {$ap_index == 0} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_2g"]
    } elseif {$ap_index == 1} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_5g"]
    } elseif {$ap_index == $to_exec} {
        set radio_cnf [extract_config_from_file $file_name "add_acl_6g"]
    } else {
        error "Not a valid radio index"
    }

    $Router wifi_api wifi_addApAclDevice $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    set acl_dev_add_op [$Router wifi_api wifi_getApAclDeviceNum $ap_index]

    if {$acl_dev_add_op == [expr $acl_dev_num + 1]} {
	UTF::Message LOG "" "Added ACL devices to increase total and matching"
    } else {
	error "Added ACL devices to increase total and not matching $acl_dev_add_op $acl_dev_num"
    }
}

#INT wifi_setApBasicAuthenticationMode(INT apIndex, CHAR *authMode)
UTF::Try "wifi_setApBasicAuthenticationMode_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "basic_auth_mode"]

    set wl_actual [$Router wifi_api wifi_getApBasicAuthenticationMode $ap_index]
    UTF::Message LOG "" "wl output is $wl_actual"

    UTF::Message LOG "" "wifi_setApBasicAuthenticationMode is about to set $radio_cnf"
    $Router wifi_api wifi_setApBasicAuthenticationMode $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getApBasicAuthenticationMode $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$radio_cnf*" $wl_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
	error "wl output not matching $wl_op"
    }

    UTF::Message LOG "" "wifi_setApBasicAuthenticationMode is about to reset $wl_actual"
    $Router wifi_api wifi_setApBasicAuthenticationMode $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_setApMacAddressControlMode(INT apIndex, INT filterMode)
UTF::Try "wifi_setApMacAddressControlMode_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "macmode"]

    UTF::Message LOG "" "wifi_setApMacAddressControlMode is about to set $radio_cnf"
    $Router wifi_api wifi_setApMacAddressControlMode $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name macmode]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 2} {
	if {$wl_op == 1} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching"
	}
    } elseif {$radio_cnf == 1} {
        if {$wl_op == 2} {
            UTF::Message LOG "" "wl output is matching"
        } else {
            error "wl output is not matching"
        }
    } elseif {$radio_cnf == $wl_op} {
            UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

if {0} {
#INT wifi_setApEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setApEnable_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getApEnable $ap_index]

    if {[string match -nocase "*FALSE*" $wl_actual]} {
        set radio_cnf 1
    } else {
        set radio_cnf 0
    }

    UTF::Message LOG "" "wifi_setApEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 30

    set wl_op [$Router wifi_api wifi_getApEnable $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 1} {
	if {[string match -nocase "*TRUE*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching TRUE"
	} else {
	    error "wl output is not matching TRUE"
	}
    } else {
	if {[string match -nocase "*FALSE*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching FALSE"
	} else {
	    error "wl output is not matching FALSE"
	}
    }

    #Need to reset to TRUE to make sure the AP is enabled
    set radio_cnf 1

    UTF::Message LOG "" "wifi_setApEnable is about to reset"
    $Router wifi_api wifi_setApEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 30
}
}

#INT wifi_getApEnable(INT apIndex, BOOL *output_bool)
UTF::Try "wifi_getApEnable_$radio_intf" {
    set ap_enable_temp [$Router wifi_api wifi_getApEnable $ap_index]
    set ap_enable_op [lindex [split $ap_enable_temp] end]

    UTF::Message LOG "" "output from wifi_getApEnable is $ap_enable_op"

    if {$idx == 0} {
	set wl_op [extract_config_from_file $nvram_show_file "wl0_bss_enabled"]
    } elseif {$idx == 1} {
	set wl_op [extract_config_from_file $nvram_show_file "wl1_bss_enabled"]
    } elseif {$idx == 2} {
	set wl_op [extract_config_from_file $nvram_show_file "wl2_bss_enabled"]
    } else {
	error "Not a valid radio index"
    }

    UTF::Message LOG "" "output from wl isup is $wl_op"

    if {$wl_op == 1} {
	if {[string match $ap_enable_op "FALSE"]} {
	    error "AP enable output mismatch isup is 1"
	}
    } elseif {$wl_op == 0} {
	if {[string match $ap_enable_op "TRUE"]} {
	    error "AP enable output mismatch isup is 0"
	}
    }

}

#INT wifi_getApStatus(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApStatus_$radio_intf" {

    set ap_status_temp [$Router wifi_api wifi_getApStatus $ap_index]
    set ap_status_op [lindex [split $ap_status_temp] end]

    UTF::Message LOG "" "output from wifi_getApStatus is $ap_status_op"
    set wl_isup_op [$Router wl -i $if_name isup]

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    UTF::Message LOG "" "output from wl isup is $wl_isup_op"
    if {$wl_isup_op == 1} {
        if {[string match -nocase "*Down*" $ap_status_op]} {
            error "AP status output mismatch isup is 1"
        } elseif {[string match -nocase "*Disable*" $ap_status_op]} {
            error "AP status output mismatch isup is 1"
        }
    } elseif {$wl_isup_op == 0} {
        if {[string match -nocase $ap_status_op "Up"]} {
            error "AP status output mismatch isup is 0"
        } elseif {[string match -nocase "*Enable*" $ap_status_op]} {
            error "AP status output mismatch isup is 1"
        }
    }

}

#INT wifi_setApSsidAdvertisementEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setApSsidAdvertisementEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ssid_adv_en"]

    UTF::Message LOG "" "wifi_setApSsidAdvertisementEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApSsidAdvertisementEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_temp [$Router wifi_api wifi_getApSsidAdvertisementEnable $ap_index]
    set wl_op [lindex [split $wl_temp] end]
    #set wl_op [$Router wl -i $if_name closed]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 1} {
        if {$wl_op == 1} {
            UTF::Message LOG "" "wifi_setApSsidAdvertisementEnable and wl output is matching"
        } else {
            error "wifi_setApSsidAdvertisementEnable and wl output is not matching"
        }
    } elseif {$radio_cnf == 0} {
        if {$wl_op == 0} {
            UTF::Message LOG "" "wifi_setApSsidAdvertisementEnable and wl output is matching"
        } else {
            error "wifi_setApSsidAdvertisementEnable and wl output is not matching"
        }
    }

}

#INT wifi_getApRetryLimit(INT apIndex, UINT *output)
UTF::Try "wifi_getApRetryLimit_$radio_intf" {
    set ap_retry_lmt_temp [$Router wifi_api wifi_getApRetryLimit $ap_index]
    set ap_retry_lmt_op [lindex [split $ap_retry_lmt_temp] end]

    UTF::Message LOG "" "output from wifi_getApRetryLimit is $ap_retry_lmt_op"
    set wl_srl_op [$Router wl -i $if_name srl]

    UTF::Message LOG "" "output from wl srl is $wl_srl_op"

    if {$ap_retry_lmt_op == $wl_srl_op} {
	UTF::Message LOG "" "output from wifi_getApRetryLimit and wl matching"
    } else {
	error "output from wifi_getApRetryLimit and wl is not matching NOT SUPPORTED"
    }
}

UTF::Try "wifi_getApSsidAdvertisementEnable_$radio_intf" {
        set ssid_adv_temp [$Router wifi_api wifi_getApSsidAdvertisementEnable $ap_index]

        set ssid_adv_output [lindex [split $ssid_adv_temp] end]

        set ssid_adv_check [lindex [$Router wl -i $if_name closed] end]

	#We need to comapre the opposite here because closed command output 0
	#means SSID advertisement is open
        if {$ssid_adv_output == $ssid_adv_check} {
		error "Radio AP advertisement enable output mismatch $ssid_adv_output $ssid_adv_check"
        }
}

#INT wifi_setApRetryLimit(INT apIndex, UINT number)
UTF::Try "wifi_setApRetryLimit_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "srl"]

    UTF::Message LOG "" "wifi_setApRetryLimit is about to set $radio_cnf"
    $Router wifi_api wifi_setApRetryLimit $ap_index $radio_cnf
    UTF::Sleep 2
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_temp [$Router wifi_api wifi_getApRetryLimit $ap_index]
    UTF::Sleep 2
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getApWMMCapability(INT apIndex, BOOL *output)
UTF::Try "wifi_getApWMMCapability_$radio_intf" {
    set ap_wmm_cap_temp [$Router wifi_api wifi_getApWMMCapability $ap_index]
    set ap_wmm_cap_op [lindex [split $ap_wmm_cap_temp] end]

    UTF::Message LOG "" "output from wifi_getApWMMCapability is $ap_wmm_cap_op"
    set wl_wme_op [$Router wl -i $if_name wme]

    UTF::Message LOG "" "output from wl lrl is $wl_wme_op"

    if {[string match -nocase "Enabled" $ap_wmm_cap_op]} {
	if {$wl_wme_op == 1} {
            UTF::Message LOG "" "output from wifi_getApWMMCapability and wl matching"
	} else {
            error "output from wifi_getApWMMCapability Enabled and wl is not matching"
	}
    } elseif {[string match -nocase "Disabled" $ap_wmm_cap_op]} {
        if {$wl_wme_op == 0} {
            UTF::Message LOG "" "output from wifi_getApWMMCapability and wl matching"
        } else {
            error "output from wifi_getApWMMCapability Enabled and wl is not matching"
        }
    }

}

#INT wifi_getApUAPSDCapability(INT apIndex, BOOL *output)
UTF::Try "wifi_getApUAPSDCapability_$radio_intf" {

    set ap_uapsd_cap_temp [$Router wifi_api wifi_getApUAPSDCapability $ap_index]
    set ap_uapsd_cap_op [lindex [split $ap_uapsd_cap_temp] end]

    UTF::Message LOG "" "output from wifi_getApUAPSDCapability is $ap_uapsd_cap_op"
    set wl_wme_apsd_op [$Router wl -i $if_name wme_apsd]

    UTF::Message LOG "" "output from wl wme_apsd is $wl_wme_apsd_op"
    if {$wl_wme_apsd_op == 1} {
        if {[string match -nocase "*Enabled*" $ap_uapsd_cap_op]} {
	    UTF::Message LOG "" "output from wifi_getApUAPSDCapability and wl matching Enabled"
        } else {
            error "AP WME UAPSD output mismatch wme_apsd is 1"
	}
    } elseif {$wl_wme_apsd_op == 0} {
        if {[string match -nocase "*Disabled*" $ap_uapsd_cap_op]} {
	    UTF::Message LOG "" "output from wifi_getApUAPSDCapability and wl matching Disabled"
        } else {
            error "AP WME UAPSD output mismatch wme_apsd is 0"
        }
    }

}

#INT wifi_setApWmmEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setApWmmEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wme"]

    UTF::Message LOG "" "wifi_setApWmmEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApWmmEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name wme]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#wifi_getApWmmUapsdEnable
UTF::Try "wifi_getApWmmUapsdEnable_$radio_intf" {
    set ap_wmm_uapsd_temp [$Router wifi_api wifi_getApWmmUapsdEnable $ap_index]
    set ap_wmm_uapsd_op [lindex [split $ap_wmm_uapsd_temp] end]

    UTF::Message LOG "" "output from wifi_getApWmmUapsdEnable is $ap_wmm_uapsd_op"
    set wl_wme_uapsd_op [$Router wl -i $if_name wme_apsd]

    UTF::Message LOG "" "output from wl lrl is $wl_wme_uapsd_op"

    if {[string match -nocase "Enabled" $ap_wmm_uapsd_op]} {
        if {$wl_wme_uapsd_op == 1} {
            UTF::Message LOG "" "output from wifi_getApWmmUapsdEnable and wl matching"
        } else {
            error "output from wifi_getApWmmUapsdEnable Enabled and wl is not matching"
        }
    } elseif {[string match -nocase "Disabled" $ap_wmm_uapsd_op]} {
        if {$wl_wme_uapsd_op == 0} {
            UTF::Message LOG "" "output from wifi_getApWmmUapsdEnable and wl matching"
        } else {
            error "output from wifi_getApWmmUapsdEnable Enabled and wl is not matching"
        }
    }

}

#INT wifi_setApWmmUapsdEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setApWmmUapsdEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wme_apsd"]

    UTF::Message LOG "" "wifi_setApWmmUapsdEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApWmmUapsdEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wl -i $if_name wme_apsd]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

UTF::Try "wifi_getApIsolationEnable_$radio_intf" {
        set apiso_mode_temp [$Router wifi_api wifi_getApIsolationEnable $ap_index]

        set apiso_mode_output [lindex [split $apiso_mode_temp] end]

	if {$idx == 0} {
	    set apiso_mode_check [extract_config_from_file $nvram_show_file "wl0_ap_isolate"]
	} elseif {$idx == 1} {
            set apiso_mode_check [extract_config_from_file $nvram_show_file "wl1_ap_isolate"]
        } elseif {$idx == 2} {
            set apiso_mode_check [extract_config_from_file $nvram_show_file "wl1_ap_isolate"]
        } else {
	    error "Not a valid radio index"
	}

        if {$apiso_mode_check == 0} {
                if {[string match $apiso_mode_output "TRUE"]} {
                        error "Radio Isolation enable output mismatch $apiso_mode_output $apiso_mode_check"
                }
        } elseif {$apiso_mode_check == 1} {
                if {[string match $apiso_mode_output "FALSE"]} {
                        error "Radio Isolation enable output mismatch $apiso_mode_output $apiso_mode_check"
                }
        }

}

#INT wifi_getApBeaconRate(INT apIndex, char *output_BeaconRate)
UTF::Try "wifi_getApBeaconRate_$radio_intf" {
    set ap_bcn_rate_temp [$Router wifi_api wifi_getApBeaconRate $ap_index]
    set ap_bcn_rate_op [lindex [split $ap_bcn_rate_temp] end]

    UTF::Message LOG "" "output from wifi_getApBeaconRate is $ap_bcn_rate_op"

    set wl_force_bcn_rspec_temp [$Router wl -i $if_name force_bcn_rspec]
    set wl_force_bcn_rspec_op [lindex [split $wl_force_bcn_rspec_temp] 0]
    UTF::Message LOG "" "output from wl force_bcn_rspec is $wl_force_bcn_rspec_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*1Mbps*" $ap_bcn_rate_op]} {
	if {$wl_force_bcn_rspec_op == 2 || $wl_force_bcn_rspec_op == 0} {
	    UTF::Message LOG "" "output from wifi_getApBeaconRate and wl matching 1Mbps"
	} else {
	    error "output from wifi_getApBeaconRate and wl is not matching 1Mbps"
	}
    } elseif {[string match -nocase "*2Mbps*" $ap_bcn_rate_op]} {
        if {$wl_force_bcn_rspec_op == 4} {
            UTF::Message LOG "" "output from wifi_getApBeaconRate and wl matching 2Mbps"
        } else {
            error "output from wifi_getApBeaconRate and wl is not matching 2Mbps"
        }
    } elseif {[string match -nocase "*6Mbps*" $ap_bcn_rate_op]} {
        if {$wl_force_bcn_rspec_op == 12} {
            UTF::Message LOG "" "output from wifi_getApBeaconRate and wl matching 6Mbps"
        } else {
	    if {$idx == 1 && $wl_force_bcn_rspec_op == 0} {
		UTF::Message LOG "" "output from wifi_getApBeaconRate and wl matching 6Mbps"
	    } else {
		error "output from wifi_getApBeaconRate and wl is not matching 6Mbps"
	    }
        }
    } else {
	error "output from wifi_getApBeaconRate and wl is not matching"
    }
}

#INT wifi_getApMaxAssociatedDevices(INT apIndex, UINT *output)
UTF::Try "wifi_getApMaxAssociatedDevices_$radio_intf" {
    set ap_max_assoc_temp [$Router wifi_api wifi_getApMaxAssociatedDevices $ap_index]
    set ap_max_assoc_op [lindex [split $ap_max_assoc_temp] end]

    UTF::Message LOG "" "output from wifi_getApMaxAssociatedDevices is $ap_max_assoc_op"

    set wl_max_assoc_temp [$Router wl -i $if_name bss_maxassoc]
    set wl_max_assoc [lindex [split $wl_max_assoc_temp] 0]

    UTF::Message LOG "" "No of MAX Associated STA from wl output is $wl_max_assoc"

    if {$wl_max_assoc == $ap_max_assoc_op} {
	UTF::Message LOG "" "output from wifi_getApMaxAssociatedDevices and wl matching"
    } else {
	error "output from wifi_getApMaxAssociatedDevices and wl is not matching"
    }

}

#INT wifi_getApSecurityModesSupported(INT apIndex, CHAR *output)
UTF::Try "wifi_getApSecurityModesSupported_$radio_intf" {
    set ap_sec_mode_op [$Router wifi_api wifi_getApSecurityModesSupported $ap_index]

    set apsec_mode_check [lindex [$Router wl -i $if_name wpa_auth] end]

    if {[string match -nocase "*None*WPA*Enterprise*" $ap_sec_mode_op]} {
	UTF::Message LOG "" "SecurityModesSupported matches expected valuees"
    } else {
	error "SecurityModesSupported not matching $ap_sec_mode_op"
    }
}

UTF::Try "wifi_getApSecurityModeEnabled_$radio_intf" {
    set apsec_mode_temp [$Router wifi_api wifi_getApSecurityModeEnabled $ap_index]

    set apsec_mode_output [lindex [split $apsec_mode_temp] end]

    set apsec_mode_check [lindex [$Router wl -i $if_name wpa_auth] end]

    if {[string match $apsec_mode_output "None"]} {
	if {[string match -nocase "*Disabled*" $apsec_mode_check]} {
            UTF::Message LOG "" "SecurityModesSupported matches None"
        } else {
            error "SecurityModesSupported not matching None $apsec_mode_output $apsec_mode_check"
        }
    } elseif {[string match "*WPA*" $apsec_mode_output]} {
        if {[string match "*WPA*" $apsec_mode_check]} {
            UTF::Message LOG "" "SecurityModesSupported matches WPA"
        } else {
            error "SecurityModesSupported not matching WPA"
        }
    } elseif {[string match "*SHA*" $ap_sec_mode_op]} {
        if {[string match "*SHA*" $apsec_mode_check]} {
            UTF::Message LOG "" "SecurityModesSupported matches SHA"
        } else {
            error "SecurityModesSupported not matching SHA"
        }
    } elseif {[string match "*FT*" $ap_sec_mode_op]} {
        if {[string match "*FT*" $apsec_mode_check]} {
            UTF::Message LOG "" "SecurityModesSupported matches FT"
        } else {
            error "SecurityModesSupported not matching FT"
        }
    } elseif {[string match -nocase "*Disabled*" $ap_sec_mode_op]} {
        if {[string match -nocase "*disabled*" $apsec_mode_check]} {
            UTF::Message LOG "" "SecurityModesSupported matches WPA"
        } else {
            error "SecurityModesSupported not matching disabled"
        }
    } else {
        error "SecurityModesEnabled is not matching Any $apsec_mode_output $apsec_mode_check"
    }
}

UTF::Try "wifi_setApSecurityModeEnabled_$radio_intf" {
	set sec_mode [extract_config_from_file $file_name "sec_mode"]

	set api_actual [$Router wifi_api wifi_getApSecurityModeEnabled $ap_index]
	UTF::Sleep 2
#0x0001  WPA-NONE
#0x0002  WPA-802.1x
#0x0004  WPA-PSK
#0x0040  WPA2-802.1x
#0x0080  WPA2-PSK
#0x1000  1X-SHA256
#0x4000  FT
#0x8000  PSK-SHA256
#0x0000  disabled
        $Router wifi_api wifi_setApSecurityModeEnabled $ap_index $sec_mode
	$Router wifi_api wifi_apply
	UTF::Sleep 10

        set apsec_mode_encheck [lindex [$Router wifi_api wifi_getApSecurityModeEnabled $ap_index] 0]
	UTF::Message LOG "" "sec mode obtained from wpa_auth command is $apsec_mode_encheck"

	if {[string match -nocase "*$apsec_mode_encheck*" $sec_mode]} {
		UTF::Message LOG "" "wl output is matching"
        } else {
                error "AP security mode set failed $apsec_mode_encheck"
        }

        $Router wifi_api wifi_setApSecurityModeEnabled $ap_index $api_actual
	$Router wifi_api wifi_apply
	UTF::Sleep 10
}

#INT wifi_getApSecurityPreSharedKey(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApSecurityPreSharedKey_$radio_intf" {
    set ap_sec_psk_op [$Router wifi_api wifi_getApSecurityPreSharedKey $ap_index]
    UTF::Message LOG "" "PSK from get command is $ap_sec_psk_op"

    UTF::Message LOG "" "Get PMK is not allowed in Wifi Driver"

    if {$idx == 0} {
        set nvram_wpa_psk_op [extract_config_from_file $nvram_show_file "wl0_wpa_psk"]
    } elseif {$idx == 1} {
        set nvram_wpa_psk_op [extract_config_from_file $nvram_show_file "wl1_wpa_psk"]
    } elseif {$idx == 2} {
        set nvram_wpa_psk_op [extract_config_from_file $nvram_show_file "wl2_wpa_psk"]
    }

    UTF::Message LOG "" "NVRAM output is $nvram_wpa_psk_op"

    if {[string match -nocase "*$ap_sec_psk_op*" $nvram_wpa_psk_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApSecurityPreSharedKey(INT apIndex, CHAR *preSharedKey)
UTF::Try "wifi_setApSecurityPreSharedKey_$radio_intf" {

    set ap_sec_psk_actual [$Router wifi_api wifi_getApSecurityPreSharedKey $ap_index]
    UTF::Message LOG "" "PSK from get command is $ap_sec_psk_actual"

    set radio_cnf [extract_config_from_file $file_name "set_pmk"]

    UTF::Message LOG "" "wifi_setApSecurityPreSharedKey is about to set $radio_cnf"
    $Router wifi_api wifi_setApSecurityPreSharedKey $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    #UTF::Message LOG "" "Get PMK is not allowed in Wifi Driver"
if {0} {
    if {$idx == 0} {
	set wl_op [extract_config_from_file $file_name "wl0_wpa_psk"]
	UTF::Message LOG "" "wl output is $wl_op"
    } elseif {$idx == 1} {
        set wl_op [extract_config_from_file $file_name "wl1_wpa_psk"]
        UTF::Message LOG "" "wl output is $wl_op"
    } elseif {$idx == 2} {
        set wl_op [extract_config_from_file $file_name "wl2_wpa_psk"]
        UTF::Message LOG "" "wl output is $wl_op"
    } else {
	error "Not a valid radio index"
    }
}
    set wl_op [$Router wifi_api wifi_getApSecurityPreSharedKey $ap_index]

    if {[string match -nocase $radio_cnf $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

    $Router wifi_api wifi_setApSecurityPreSharedKey $ap_index $ap_sec_psk_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 10
}

UTF::Try "wifi_setApSecurityKeyPassphrase_$radio_intf" {

    set ap_pass_phrase_val [$Router wifi_api wifi_getApSecurityKeyPassphrase $ap_index]

    set to_set_phrase 1234123456
    $Router wifi_api wifi_setApSecurityKeyPassphrase $ap_index $to_set_phrase
    wifi_apply_test_suite $Router
    UTF::Sleep 30

    set ap_pass_phrase_op [$Router wifi_api wifi_getApSecurityKeyPassphrase $ap_index]

    if {[string match -nocase "*$ap_pass_phrase_op*" $to_set_phrase]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    #reset back to original value
    $Router wifi_api wifi_setApSecurityKeyPassphrase $ap_index $ap_pass_phrase_val
    wifi_apply_test_suite $Router
    UTF::Sleep 30
}

UTF::Try "wifi_getApSecurityKeyPassphrase_$radio_intf" {
    set ap_pass_phrase_op [$Router wifi_api wifi_getApSecurityKeyPassphrase $ap_index]

    UTF::Message LOG "" "Get PMK is not allowed in Wifi Driver"

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    if {$idx == 0} {
        set nvram_wpa_psk_op [extract_config_from_file $nvram_show_file "wl0_wpa_psk"]
    } elseif {$idx == 1} {
        set nvram_wpa_psk_op [extract_config_from_file $nvram_show_file "wl1_wpa_psk"]
    } elseif {$idx == 2} {
        set nvram_wpa_psk_op [extract_config_from_file $nvram_show_file "wl2_wpa_psk"]
    }

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    UTF::Message LOG "" "NVRAM output is $nvram_wpa_psk_op"

    if {[string match -nocase "*$ap_pass_phrase_op*" $nvram_wpa_psk_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_getApWpsEnable(INT apIndex, BOOL *output_bool)
UTF::Try "wifi_getApWpsEnable_$radio_intf" {

    set ap_wps_en_temp [$Router wifi_api wifi_getApWpsEnable $ap_index]
    set ap_wps_en_op [lindex [split $ap_wps_en_temp] end]

    UTF::Message LOG "" "output from wifi_getApWpsEnable is $ap_wps_en_op"

    #set nvram_wps_mode_op [$Router nvram show | grep wl0_wps_mode]

    if {$idx == 0} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl0_wps_mode"]
    } elseif {$idx == 1} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl1_wps_mode"]
    } elseif {$idx == 2} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl2_wps_mode"]
    }

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    UTF::Message LOG "" "NVRAM output is $nvram_wps_mode_op"

    if {$ap_wps_en_op == 1} {
	if {[string match -nocase "*enabled*" $nvram_wps_mode_op]} {
	    UTF::Message LOG "" "output from wifi_getApWpsEnable and wl matching 1"
	} else {
	    error "output from wifi_getApWpsEnable and wl not matching 1"
	}
    } elseif {$ap_wps_en_op == 0} {
        if {[string match -nocase "*disabled*" $nvram_wps_mode_op]} {
            UTF::Message LOG "" "output from wifi_getApWpsEnable and wl matching 0"
        } else {
            error "output from wifi_getApWpsEnable and wl not matching 0"
        }
    }

}

#INT wifi_setApWpsEnable(INT apIndex, BOOL enableValue)
UTF::Try "wifi_setApWpsEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wps_en"]

    UTF::Message LOG "" "wifi_setApWpsEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApWpsEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set ap_wps_en_temp [$Router wifi_api wifi_getApWpsEnable $ap_index]
    set ap_wps_en_op [lindex [split $ap_wps_en_temp] end]

    if {$radio_cnf == $ap_wps_en_op} {
        UTF::Message LOG "" "wl output is matching"
    }

}

#INT wifi_getApWpsConfigMethodsSupported(INT apIndex, CHAR *output)
UTF::Try "wifi_getApWpsConfigMethodsSupported_$radio_intf" {
    set ap_wps_config_temp [$Router wifi_api wifi_getApWpsConfigMethodsSupported $ap_index]
    set ap_wps_config_op [lindex [split $ap_wps_config_temp] end]

    UTF::Message LOG "" "output from wifi_getApWpsConfigMethodsSupported is $ap_wps_config_op"

    if {$idx == 0} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl0_wps_method_enabled"]
    } elseif {$idx == 1} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl1_wps_method_enabled"]
    } elseif {$idx == 2} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl2_wps_method_enabled"]
    }

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    UTF::Message LOG "" "NVRAM output is $nvram_wps_mode_op"

    if {[string match -nocase "*$nvram_wps_mode_op*" $ap_wps_config_op]} {
        UTF::Message LOG "" "output from wifi_getApWpsConfigMethodsSupported and wl matching"
    } else {
	error "output from wifi_getApWpsConfigMethodsSupported and wl not matching $nvram_wps_mode_op"
    }

}

#INT wifi_getApWpsConfigMethodsEnabled(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApWpsConfigMethodsEnabled_$radio_intf" {
    set ap_wps_config_en_temp [$Router wifi_api wifi_getApWpsConfigMethodsEnabled $ap_index]
    set ap_wps_config_en_op [lindex [split $ap_wps_config_en_temp] end]

    UTF::Message LOG "" "output from wifi_getApWpsConfigMethodsEnabled is $ap_wps_config_en_op"

    if {$idx == 0} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl0_wps_method_enabled"]
    } elseif {$idx == 1} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl1_wps_method_enabled"]
    } elseif {$idx == 2} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl2_wps_method_enabled"]
    }

    UTF::Message LOG "" "NVRAM output is $nvram_wps_mode_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*$nvram_wps_mode_op*" $ap_wps_config_en_op]} {
        UTF::Message LOG "" "output from wifi_getApWpsConfigMethodsSupported and wl matching"
    } else {
        error "output from wifi_getApWpsConfigMethodsSupported and wl not matching $nvram_wps_mode_op"
    }
}

#INT wifi_setApWpsConfigMethodsEnabled(INT apIndex, CHAR *methodString)
UTF::Try "wifi_setApWpsConfigMethodsEnabled_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wps_config"]

    UTF::Message LOG "" "wifi_setApWpsConfigMethodsEnabled is about to set $radio_cnf"
    $Router wifi_api wifi_setApWpsConfigMethodsEnabled $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set ap_wps_config_en_temp [$Router wifi_api wifi_getApWpsConfigMethodsEnabled $ap_index]
    set ap_wps_config_en_op [lindex [split $ap_wps_config_en_temp] end]

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*$radio_cnf*" $ap_wps_config_en_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching $ap_wps_config_en_op"
    }

}

#INT wifi_getApWpsDevicePIN(INT apIndex, ULONG *output_ulong)
UTF::Try "wifi_getApWpsDevicePIN_$radio_intf" {
    set ap_wps_pin_temp [$Router wifi_api wifi_getApWpsDevicePIN $ap_index]
    set ap_wps_pin_op [lindex [split $ap_wps_pin_temp] end]

    UTF::Message LOG "" "output from wifi_getApWpsDevicePIN is $ap_wps_pin_op"

    if {$idx == 0} {
        set nvram_wps_pin_op [extract_config_from_file $nvram_show_file "wps_device_pin"]
    } elseif {$idx == 1} {
        set nvram_wps_pin_op [extract_config_from_file $nvram_show_file "wps_device_pin"]
    } elseif {$idx == 2} {
        set nvram_wps_pin_op [extract_config_from_file $nvram_show_file "wps_device_pin"]
    }

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    UTF::Message LOG "" "NVRAM output is $nvram_wps_pin_op"

    if {[string match -nocase "*$nvram_wps_pin_op*" $ap_wps_pin_op]} {
        UTF::Message LOG "" "output from aifi_getApWpsDevicePIN and wl matching"
    } else {
#        error "output from wifi_getApWpsDevicePIN and wl not matching $nvram_wps_pin_op"
    }
}

#INT wifi_setApWpsDevicePIN(INT apIndex, ULONG pin)
UTF::Try "wifi_setApWpsDevicePIN_$radio_intf" {

    set ap_wps_pin_temp [$Router wifi_api wifi_getApWpsDevicePIN $ap_index]
    set ap_wps_pin_orig [lindex [split $ap_wps_pin_temp] end]

    set radio_cnf [extract_config_from_file $file_name "wps_PIN"]

    UTF::Message LOG "" "wifi_setApWpsDevicePIN is about to set $radio_cnf"
    $Router wifi_api wifi_setApWpsDevicePIN $ap_index $radio_cnf
    $Router wifi_api wifi_apply
    UTF::Sleep 30

    set ap_wps_pin_temp [$Router wifi_api wifi_getApWpsDevicePIN $ap_index]
    set ap_wps_pin_op [lindex [split $ap_wps_pin_temp] end]

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*$ap_wps_pin_op*" $radio_cnf]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching $ap_wps_pin_op"
    }

    $Router wifi_api wifi_setApWpsDevicePIN $ap_index $ap_wps_pin_orig
    $Router wifi_api wifi_apply
    UTF::Sleep 30
}

#INT wifi_getApWpsConfigurationState(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApWpsConfigurationState_$radio_intf" {
    set ap_wps_config_st_temp [$Router wifi_api wifi_getApWpsConfigurationState $ap_index]

    set ap_wps_config_st_op [lindex [split $ap_wps_config_st_temp] end]

    UTF::Message LOG "" "output from wifi_getApWpsConfigurationState is $ap_wps_config_st_temp"

    set nvram_lan_oob_op [extract_config_from_file $nvram_show_file "lan_wps_oob"]
    UTF::Message LOG "" "output from NVRAM is $nvram_lan_oob_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*Not configured*" $ap_wps_config_st_temp]} {
	if {[string match -nocase "*enabled*" $nvram_lan_oob_op]} {
            UTF::Message LOG "" "output from wifi_getApWpsDevicePIN and wl matching"
	} else {
	    error "output from wifi_getApWpsConfigurationState and wl not matching $nvram_lan_oob_op"
	}
    } else {
	if {[string match -nocase "*disabled*" $nvram_lan_oob_op]} {
            UTF::Message LOG "" "output from wifi_getApWpsConfigurationState and wl matching"
	} else {
	    error "output from wifi_getApWpsConfigurationState and wl not matching $nvram_lan_oob_op"
	}
    }
}

#INT wifi_setApWpsEnrolleePin(INT apIndex, CHAR *pin)
UTF::Try "wifi_setApWpsEnrolleePin_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "wps_enrolee_PIN"]

    UTF::Message LOG "" "wifi_setApWpsEnrolleePin is about to set $radio_cnf"
    $Router wifi_api wifi_setApWpsEnrolleePin $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 160

    set wl_op [$Router wifi_api wifi_getApWpsEnrolleePin $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"
    if {[string match -nocase $radio_cnf $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    }

}

#INT wifi_setApWpsButtonPush(INT apIndex)
UTF::Try "wifi_setApWpsButtonPush_$radio_intf" {

    $Router wifi_api wifi_setApWpsButtonPush $ap_index
    $Router wifi_api wifi_apply
    UTF::Sleep 120

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    if {$idx == 0} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl0_wps_method_enabled"]
    } elseif {$idx == 1} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl1_wps_method_enabled"]
    } elseif {$idx == 2} {
        set nvram_wps_mode_op [extract_config_from_file $nvram_show_file "wl2_wps_method_enabled"]
    }

    UTF::Message LOG "" "NVRAM output is $nvram_wps_mode_op"

    if {[string match -nocase "*pushButton*" $nvram_wps_mode_op]} {
	UTF::Message LOG "" "wl output is matching"
    } else {
#	error "wl output not matching $nvram_wps_mode_op"
    }

}

UTF::Try "wifi_getSSIDName_$radio_intf" {
	set ssid_temp [$Router wifi_api wifi_getSSIDName $ap_index]

	set ssid_out [lindex [split $ssid_temp] end]

	UTF::Message LOG "" "total output string length $ssid_out"

        set ssid_check [lindex [$Router wl -i $if_name ssid] end]

        if {[string match $ssid_out $ssid_check]} {
                UTF::Message LOG "" "SSID Matching strings $ssid_out"
        } else {
                error "SSID NOT Matching output $ssid_out wl check is $ssid_check"
        }
}

UTF::Try "wifi_getSSIDNameStatus_$radio_intf" {
    set ssid_status_op [$Router wifi_api wifi_getSSIDNameStatus $ap_index]

    set ssid_op [$Router wifi_api wifi_getSSIDName $ap_index]

    if {[string match -nocase $ssid_op $ssid_status_op]} {
	UTF::Message LOG "" "SSID Matching"
    } else {
	error "SSID not Matching $ssid_status_op $ssid_op"
    }
}

#INT wifi_getApBeaconType(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApBeaconType_$radio_intf" {
    set ap_bcn_type_temp [$Router wifi_api wifi_getApBeaconType $ap_index]
    set ap_bcn_type_op [lindex [split $ap_bcn_type_temp] end]

    UTF::Sleep 2
    UTF::Message LOG "" "output from wifi_getApBeaconType is $ap_bcn_type_op"

#0x0001  WPA-NONE
##0x0002  WPA-802.1x
##0x0004  WPA-PSK
##0x0040  WPA2-802.1x
##0x0080  WPA2-PSK
##0x1000  1X-SHA256
##0x4000  FT
##0x8000  PSK-SHA256
##0x0000  disabled

    set wl_wpa_auth_op [lindex [$Router wl -i $if_name wpa_auth] end]

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*None*" $ap_bcn_type_op]} {
	if {[string match -nocase "*Disabled*" $wl_wpa_auth_op]} {
            UTF::Message LOG "" "output from wifi_getApBeaconType and wl matching None"
	} else {
	    error "output from wifi_getApBeaconType and wl is not matching None"
	}
    } elseif {[string match -nocase "*Basic*" $ap_bcn_type_op]} {
	if {[string match -nocase "*802*" $wl_wpa_auth_op]} {
            UTF::Message LOG "" "output from wifi_getApBeaconType and wl matching None"
	} else {
	    error "output from wifi_getApBeaconType and wl is not matching None"
	}
    } elseif {[string match -nocase "*WPA*" $ap_bcn_type_op]} {
	if {[string match -nocase "*WPA*" $wl_wpa_auth_op]} {
            UTF::Message LOG "" "output from wifi_getApBeaconType and wl matching None"
	} else {
	    error "output from wifi_getApBeaconType and wl is not matching None"
	}
    } elseif {[string match -nocase "*11i*" $ap_bcn_type_op]} {
	if {[string match -nocase "*802*" $wl_wpa_auth_op]} {
            UTF::Message LOG "" "output from wifi_getApBeaconType and wl matching None"
	} else {
	    error "output from wifi_getApBeaconType and wl is not matching None"
	}
    } elseif {[string match -nocase "*WPAand11i*" $ap_bcn_type_op]} {
	if {[string match -nocase "*WPA*" $wl_wpa_auth_op]} {
            UTF::Message LOG "" "output from wifi_getApBeaconType and wl matching None"
	} else {
	    error "output from wifi_getApBeaconType and wl is not matching None"
	}
    } else {
        error "output from wifi_getApBeaconType and wl is not matching"
    }

}

#INT wifi_getApRadioIndex(INT apIndex, INT *output_int)
UTF::Try "wifi_getApRadioIndex_$radio_intf" {

    set ap_radio_idx_temp [$Router wifi_api wifi_getApRadioIndex $ap_index]
    set ap_radio_idx_op [lindex [split $ap_radio_idx_temp] end]

    UTF::Message LOG "" "output from wifi_getApRadioIndex is $ap_radio_idx_op"

    if {$ap_radio_idx_op == $idx} {
        UTF::Message LOG "" "output from wifi_getApRadioIndex and wl matching"
    } else {
        error "output from wifi_getApRadioIndex and wl is not matching"
    }

}

#INT wifi_setApBridgeInfo(INT apIndex, CHAR *bridgeName, CHAR *IP, CHAR *subnet)
UTF::Try "wifi_setApBridgeInfo_$radio_intf" {
    set brdg_name_cnf [extract_config_from_file $file_name "apbridge_name"]
    set brdg_ip_cnf [extract_config_from_file $file_name "apbridge_ip"]
    set brdg_subnet_cnf [extract_config_from_file $file_name "apbridge_subnet"]

    set wl_op [$Router wifi_api wifi_getApBridgeInfo $ap_index]

    UTF::Message LOG "" "wifi_setApBridgeInfo is about to set $brdg_name_cnf $brdg_ip_cnf $brdg_subnet_cnf"
    $Router wifi_api wifi_setApBridgeInfo $ap_index $brdg_name_cnf $brdg_ip_cnf $brdg_subnet_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getApBridgeInfo $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase "*$brdg_name_cnf*" $wl_op]} {
	if {[string match -nocase "*$brdg_ip_cnf*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching $brdg_name_cnf $brdg_ip_cnf"
	}
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApBeaconType(INT apIndex, CHAR *beaconTypeString)
UTF::Try "wifi_setApBeaconType_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getApBeaconType $ap_index]
    UTF::Message LOG "" "wl actual is $wl_actual"

    set radio_cnf [extract_config_from_file $file_name "beacon_type"]

    UTF::Message LOG "" "wifi_setApBeaconType is about to set $radio_cnf"
    $Router wifi_api wifi_setApBeaconType $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_op [$Router wifi_api wifi_getApBeaconType $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*Basic*" $radio_cnf]} {
	if {[string match -nocase "*None*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching Basic"
	}
    } elseif {[string match -nocase "*$radio_cnf*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

#reset
    $Router wifi_api wifi_setApBeaconType $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}

UTF::Try "wifi_getAssociatedDeviceDetail_$radio_intf" {
	#$Router wifi_api wifi_getAssociatedDeviceDetail $idx

	set assoc_sta_info_output [$Router wifi_api wifi_getAssociatedDeviceDetail $idx]
	set assoc_sta_info [lindex [split $assoc_sta_info_output] end]

	UTF::Message LOG "" "The Associated STA info in $if_name is $assoc_sta_info"

	set assoclist_output [$Router wl -i $if_name assoclist]
	UTF::Message LOG "" "wl assoclist output is $assoclist_output"

	set assoclist_split [split $assoclist_output "\n"]
	UTF::Message LOG "" "wl assoclist split output is $assoclist_split"

	set assoclist_check 0
	foreach j $assoclist_split {
		puts "$j STA from assoclist is $assoclist_check in list"
		set sta_addr [lindex [split $j] end]
		puts "STA from assoclist is $sta_addr"
		set sta_info_output [$Router wl -i $if_name sta_info $sta_addr]
		incr assoclist_check
	}

	UTF::Message LOG "" "The number of Associated STAs from assoclist is $assoclist_check NOT SUPPORTED"
}

#INT wifi_getIndexFromName(CHAR *inputSsidString, INT *output_int)
UTF::Try "wifi_getIndexFromName_$radio_intf" {

    #set name_check [lindex [$Router wl -i $if_name ssid] end]
    set radio_idx_name_temp [$Router wifi_api wifi_getIndexFromName $if_name]
    set radio_idx_name_op [lindex [split $radio_idx_name_temp] end]

    UTF::Message LOG "" "output from wifi_getIndexFromName is $radio_idx_name_op"

    if {$idx == $radio_idx_name_op} {
        UTF::Message LOG "" "output from wifi_getIndexFromName and index matching"
    } else {
	if {$idx == 2} {
	    if {$radio_idx_name_op == 16} {
		UTF::Message LOG "" "output from wifi_getIndexFromName and index matching wl2"
	    } else {
		error "output from wifi_getIndexFromName and wl is not matching index is $idx on wl2 case"
	    }
	} else {
	    error "output from wifi_getIndexFromName and wl is not matching index is $idx"
	}
    }
}

#INT wifi_getRadioWifiTrafficStats(INT radioIndex, wifi_radioTrafficStats_t *output_struct)
#
UTF::Try "wifi_getRadioWifiTrafficStats_$radio_intf" {
    set radio_wifi_traf_stats_op [$Router wifi_api wifi_getRadioWifiTrafficStats $idx]

    set num_chars 2
    UTF::Message LOG "" "output from wifi_getRadioWifiTrafficStats is $radio_wifi_traf_stats_op"

    set wl_bcn_period_temp [$Router wl -i $if_name counters]
    UTF::Message LOG "" "output from wl is $wl_bcn_period_temp"

    set wl_bcn_period_op [extract_wl_counter_output $wl_bcn_period_temp "txnoassoc" $num_chars]

    UTF::Message LOG "" "output from wl counters is $wl_bcn_period_op"

    if {[string match -nocase "*wl_bcn_period_op*" $radio_wifi_traf_stats_op]} {
        UTF::Message LOG "" "output from wifi_getRadioWifiTrafficStats and wl matching"
    }
}

#INT wifi_setSSIDName(INT apIndex, CHAR *ssid_string)
UTF::Try "wifi_setSSIDName_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getSSIDName $ap_index]

    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "wl0_ssid"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "wl1_ssid"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "wl2_ssid"]
    }

    UTF::Message LOG "" "wifi_setSSIDName is about to set $radio_cnf"
    $Router wifi_api wifi_setSSIDName $ap_index $radio_cnf
    wifi_apply_test_suite $Router

    UTF::Sleep 120
    set wl_op [$Router wl -i $if_name ssid]
    UTF::Message LOG "" "wl output is $wl_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {[string match -nocase $radio_cnf $wl_op]} {
        UTF::Message LOG "" "wifi_setSSIDName and wl output is matching"
    } else {
        error "wifi_setSSIDName and wl output is not matching"
    }

    $Router wifi_api wifi_setSSIDName $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 60
}

#INT wifi_pushSsidAdvertisementEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_pushSsidAdvertisementEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "ssid_adv_en"]

    UTF::Message LOG "" "about to set $radio_cnf"
    $Router wifi_api wifi_pushSsidAdvertisementEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 5

    set wl_temp [$Router wifi_api wifi_getApSsidAdvertisementEnable $ap_index]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

}

#INT wifi_setApIsolationEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setApIsolationEnable_$radio_intf" {

        set apiso_mode_temp [$Router wifi_api wifi_getApIsolationEnable $ap_index]

        set apiso_mode_val [lindex [split $apiso_mode_temp] end]

        set iso_value [extract_config_from_file $file_name "ap_isolate"]
        $Router wifi_api wifi_setApIsolationEnable $ap_index $iso_value
        wifi_apply_test_suite $Router
        UTF::Sleep 20

        set apiso_enmode_check [lindex [$Router wifi_api wifi_getApIsolationEnable $ap_index] end]

        if {$iso_value == 1} {
		if {[string match -nocase "*TRUE*" $apiso_enmode_check]} {
			UTF::Message LOG "" "output from wifi_getApIsolationEnable and input matching TRUE"
		} else {
			error "output from wifi_getRadioDfsEnable Disabled and wl is not matching"
		}
	} else {
		if {[string match -nocase "*FALSE*" $apiso_enmode_check]} {
			UTF::Message LOG "" "output from wifi_getApIsolationEnable and input matching FALSE"
		} else {
			error "output from wifi_getRadioDfsEnable Disabled and wl is not matching"
		}
	}

	$Router wifi_api wifi_setApIsolationEnable $ap_index 0
	wifi_apply_test_suite $Router
	UTF::Sleep 20
}

#INT wifi_setApSecurityKeyPassphrase(INT apIndex, CHAR *passPhrase)
UTF::Try "wifi_setApSecurityKeyPassphrase_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "set_keyphrase"]

    UTF::Message LOG "" "wifi_setApSecurityKeyPassphrase is about to set $radio_cnf"
    $Router wifi_api wifi_setApSecurityKeyPassphrase $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    UTF::Message LOG "" "Get PMK/PassPhrase is not allowed in Wifi Driver"
    set wl_temp [$Router wifi_api wifi_getApSecurityKeyPassphrase $ap_index]
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    if {$radio_cnf == $wl_op} {
        UTF::Message LOG "" "wl output is matching"
    }

}

#INT wifi_setRadioAutoBlockAckEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioAutoBlockAckEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "blackack_en"]

    UTF::Message LOG "" "wifi_setRadioAutoBlockAckEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioAutoBlockAckEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

if {0} {
    set wl_op [$Router wl -i $if_name ampdu_ba_wsize]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$wl_op >= 64} {
        UTF::Message LOG "" "wl output is matching"
    } else {
#        error "wl output is not matching"
	 UTF::Message LOG "" "STUB FUNCTION"
    }
}

}

#INT wifi_getApSecurityMFPConfig(INT apIndex, CHAR *output_string)
UTF::Try "wifi_getApSecurityMFPConfig_$radio_intf" {
    set ap_mfp_temp [$Router wifi_api wifi_getApSecurityMFPConfig $ap_index]
    set ap_mfp_op [lindex [split $ap_mfp_temp] end]

    UTF::Message LOG "" "output from wifi_getApSecurityMFPConfig is $ap_mfp_op"

    set wl_mfp_op [$Router wl -i $if_name mfp]

    if {$wl_mfp_op == 0} {
        if {[string match -nocase "*Disabled*" $ap_mfp_op]} {
            UTF::Message LOG "" "Value matching"
        } else {
            error "output from Disabled and wl is not matching"
        }
    } elseif {$wl_mfp_op == 1} {
        if {[string match -nocase "*Optional*" $ap_mfp_op]} {
            UTF::Message LOG "" "Value matching"
        } else {
            error "output from Optional and wl is not matching"
        }
    } elseif {$wl_mfp_op == 2} {
        if {[string match -nocase "*Enabled*" $ap_mfp_op]} {
            UTF::Message LOG "" "Value matching"
        } elseif {[string match -nocase "*Require*" $ap_mfp_op]} {
            UTF::Message LOG "" "Value matching"
        } else {
            error "output from Enabled and wl is not matching"
        }
    } else {
	error "output from Enabled and wl is not matching"
    }
}

#INT wifi_setApSecurityMFPConfig(INT apIndex, CHAR *MfpConfig)
UTF::Try "wifi_setApSecurityMFPConfig_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "mfp"]

    set wl_actual [$Router wifi_api wifi_getApSecurityMFPConfig $ap_index]
    UTF::Message LOG "" "actual value is $wl_actual"

    UTF::Message LOG "" "wifi_setApSecurityMFPConfig is about to set $radio_cnf"
    $Router wifi_api wifi_setApSecurityMFPConfig $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_op [$Router wifi_api wifi_getApSecurityMFPConfig $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*$wl_op*" $radio_cnf]} {
            UTF::Message LOG "" "wl output is matching"
    } else {
#        error "wl output is not matching"
    }

    UTF::Message LOG "" "reset to $wl_actual"
    $Router wifi_api wifi_setApSecurityMFPConfig $ap_index $wl_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2
}

#INT wifi_getRadioDCSSupported(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioDCSSupported_$radio_intf" {
    set ap_dcs_cap_temp [$Router wifi_api wifi_getRadioDCSSupported $idx]
    set ap_dcs_cap_op [lindex [split $ap_dcs_cap_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioDCSSupported is $ap_dcs_cap_temp"

    set wl_bcm_dcs_op [$Router wifi_api wifi_getRadioAutoChannelEnable $idx]

    if {$wl_bcm_dcs_op == 0} {
	if {[string match -nocase "*returned 0*" $ap_dcs_cap_temp]} {
	    UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
	} elseif {[string match -nocase "*dcs=1*" $ap_dcs_cap_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } else {
	    error "output from wifi_getRadioDCSSupported DCS 0 and wl is not matching"
	}
    } elseif {$wl_bcm_dcs_op == 1} {
        if {[string match -nocase "*returned 1*" $ap_dcs_cap_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } elseif {[string match -nocase "*dcs=1*" $ap_dcs_cap_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } else {
            error "output from wifi_getRadioDCSSupported DCS 1 and wl is not matching"
        }
    }
}

#INT wifi_getRadioDCSEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioDCSEnable_$radio_intf" {
    set ap_dcs_en_temp [$Router wifi_api wifi_getRadioDCSEnable $idx]
    set ap_dcs_en_op [lindex [split $ap_dcs_en_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioDCSEnable is $ap_dcs_en_op"

    set wl_bcm_dcs_op [$Router wifi_api wifi_getRadioAutoChannelEnable $idx]

    if {$wl_bcm_dcs_op == 0} {
        if {[string match -nocase "*returned 0*" $ap_dcs_en_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } elseif {[string match -nocase "*dcs=0*" $ap_dcs_en_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } else {
            error "output from wifi_getRadioDCSSupported DCS 0 and wl is not matching"
        }
    } elseif {$wl_bcm_dcs_op == 1} {
        if {[string match -nocase "*returned 1*" $ap_dcs_en_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } elseif {[string match -nocase "*dcs=1*" $ap_dcs_en_temp]} {
            UTF::Message LOG "" "output from wifi_getRadioDCSSupported and wl matching"
        } else {
            error "output from wifi_getRadioDCSSupported DCS 1 and wl is not matching"
        }
    }
}

#INT wifi_getRadioDCSScanTime(INT radioIndex, INT *output_interval_seconds, INT *output_dwell_milliseconds)
UTF::Try "wifi_getRadioDCSScanTime_$radio_intf" {

    set wl_temp [$Router wifi_api wifi_getRadioDCSScanTime $idx]
    UTF::Sleep 2
    set wl_op [lindex [split $wl_temp] end]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$wl_op == 900} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching $wl_op"
    }
}

#INT wifi_setRadioDCSScanTime(INT radioIndex, INT interval_seconds, INT dwell_milliseconds)
UTF::Try "wifi_setRadioDCSScanTime_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "dcs_scan"]
    set radio_cnf_1 [extract_config_from_file $file_name "dcs_dwell"]

    set dcs_scan_temp [$Router wifi_api wifi_getRadioDCSScanTime $idx]
    set dcs_scan_actual [lindex [split $dcs_scan_temp] 0]
    set dcs_dwell_actual [lindex [split $dcs_scan_temp] end]

	if {$idx == 2} {
	    $Router wl -i $if_name status
	    $Router wl -i $if_name bss
	}

    UTF::Message LOG "" "wifi_setRadioDCSScanTime is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDCSScanTime $idx $radio_cnf $radio_cnf_1
    wifi_apply_test_suite $Router
    UTF::Sleep 10

    set wl_temp [$Router wifi_api wifi_getRadioDCSScanTime $idx]
    set wl_op [lindex [split $wl_temp] 0]
    UTF::Message LOG "" "wl output is $wl_op"

	if {$idx == 2} {
	    $Router wl -i $if_name status
	    $Router wl -i $if_name bss
	}

    if {[string match -nocase "*$radio_cnf*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
        error "wl output is not matching"
    }

    UTF::Message LOG "" "wifi_setRadioDCSScanTime is about to reset $dcs_scan_actual $dcs_dwell_actual"
    $Router wifi_api wifi_setRadioDCSScanTime $idx $dcs_scan_actual $dcs_dwell_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 5
}

#INT wifi_getRadioDfsSupport(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioDfsSupport_$radio_intf" {
    set ap_dfs_temp [$Router wifi_api wifi_getRadioDfsSupport $idx]

    UTF::Message LOG "" "output from wifi_getRadioDfsSupport is $ap_dfs_temp"

    set ap_dfs_en_temp [$Router wifi_api wifi_getRadioDfsEnable $idx]

    if {$idx == 1} {
	if {[string match -nocase "*Not supported*" $ap_dfs_temp]} {
	    if {[string match -nocase "*Disabled*" $ap_dfs_en_temp]} {
		UTF::Message LOG "" "output from wifi_getRadioDfsSupport and wl matching"
	    } else {
		error "output from wifi_getRadioDfsSupport and wifi_getRadioDfsEnable not matching"
	    }
	} else {
	    if {[string match -nocase "*Enabled*" $ap_dfs_en_temp]} {
		UTF::Message LOG "" "output from wifi_getRadioDfsSupport and wl matching"
	    } else {
		error "output from wifi_getRadioDfsSupport and wifi_getRadioDfsEnable not matching"
	    }
	}
    }
}

#INT wifi_getRadioDfsEnable(INT radioIndex, BOOL *output_bool)
UTF::Try "wifi_getRadioDfsEnable_$radio_intf" {
    set ap_dfs_en_temp [$Router wifi_api wifi_getRadioDfsEnable $idx]
    set ap_dfs_en_op [lindex [split $ap_dfs_en_temp] end]

    UTF::Message LOG "" "output from wifi_getRadioDfsEnable is $ap_dfs_en_op"

    #set wl_radar_op [$Router wifi_api wifi_getRadioIEEE80211hEnabled $idx]
    set wl_radar_op [$Router wl -i $if_name radar]

    if {$idx == 1} {
    if {[string match -nocase "*Disable*" $ap_dfs_en_op]} {
	if {[string match -nocase "*0*" $wl_radar_op]} {
            UTF::Message LOG "" "output from wifi_getRadioDfsEnable and wl matching"
	} elseif {[string match -nocase "*FALSE*" $wl_radar_op]} {
            UTF::Message LOG "" "output from wifi_getRadioDfsEnable and wl matching"
        } else {
	    error "output from wifi_getRadioDfsEnable Disabled and wl is not matching"
	}
    } else {
	if {[string match -nocase "*1*" $wl_radar_op]} {
            UTF::Message LOG "" "output from wifi_getRadioDfsEnable and wl matching"
	} elseif {[string match -nocase "*TRUE*" $wl_radar_op]} {
            UTF::Message LOG "" "output from wifi_getRadioDfsEnable and wl matching"
        } else {
	    error "output from wifi_getRadioDfsEnable Enabled and wl is not matching"
	}
    }
    }
}

#INT wifi_setRadioDfsEnable(INT radioIndex, BOOL enabled)
UTF::Try "wifi_setRadioDfsEnable_$radio_intf" {

if {$idx == 1} {
    set radio_cnf [extract_config_from_file $file_name "radar"]

#US (US/791) UNITED STATES

    set wl_actual [$Router wl -i $if_name country]

    set first_index [expr 1 + [string first "(" $wl_actual]]
    set last_index [expr [string first ")" $wl_actual] - 1]

    UTF::Message LOG "" "first index $first_index last index $last_index"
    set cntry_len [expr $last_index - $first_index]
    UTF::Message LOG "" "total length $cntry_len"

    set country_actual [string range $wl_actual $first_index $last_index]
    UTF::Message LOG "" "actual country is $country_actual"

    set wl_ssid_op [$Router wifi_api wifi_getSSIDName $ap_index]
    set wl_down_op [$Router wl -i $if_name down]
    UTF::Sleep 2
    set wl_op [$Router wl -i $if_name country JP]
    UTF::Sleep 2
    UTF::Message LOG "" "wifi_setRadioDfsEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDfsEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set wl_op [$Router wifi_api wifi_getRadioDfsEnable $idx]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$idx == 1} {
    if {$radio_cnf == 1} {
	if {[string match -nocase "*Enabled*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching enabled"
	}
    } else {
	if {[string match -nocase "*Disabled*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching"
	} else {
	    error "wl output is not matching enabled"
	}
    }
    }

    #reset
    set wl_up_op [$Router wl -i $if_name down]
    UTF::Sleep 5
    set wl_op [$Router wl -i $if_name country $country_actual]
    UTF::Sleep 2
    set wl_up_op [$Router wl -i $if_name up]
    UTF::Sleep 5
    set en_rad 1
    $Router wifi_api wifi_setRadioEnable $idx $en_rad
    UTF::Sleep 5
    set wl_ssid [$Router wl -i $if_name ssid $wl_ssid_op]
    UTF::Sleep 5
}
}

#INT wifi_getNeighboringWiFiDiagnosticResult2(INT radioIndex, wifi_neighbor_ap2_t **neighbor_ap_array, UINT *output_array_size)
UTF::Try "wifi_getNeighboringWiFiDiagnosticResult2_$radio_intf" {
    set ap_assoc_diag2_op [$Router wifi_api wifi_getNeighboringWiFiDiagnosticResult2 $idx]

    UTF::Message LOG "" "output from wifi_getNeighboringWiFiDiagnosticResult2 is $ap_assoc_diag2_op"

    if {[string match -nocase "*Total Scan Results:*" $ap_assoc_diag2_op]} {
        UTF::Message LOG "" "output from wifi_getNeighboringWiFiDiagnosticResult2 and wl matching"
    } else {
        error "output from wifi_getNeighboringWiFiDiagnosticResult2 and wl is not matching"
    }
}

UTF::Try "wifi_startNeighborScan_$radio_intf" {
#<AP Index> <Scan Mode> <Dwell Time>             <Channel Number> <list of channels>
        if {$idx == 0} {
		$Router wifi_api wifi_startNeighborScan 0 0 -1 1 11
        } elseif {$idx == 1} {
		$Router wifi_api wifi_startNeighborScan 1 0 -1 2 44 149
        } elseif {$idx == 2} {
                set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
                $Router wifi_api wifi_startNeighborScan $to_exec 0 -1 1 175
        } else {
		error "Not a valid radio index"
	}
}

#INT wifi_getApAssociatedDeviceDiagnosticResult3(INT apIndex, wifi_associated_dev3_t **associated_dev_array, UINT *output_array_size)
UTF::Try "wifi_getApAssociatedDeviceDiagnosticResult3_$radio_intf" {
    set ap_assoc_diag3_op [$Router wifi_api wifi_getApAssociatedDeviceDiagnosticResult3 $ap_index]

    UTF::Message LOG "" "output from wifi_getApAssociatedDeviceDiagnosticResult3 is $ap_assoc_diag3_op"

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    $Router wl -i $if_name status
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_list {
        UTF::Message LOG "" "$j STA from assoclist is $no_of_assoc_sta in list"
	set check_sta [lindex [split $j] end]
	UTF::Message LOG "" "STA to search is $check_sta"
	if {[string match -nocase "*$check_sta*" $ap_assoc_diag3_op]} {

	    UTF::Message LOG "" "FOUND $wl_assoclist_list in list"
	    incr found_sta
	}
	incr no_of_assoc_sta
    }

    if {$no_of_assoc_sta == $found_sta} {
	UTF::Message LOG "" "STA are matching $no_of_assoc_sta $found_sta"
    } else {
	error "NO of STA are mismatching $no_of_assoc_sta $found_sta"
    }
}

#INT wifi_kickApAssociatedDevice(INT apIndex, CHAR *client_mac)
UTF::Try "wifi_kickApAssociatedDevice_$radio_intf" {
    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "kick_associated_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "kick_associated_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "kick_associated_6g"]
    } else {
        error "Not a valid radio index"
    }
    set assoclist_temp [$Router wl -i $if_name assoclist]
    if {[string match -nocase "*$radio_cnf*" $assoclist_temp]} {
	set wl_op [$Router wl -i $if_name sta_info $radio_cnf]
	UTF::Message LOG "" "wl output is $wl_op"

	if {[string match -nocase "*$radio_cnf*" $wl_op]} {

	    UTF::Message LOG "" "wifi_kickApAssociatedDevice is about to kick $radio_cnf"
	    $Router wifi_api wifi_kickApAssociatedDevice $ap_index $radio_cnf
	    $Router wifi_api wifi_apply
	    UTF::Sleep 10

	    set wl_assoclist_temp [$Router wifi_api wifi_getApAssociatedDeviceDiagnosticResult3 $ap_index]

	    if {[string match -nocase "*$radio_cnf*" $wl_assoclist_temp]} {
	    UTF::Message LOG "" "output is not matching"
	    if {[string match -nocase "*in network*" $wl_op]} {
		UTF::Message LOG "" "output is matching"
	    } else {
		error "wl output is not matching"
	    }
	    } else {
		UTF::Message LOG "" "wl output confirms the STA is kickedout"
	    }
            UTF::Sleep 20
        }
    } else {
	UTF::Message LOG "" "STA is not in assoclist so cannot kick"
    }
}

#INT wifi_kickApAclAssociatedDevices(INT apIndex, CHAR *client_mac)
UTF::Try "wifi_kickApAclAssociatedDevices_$radio_intf" {
    if {$idx == 0} {
        set radio_cnf [extract_config_from_file $file_name "kick_acl_associated_2g"]
    } elseif {$idx == 1} {
        set radio_cnf [extract_config_from_file $file_name "kick_acl_associated_5g"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $file_name "kick_acl_associated_6g"]
    }

    set ap_max_assoc_temp [$Router wifi_api wifi_getAllAssociatedDeviceDetail $ap_index]

    if {[string match -nocase "*Total_STA:0*" $ap_max_assoc_temp]} {
         UTF::Message LOG "" "No associated STA in list"
    } else {
#	set wl_temp [$Router wl -i $if_name assoclist]
	set wl_op [$Router wl -i $if_name sta_info $radio_cnf]
#	set wl_op [lindex [split $wl_temp] end]
	UTF::Message LOG "" "wl output is $wl_op"

	if {[string match -nocase "*$radio_cnf*" $wl_op]} {
	    UTF::Message LOG "" "wl output is matching"
	    UTF::Message LOG "" "wifi_kickApAclAssociatedDevices is about to set $radio_cnf"
	    $Router wifi_api wifi_kickApAclAssociatedDevices $ap_index $radio_cnf
	    UTF::Sleep 20

	    set ap_max_assoc_temp [$Router wifi_api wifi_getAllAssociatedDeviceDetail $ap_index]
	    UTF::Sleep 5

	    if {[string match -nocase "*$radio_cnf*" $ap_max_assoc_temp]} {
		UTF::Message LOG "" "STA not removed from list check in network time"

		set wl_op [$Router wl -i $if_name sta_info $radio_cnf]
		if {[string match -nocase "*in network*" $wl_op]} {
		    UTF::Message LOG "" "output is matching"
		} else {
#		error "wl output is not matching"
		    UTF::Message LOG "" "FAIL STA still exists"
		    error "wl output is not matching"
		}
	    } else {
		UTF::Message LOG "" "STA removed from list"
	    }
	} else {
	    UTF::Message LOG "" "wl output does not have STA in associated state"
	}
    }
}

#END2G5G6G
}

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
        } elseif {$idx == 2} {
                set radio_intf "6g"
        }

	set to_exec [convert_radio_idx_to_ap_idx $Router $idx]
	set radioName [$Router wifi_api wifi_getRadioIfName $idx]

        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

	set ap_index [convert_radio_idx_to_ap_idx $Router $idx]

#deleteAp
UTF::Try "wifi_deleteAp_$radio_intf" {
#       apindex 0/1 in group 0
    if {$idx == 0} {
	set ap_idx [extract_config_from_file $file_name "create_ap_ap_idx_2g"]
    } elseif {$idx == 1} {
	set ap_idx [extract_config_from_file $file_name "create_ap_ap_idx_5g"]
    } elseif {$idx == 2} {
	set ap_idx [extract_config_from_file $file_name "create_ap_ap_idx_6g"]
    }

    set ap_status_temp [$Router wl -i $ap_idx status]

    if {[string match -nocase "*BROAD*" $ap_status_temp]} {
	UTF::Message LOG "" "AP does exist to delete"
	set bssid_temp [$Router wifi_api wifi_getIndexFromName $ap_idx]
	set bssid_idx [lindex [split $bssid_temp] end]
        $Router wifi_api wifi_deleteAp $bssid_idx
	wifi_apply_test_suite $Router
	UTF::Sleep 20

        set wl_deleteap_check [$Router wl -i $ap_idx status]
        if {[string match -nocase "*BSSID:*00:00*" $wl_deleteap_check]} {
                UTF::Message LOG "" "wl is deleted wifi_deleteAp"
        } else {
                error "wl is not deleted in wifi_deleteAp index $idx is STILL UP"
        }
    } else {
	UTF::Message LOG "" "AP does not exist to delete"
    }
}

#INT wifi_setApEnable(INT apIndex, BOOL enable)
UTF::Try "wifi_setApEnable_$radio_intf" {

    set wl_actual [$Router wifi_api wifi_getApEnable $ap_index]

    if {[string match -nocase "*FALSE*" $wl_actual]} {
        set radio_cnf 1
    } else {
        set radio_cnf 0
    }

    UTF::Message LOG "" "wifi_setApEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setApEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 30

    set wl_op [$Router wifi_api wifi_getApEnable $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {$radio_cnf == 1} {
	if {[string match -nocase "*TRUE*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching TRUE"
	} else {
	    error "wl output is not matching TRUE"
	}
    } else {
	if {[string match -nocase "*FALSE*" $wl_op]} {
            UTF::Message LOG "" "wl output is matching FALSE"
	} else {
	    error "wl output is not matching FALSE"
	}
    }

    #Need to reset to TRUE to make sure the AP is enabled
    set radio_cnf 1

    UTF::Message LOG "" "wifi_setApEnable is about to reset"
    $Router wifi_api wifi_setApEnable $ap_index $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 30
}

UTF::Try "wifi_createAp_$radio_intf" {
#       apindex 0/1 in group 0
#       wifi_api wifi_createAp <RadioIndex> <AP Index> <E-SSID> <Hide-SSID>
#       wifi_api wifi_createAp 2 0 test-2g-id2 0

    set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

    if {$idx == 0} {
	set ap_idx [extract_config_from_file $file_name "create_ap_ap_idx_2g"]
	set radio_idx [extract_config_from_file $file_name "create_ap_radio_idx_2g"]
	set ap_essid [extract_config_from_file $file_name "create_ap_essid_2g"]
	set ap_hide_ssid [extract_config_from_file $file_name "create_ap_hide_ssid_2g"]
    } elseif {$idx == 1} {
        set ap_idx [extract_config_from_file $file_name "create_ap_ap_idx_5g"]
        set radio_idx [extract_config_from_file $file_name "create_ap_rad_idx_5g"]
        set ap_essid [extract_config_from_file $file_name "create_ap_essid_5g"]
        set ap_hide_ssid [extract_config_from_file $file_name "create_ap_hide_ssid_5g"]
    } elseif {$to_exec == 16} {
	set ap_idx [extract_config_from_file $file_name "create_ap_ap_idx_6g"]
	set radio_idx [extract_config_from_file $file_name "create_ap_radio_idx_6g"]
	set ap_essid [extract_config_from_file $file_name "create_ap_essid_6g"]
	set ap_hide_ssid [extract_config_from_file $file_name "create_ap_hide_ssid_6g"]
    } else {
	error "Not a valid radio index"
    }

    set ap_if_temp [$Router wifi_api wifi_getIndexFromName $ap_idx]
    set ap_if_idx [lindex [split $ap_if_temp] end]
    $Router wifi_api wifi_createAp $ap_if_idx $idx $ap_essid $ap_hide_ssid
    wifi_apply_test_suite $Router
    UTF::Sleep 60

    set wl_create_ssid_check [$Router wl -i $ap_idx ssid]
    if {[string match -nocase "*$ap_essid*" $wl_create_ssid_check]} {
	UTF::Message LOG "" "SSID Matching wifi_createAp"
    } else {
	error "SSID NOT Matching output with wifi_createAp $wl_create_ssid_check"
    }
}

UTF::Try "wifi_disableApEncryption_$radio_intf" {
        set disable_ap_enc_temp [$Router wifi_api wifi_disableApEncryption $idx]
	wifi_apply_test_suite $Router
	UTF::Sleep 60

        set disable_ap_enc_op [lindex [split $disable_ap_enc_temp] end]

        UTF::Message LOG "" "total output string length $disable_ap_enc_op"

        set wpa_auth_op [lindex [$Router wl -i $if_name wpa_auth] end]

        if {[string match "Disabled" $wpa_auth_op]} {
                UTF::Message LOG "" "Encryption is reset to Disabled"
        } else {
                error "Encryption is NOT reset to NULL $wpa_auth_op"
        }
}

#INT wifi_delApAclDevice(INT apIndex, CHAR *MAC)
UTF::Try "wifi_delApAclDevice_$radio_intf" {

    set wl_assoclist_temp [$Router wl -i $if_name assoclist]
    set wl_assoclist_list [split $wl_assoclist_temp "\n"]

    UTF::Message LOG "" "output from wl assoclist is $wl_assoclist_list"

    if {$idx == 0} {
	set acl_MAC [extract_config_from_file $file_name "acl_MAC_2g"]
    } elseif {$idx == 1} {
        set acl_MAC [extract_config_from_file $file_name "acl_MAC_5g"]
    } elseif {$idx == 2} {
	set acl_MAC [extract_config_from_file $file_name "acl_MAC_6g"]
    } else {
	error "Not a valid radio index"
    }

    set no_of_assoc_sta 0
    set found_sta 0

    foreach j $wl_assoclist_temp {
        puts "$j STA from assoclist is $no_of_assoc_sta in list"
        if {[string match -nocase "*$acl_MAC*" $wl_assoclist_temp]} {

            set found_sta 1
            set get_rssi_op [$Router wifi_api wifi_delApAclDevice $idx $acl_MAC]

        } else {
            incr no_of_assoc_sta
        }
    }
    if {$found_sta == 0 && $no_of_assoc_sta == 0} {
	UTF::Message LOG "" "NO STA in associated list"
    } else {
	if {$found_sta == 1} {
		UTF::Message LOG "" "STA removed from list"
	} else {
        	error "no STA with $acl_MAC is in associated list"
	}
    }

}

#INT wifi_setApSecurityReset(INT apIndex)
UTF::Try "wifi_setApSecurityReset_$radio_intf" {

    set api_actual [$Router wifi_api wifi_getApSecurityModeEnabled $ap_index]
    UTF::Sleep 2

    set commit_en 1
    set restart_en 0

    $Router wifi_api wifi_setApSecurityReset $ap_index $commit_en $restart_en
    UTF::Sleep 60
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    intf_down_up_restart $Router $if_name $idx

    set wl_op [$Router wifi_api wifi_getApSecurityModeEnabled $ap_index]
    UTF::Message LOG "" "wl output is $wl_op"

    if {[string match -nocase "*None*" $wl_op]} {
        UTF::Message LOG "" "wl output is matching"
    } else {
	if {$ap_index == 16} {
		if {[string match -nocase "*WPA3*" $wl_op]} {
			UTF::Message LOG "" "wl output is matching WPA3"
		} else {
			error "wl output is not matching WPA3"
		}
	} else {
	        error "wl output is not matching"
	}
    }

	if {$idx == 1} {
	    $Router wl -i $if_name status
	    $Router wl -i  wl1.1 status
	}
    $Router wifi_api wifi_setApSecurityModeEnabled $ap_index $api_actual
    wifi_apply_test_suite $Router
    UTF::Sleep 2
    intf_down_up_restart $Router $if_name $idx
}

UTF::Try "wifi_factoryResetAP_$radio_intf" {
#	apindex 0/1 in group 0

	set to_exec [convert_radio_idx_to_ap_idx $Router $idx]

	$Router wifi_api wifi_factoryResetAP $to_exec 1 0
	UTF::Sleep 2
	wifi_apply_test_suite $Router
	UTF::Sleep 2

	intf_down_up_restart $Router $if_name $idx

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

	set ssid_check [lindex [$Router wl -i $if_name ssid] end]

	set def_ssid [extract_config_from_file $file_name "default_ssid"]

	if {[string match -nocase $def_ssid $ssid_check]} {
		UTF::Message LOG "" "SSID Matching strings in wifi_factoryResetAP $ssid_check"
	} else {
		$Router wl -i $if_name status
		error "SSID NOT Matching output in wifi_factoryResetAP $ssid_check"
	}
}


UTF::Try "wifi_factoryResetRadio_$radio_intf" {
#	apindex 0/1 in group 0
    $Router wifi_api wifi_factoryResetRadio $idx 1 0
    UTF::Sleep 60

    wifi_apply_test_suite $Router
    UTF::Sleep 2
	intf_down_up_restart $Router $if_name $idx

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    if {$idx == 0} {
	set radio_cnf [extract_config_from_file $nvram_show_file "wl0_channel"]
    } elseif {$idx == 1} {
	set radio_cnf [extract_config_from_file $nvram_show_file "wl1_channel"]
    } elseif {$idx == 2} {
        set radio_cnf [extract_config_from_file $nvram_show_file "wl2_channel"]
    }
    UTF::Message LOG "" "extracted channel value from default file is $radio_cnf"

    if {$radio_cnf == 0} {
	UTF::Message LOG "" "Channel value matches"
    } else {
	error "Channel value does not match $radio_cnf"
    }

}

#INT wifi_setRadioDCSEnable(INT radioIndex, BOOL enable)
UTF::Try "wifi_setRadioDCSEnable_$radio_intf" {
    set radio_cnf [extract_config_from_file $file_name "bcm_dcs"]

    UTF::Message LOG "" "wifi_setRadioDCSEnable is about to set $radio_cnf"
    $Router wifi_api wifi_setRadioDCSEnable $idx $radio_cnf
    wifi_apply_test_suite $Router
    UTF::Sleep 20

   set get_dcs [$Router wifi_api wifi_getRadioDCSEnable $idx]

   if {$radio_cnf == 0} {
	if {[string match -nocase "*returned 0*" $get_dcs]} {
	    UTF::Message LOG "" "wl output is matching 0"
	} elseif {[string match -nocase "*dcs=0*" $get_dcs]} {
            UTF::Message LOG "" "wl output is matching 0"
        } else {
            error "wl output is not matching cnf 0"
	}
    } else {
	if {[string match -nocase "*returned 1*" $get_dcs]} {
	    UTF::Message LOG "" "wl output is matching 1"
	} elseif {[string match -nocase "*dcs=1*" $get_dcs]} {
            UTF::Message LOG "" "wl output is matching 1"
        } else {
            error "wl output is not matching cnf 0"
	}
    }
}

}

UTF::Try "wifi_factoryResetRadios" {
    $Router wifi_api wifi_factoryResetRadios 1 0
    UTF::Sleep 60
    wifi_apply_test_suite $Router
    UTF::Sleep 2

    set radioName_0 [$Router wifi_api wifi_getRadioIfName 0]
    set str_len [string length $radioName_0]
    set if_name_0 [string range $radioName_0 $str_len-3 $str_len]
    intf_down_up_restart $Router $if_name_0 0

    set radio_intf_1 "5g"
    set radioName_1 [$Router wifi_api wifi_getRadioIfName 1]
    set str_len [string length $radioName_1]
    set if_name_1 [string range $radioName_1 $str_len-3 $str_len]
    intf_down_up_restart $Router $if_name_1 1

if {$num_radios == 3} {
    set radio_intf_2 "6g"
    set radioName_2 [$Router wifi_api wifi_getRadioIfName 2]
    set str_len [string length $radioName_2]
    set if_name_2 [string range $radioName_2 $str_len-3 $str_len]
}

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

    UTF::Sleep 2

    set radio_cnf_0 [extract_config_from_file $nvram_show_file "wl0_channel"]
    set radio_cnf_1 [extract_config_from_file $nvram_show_file "wl1_channel"]
    if {$num_radios == 3} {
	set radio_cnf_2 [extract_config_from_file $nvram_show_file "wl2_channel"]
    }

    if {$num_radios == 3} {
	if {$radio_cnf_0 == 0 && $radio_cnf_1 == 0 && $radio_cnf_2 == 0} {
	    UTF::Message LOG "" "Channel value is reset for 3 radio"
	} else {
	    error "Channel value does not match $radio_cnf_0 $radio_cnf_1 for 3 radio"
	}
    } else {
	if {$radio_cnf_0 == 0 && $radio_cnf_1 == 0} {
	    UTF::Message LOG "" "Channel value is reset"
	} else {
	    error "Channel value does not match $radio_cnf_0 $radio_cnf_1"
	}
    }
}

UTF::Try "wifi_factoryReset" {
	set commit_en 1
	set restart_en 0
        $Router wifi_api wifi_factoryReset $restart_en
	wifi_apply_test_suite $Router
	UTF::Sleep 2

	set radio_intf_0 "2g"

	set radioName_0 [$Router wifi_api wifi_getRadioIfName 0]
	set str_len [string length $radioName_0]
	set if_name_0 [string range $radioName_0 $str_len-3 $str_len]
	intf_down_up_restart $Router $if_name_0 0

	set radio_intf_1 "5g"
	set radioName_1 [$Router wifi_api wifi_getRadioIfName 1]
	set str_len [string length $radioName_1]
	set if_name_1 [string range $radioName_1 $str_len-3 $str_len]
	intf_down_up_restart $Router $if_name_1 1

if {$num_radios == 3} {
	set radio_intf_2 "6g"
	set radioName_2 [$Router wifi_api wifi_getRadioIfName 2]
	set str_len [string length $radioName_2]
	set if_name_2 [string range $radioName_2 $str_len-3 $str_len]
}

    set path_info [exec pwd]

    UTF::Message LOG "" "path info is $path_info"
    set file_name "$path_info/Test/hal_set_config"
    UTF::Message LOG "" "File name is $file_name"
    set nvram_show [$Router nvram show]

    set nvram_show_file "$path_info/nvram_show.txt"
    set fp [open "nvram_show.txt" w+]
    puts $fp $nvram_show
    close $fp

        set ssid_check_0 [lindex [$Router wl -i $if_name_0 ssid] end]
        set ssid_check_1 [lindex [$Router wl -i $if_name_1 ssid] end]

        if {[string match -nocase "BROADCOM" $ssid_check_0]} {
		$Router wl -i $if_name_0 status
                UTF::Message LOG "" "SSID Matching strings in wifi_factoryReset $ssid_check_0"
        } else {
		$Router wl -i $if_name_0 status
                error "SSID NOT Matching output in wifi_factoryReset $ssid_check_0"
        }
        set ssid_check_1 [lindex [$Router wl -i $if_name_1 ssid] end]

        if {[string match -nocase "BROADCOM" $ssid_check_1]} {
		$Router wl -i $if_name_1 status
                UTF::Message LOG "" "SSID Matching strings in wifi_factoryReset $ssid_check_1"
        } else {
		$Router wl -i $if_name_1 status
                error "SSID NOT Matching output in wifi_factoryReset $ssid_check_1"
        }

if {$num_radios == 3} {
	set ssid_check_2 [lindex [$Router wl -i $if_name_2 ssid] end]
        if {[string match -nocase "BROADCOM" $ssid_check_2]} {
		$Router wl -i $if_name_2 status
                UTF::Message LOG "" "SSID Matching strings in wifi_factoryReset $ssid_check_1"
        } else {
		$Router wl -i $if_name_2 status
                error "SSID NOT Matching output in wifi_factoryReset $ssid_check_1"
        }
}

}

    for {set idx 0} {$idx < $num_radios} {incr idx} {

        if {$idx == 0} {
                set radio_intf "2g"
        } elseif {$idx == 1} {
                set radio_intf "5g"
        } elseif {$idx == 2} {
                set radio_intf "6g"
        }

        set radioName [$Router wifi_api wifi_getRadioIfName $idx]
        set str_len [string length $radioName]
        set if_name [string range $radioName $str_len-3 $str_len]

UTF::Try "wifi_initRadio_$radio_intf" {

        $Router wifi_api wifi_initRadio $idx
	wifi_apply_test_suite $Router
        UTF::Sleep 120
	#Check SSID

        set ssid_status_temp [$Router wifi_api wifi_getSSIDName $idx]

        set ssid_status_out [lindex [split $ssid_status_temp] end]

        UTF::Message LOG "" "total output string length $ssid_status_out"

        set ssid_init_check [lindex [$Router wl -i $if_name ssid] end]

        if {[string match $ssid_status_out $ssid_init_check]} {
		$Router wl -i $if_name status
                UTF::Message LOG "" "SSID Matching strings in wifi_initRadio $ssid_status_out"
        } else {
		$Router wl -i $if_name status
                #error "SSID NOT Matching output in wifi_initRadio $ssid_status_out"
		UTF::Message LOG "" "STUB FUNCTION"
        }

}

    }


}
# Proc setup_summaries initialize summary web pages and related
# global variables.
#====================================================================
proc setup_summaries {AP STA titleap } {

    # Get testrig name


}

#============== proc update_summaries ===============================
# # Proc for updating summary web pages
#====================================================================

#============== Main hal_commands test ===============================
UTF::Test hal_commands {args} {
     UTF::Getopts "$::hal_commands_getopts" "$::hal_commands_help"
     set ::loop1_counter 0

    # If necessary, override the config file log directory setting.
    if {$(logdir) != ""} {
        set UTF::SummaryDir $(logdir)
        UTF::Message INFO "" "Using logdir: $UTF::SummaryDir"
    }

    # noinit implies nosetup. nosetup is for this script only.
    # noinit is passed to aci1fidha.test & has broader impact than nosetup.

    set (sta) [string trim $(sta)]
    if {$(sta) == ""} {
        error "ERROR: Must specify at least one sta"
    }

    set (suite) [string trim $(suite)]
    if {$(suite) == ""} {
	error "ERROR: Must specify at least suite"
    }
    # Get build name for use in report email subject.
    # When multiple STA are tested, they USUALLY use the same build.
    if {$(titleap)} {
       set item $Router
    } else {
       set item [lindex $(sta) 0]
    }

    if {[set build [$item cget -image]] eq ""} {
        set build [$item cget -tag]
    }
    if {$build eq "NIGHTLY"} {
        set build "TOT"
    }

    # (branch) is used for comparison over time. For private builds
    # this should be specified explicitly so the tests know which
    # branch to test. (branch) defaults to auto.
    if {$(branch) eq ""} {
        if {[regexp {/} $build]} {
            error "Unable to determine branch name from build.  Please specify -branch"
        }
        set (branch) $build
    }

    # Truncate branch name for performance keys
    regsub {_.*} $(branch) {} (branch)

    # aci1fidha.test needs branch name when it calls get_stream.
    if {$(branch) != "" && $(branch) != "auto"} {
        append ::branch_list " $(branch)"
    }
    if {![info exists ::branch_list]} {
        set ::branch_list $build
    }

   set Router [lindex $(ap) 0]
   set STA [lindex $(sta) 0]

    # Compact build list for title
    set build [UTF::BuildTitle $(sta)]

     if {$(title) eq ""} {
	if {[$STA hostis WinDHD Cygwin]} {
	    set (title) [$STA host whatami]
	} elseif {[$STA hostis LMAC DHD]} {
	    set (title) "Linux Dongle"
	} else {
	    set (title) [$STA hostis]
	}
	set today [join [clock format [clock seconds] -format "%Y %N %e"] .]
        if {$(stadate) ne ""} {
	    set stadate $(stadate)
	    foreach STA $(sta) {
		$STA configure -date $(stadate)
	    }
	} else {
	    set stadate $today
	}

	if {[regexp {(\d+sd)} $Router - c]} {
	    append (title) " with $c AP"
	}
    }

    set TITLE "UTF $(title) ($build)"
    UTF::Message INFO "" $TITLE

    # $build is used in the title.  For private builds this will
    # indicate special images.

    # (branch) is used for comparison over time.  For private builds
    # this should be specified explicitly so the tests know which
    # branch to test.

    if {$(branch) eq ""} {
	if {[regexp {/} $build]} {
	    error "Unable to determine branch name from build.  Please specify -branch"
	}
	set (branch) $build
    }
    unset build

    # Truncate build name for performance keys
    regsub {_.*} $(branch) {} (branch)


    UTF::WrapSummary $UTF::SummaryDir $TITLE "" $(email) {
	set ::UTF::Perfcache [file join $UTF::SummaryDir perfcache]

	if {!$(nosetuptestbed) && [info exists ::UTF::SetupTestBed]} {
	    UTF::Try "Setup testbed" {
		eval $::UTF::SetupTestBed
	    }
	}
	if {!$(nosetuptestbed)} {
	    UTF::Try "Setup testbed" {
		UTF::SetupTestBed
	    }
	}
	#-----------------------------------------------------------------------------------------
	# Updated the following modules : added by am941966 ; date 7/30/2021
	# Findimages STA
	# Findimages AP
	# STA load
	# Apload
	# AP restore defaults
	# STA unload
	#-----------------------------------STA findimages-----------------------------------------
	set today [join [clock format [clock seconds] -format "%Y %N %e"] .]
	if {$(stadate) ne ""} {
		set stadate $(stadate)
		foreach STA $(sta) {
		$STA configure -date $(stadate)
		}
	} else {
		set stadate $today
	}
	#-----------------------------------AP findimages- and load-----------------------
	if {!$(noapload)} {
	    UTF::Try "[$Router cget -name]: Load Image" {
		if {$(norestore) || ![$Router wlconf_by_nvram]} {
		    $Router load
		} else {
		    $Router load -erase
		}
	    }
	    # Check secondary driver and update report header
	    set build [$Router cmreleaseinfo]
	    UTF::ReportDriver $Router $build

	}
	#---------------------------- AP restore defaults----------------------------------
	if {!$(norestore)} {
	    UTF::Try "$Router: Restore Defaults NO Erase" {
		if {[$Router wlconf_by_nvram]} {
			$Router restore_defaults
		}
		# Collect HW info and update report header + DB
		UTF::ReportWhatami $Router -role DUT -noload $(noapload)
	    }

	    if {![$Router cget -nomaxmem] && [$Router rte_available]} {
		UTF::Try "$Router: Load Free(K)" {
		    memchart [$Router freekb] -failonlow \
			-key [list $branch $Router loadfree] \
			-history $(history) -units kb -title "Load Free"
		}
	    }
	}
	if {$(norestore)} {
	    UTF::Try "$Router: Restore Defaults" {
		$Router restore_defaults -noerase
	    }
	}
	#--------------------------------STA load --------------------------------------------
	foreach STA $(sta) {
	    # Find images
	    if {!$(nostaload)} {
		UTF::Try "$STA: Find STA Image" {
		    # Check primary image and start report header
		    UTF::CheckImage $STA $stadate unknown
		}
		UTF::Try "$STA: load" {
		    $STA load
		}
		# Check secondary driver and update report header
		UTF::ReportDriver $STA $stadate
	    } elseif {[catch {$STA wl ver}]} {
		# If there is no driver, at least try reloading
		UTF::Try "$STA: reload" {
		    $STA reload
		}
	    }
	}
	#--------------------  Configure security and associate module load  ----------------
	foreach STA $(sta) {
		UTF::Try "$Router: Configure security and associate." {
			APConfigureSecurity $Router -security $(security)
			# Attempt to remove router from arp cache, in case we
			# switched between routers with the same IP address.
			set APIP [$Router cget -lan_ip]
			$STA -x arp -d $APIP
				ConnectAPSTA $Router $STA -security $(security) -stasecurity $(security) -tries 3
			return
		}
	}
	#---------------------------------------------------------------------------

	UTF::Sleep 10
	set modules ""

	# This is regular test and we loop through each STA.
	# Chung to test

	foreach STA $(sta) {
	    setup_summaries $Router $STA $(titleap) \

	    if {$(suite) eq "P1"} {

		UTF::Message LOG "" "JST10: Trying to execute P1 set of commands"
		wifi_test_hal_p1_commands $Router $STA

	    } elseif {$(suite) eq "P2"} {
		UTF::Message LOG "" "JST11: P2 SET commands"
		test_p2_commands $Router $STA
            } elseif {$(suite) eq "P3"} {
		UTF::Message LOG "" "JST11: P3 SET commands"
		test_p3_commands $Router $STA
            } elseif {$(suite) eq "P4"} {
		UTF::Message LOG "" "JST11: P4 SET commands"
		test_p4_commands $Router $STA
            } elseif {$(suite) eq "P5"} {
		UTF::Message LOG "" "JST11: P5 SET commands"
		test_p5_commands $Router $STA
            } elseif {$(suite) eq "P6"} {
		UTF::Message LOG "" "JST11: P6 SET commands"
		test_p6_commands $Router $STA
            } else {
		UTF::Message LOG "" "JST11: P2 SET commands"
		test_p2_commands $Router $STA

		UTF::Message LOG "" "JST11: P3 SET commands"
		test_p3_commands $Router $STA

		UTF::Message LOG "" "JST11: P4 SET commands"
		test_p4_commands $Router $STA

		UTF::Message LOG "" "JST11: P5 SET commands"
		test_p5_commands $Router $STA

		UTF::Message LOG "" "JST11: P6 SET commands"
		test_p6_commands $Router $STA
		incr ::sta_counter
	    }
	    if {!$(nostaunload)} {
		foreach STA $(sta) {
		    UTF::Try "$STA: unload" {
		    $STA unload
		    }
		}
	    }
	    PreservedReport

	    if {!$(noposttesthook) && [info exists ::UTF::PostTestHook]} {
		UTF::Try "Post Test" {
		    eval $::UTF::PostTestHook
		}
	    }
	}

	# Do optional post test analysis. The "" passes the unnamed options array.
	UTF::do_post_test_analysis hal_commands.test ""
    }
}
