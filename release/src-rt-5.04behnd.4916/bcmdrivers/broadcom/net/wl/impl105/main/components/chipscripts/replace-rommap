#!/usr/bin/perl
#
# $Id: replace-rommap,v 1.27 2011-02-03 23:26:20 csm Exp $
#
# This script replaces predefined macros in linker script template with information
# found in ROM symbol table, STDIN, and etc. and outputs the linker script to STDOUT.
#
# 1. For building ROM library:
#
# KEEP_MAP macro - ROM symbols (function/data) to keep
#     - Uses ROM symbols with .extern keyword found in file <rom-table>
# DEL_MAP macro - ROM data to discard for feature specific
#     - ROM symbols to discard for feature specific
# ESC_SPACE macro - Reserve room for ROM escape table
#     - Reads file romesc.txt
# ROMXREF macro - Used discard rodata to gen xref during link pass 1
#
# 2. For building ROM offloaded RAM image:
#
# SHDAT_MAP macro - ROM/RAM shared data (initialized/uninitialized)
#     - Reads an input file <roml-nm> containing the output of 'nm -n roml.exe' and
#       an input file <roml-objdump> containing the output of 'objdump -t roml.exe'
# UNDEF_MAP macro - RAM functions default address in case they are not available
#       due to different compilation flags
#     - Uses RAM symbols found in file <stubbed-symbols>
# ESC_TABLE macro - ROM escape table
#     - Reads file romesc.txt
#

use warnings;
use Getopt::Std;


my $idre = '([\w$]+)';
my $fnre = '([\w.-]+)';
my $adr = '([0-9a-fA-F]{8})';
my $addr_re = '([0-9a-fA-F]{8})';

# Parse optional command-line options.
my %opts;
getopts('h:r:', \%opts);

my $fnromtbl = "nil";
my $fnldsin = "nil";
if (@ARGV > 1) {
    $fnromtbl = $ARGV[0];
    $fnldsin = $ARGV[1];
}

my $jmptbl_full = 0;
if (@ARGV > 2) {
   $jmptbl_full = $ARGV[2];
}

my $minroml_build = 0;
if (@ARGV > 3) {
   $minroml_build = $ARGV[3];
}

my $fnromesc = "nil";
if (@ARGV > 4) {
    $fnromesc = $ARGV[4];
}

my $fnromesc_min = "nil";

my $DATA_START = $ARGV[5];

if (@ARGV > 6) {
    $fnromesc_min = $ARGV[6];
}



my $BOOTLOADER_PATCH_SIZE = 0x0;
if (@ARGV > 7) {
    $BOOTLOADER_PATCH_SIZE = $ARGV[7];
}


my $fnwrap = "nil";
if (@ARGV > 8) {
    $fnwrap = $ARGV[8];
}

my $tcam_enab = 0;
my $tcam_pcnt = 0;
my $tcam_size = 0;
my $patch_hdr_size = 0;
if (@ARGV > 10) {
   ($tcam_enab, $tcam_pcnt, $tcam_size, $patch_hdr_size) = split(/\+/, $ARGV[10]);
   if ($tcam_enab == 1) {
      die if ($tcam_pcnt > 4 || $tcam_pcnt < 0);
   }
}

if ($fnromtbl eq "nil" || $fnldsin eq "nil") {
    print "Usage: perl replace-rommap [-h patch_section_headers] [-r ram mapfile] <rom-table> \n";
    print "                           <linker-script-template> <jmptbl-type> <romesc>\n";
    print "                           <stubbed-symbols> <cpp-fnwrap> <jmptbl-tcam>\n";
    exit -1;
}


# Name of manual ROM patch object file (e.g. wlc_patch_43xx.o).
my $g_fname_manual_patch_obj;
# Hash of functions that have been manually patched. (key is function name, value is '1').
my %g_manual_patch_funcs;

# Parse manually patched functions.
if ($opts{h}) {
	my $fname = $opts{h};
	my ($fd, $line, $sect, @words);
	my $romfn_suffix = "__bcmromfn";

	# Open the section headers file for the manual patched object file.
	open($fd, "<$fname") or
		die "Could not open $fname for reading: $!\n";

	# Parse objdump section header. The format is:
	#    Idx Name          Size      VMA       LMA       File off  Algn
	#      0 .text         00000000  00000000  00000000  00000034  2**1
	#                      CONTENTS, ALLOC, LOAD, READONLY, CODE
	#    ...
	#      3 .text.bcm_mp_stats__bcmromfn_preamble 0000000e  00000000  00000000  00000034  2**1
	#                      CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
	foreach $line (<$fd>) {
		# Parse patched object file name, syntax is:.
		#    wlc_patch_4350c1.o:     file format elf32-littlearm
		if ($line =~ /^\s*($idre\.o):\s+file format/) {
			$g_fname_manual_patch_obj = $1;
		}
		# Parse patched functions.
		elsif ($line =~ /^\s*[0-9]+\s+/) {
			$line =~ s/^\s+//;
			@words = split(/\s+/, $line);
			$sect  = $words[1];
			if (($sect =~ /\.text\.$idre/) && ($sect !~ /$romfn_suffix/)) {
				$g_manual_patch_funcs{$1} = 1;
			}
		}
	}

	# Clean up.
	close $fd;
}


# Parse the all-RAM map file generated by the 'nm' utility. For ROM offload images, this is used to
# generate a list of all symbols used by a particular build. If a function is not used, but a
# RAM function stub exists for it, the RAM function stub is set to reference hnd_unimpl().
# This saves RAM memory by eliminating the need to include the function (and its associated
# call chain) from the ROM offload image.
#
# The format of the input file is:
#
# 00000148 T enable_arm_ints
# 00000184 T disable_arm_ints
my %sym_exists;
my $exclude_unused_func_stubs = 0;
if ($opts{r}) {
   my $fname_all_ram_mapfile = $opts{r};
   my ($fd, $line);

   $exclude_unused_func_stubs = 1;

   # Open map file.
   open($fd, "<$fname_all_ram_mapfile") or
      die "Could not open $fname_all_ram_mapfile for reading: $!\n";

   # Iterate the file, and parse symbols.
   foreach $line (<$fd>) {
      if ($line =~ /${addr_re} . ${idre}$/) {
         $sym_exists{$2} = 1;
      }
   }

   # Clean up.
   close $fd;
}

my %ramsec = ();
my %ramsec0 = ();
my %ramsec1 = ();
my %ramsec2 = ();
my %ramsec3 = ();

if (@ARGV > 11) {
	my $fname_sec = $ARGV[11];
	my $fh;
	
	open($fh, "$fname_sec") or die "Unable to open file $fname_sec: $!\n";
	map {
		my $sym = $1 if /^${idre}/;
		if (defined $sym) {
			$ramsec{$sym} = 1;
			if (/textini3$/) {
				$ramsec3{$sym} = 1;
			} 
			elsif (/textini2$/) {
				$ramsec2{$sym} = 1;
			}
			elsif (/textini1$/) {
				$ramsec1{$sym} = 1;
			} else {
				$ramsec0{$sym} = 1;
			}
		}
	} <$fh>;
	close $fh;
}

# find all symbols with .extern keyword in the rom table
open($fhromtbl, "<$fnromtbl") or die "Unable to open file $fnromtbl: $!\n";
my @declare = ();
my %abandoned = ();
my %abandoned_rodata = ();
my %not_abandoned = ();
my %g_flist = ();
my %sym_present_in_updated_romtable = ();
my $fname = "";
map {
    my $sym = $1 if /^\s*\.extern\s+${idre}\b/;
    if (defined $sym) {
    $sym_present_in_updated_romtable{$sym} = 1;
	if (/\#.*\.abandon\b/) {
	    $abandoned{$sym} = 1;
	    $ramsec0{$sym} = 1 if (!$ramsec{$sym});
	    $abandoned_rodata{$sym} = 1 if (/\#.*\.rodata\b/);
	} else {
	    $not_abandoned{$sym} = 1;
	}
	die "$sym is both abandoned and not abandoned in $fnromtbl\n"
	    if $abandoned{$sym} && $not_abandoned{$sym};
	push(@declare, $_);	# save whole line
    } elsif (/\#\s*${fnre}\.o/) {
	$g_flist{$1} = 1;
	$fname = $1;
    }
} <$fhromtbl>;
close($fhromtbl);

# load all stubbed symbols to prepare for the cases where they are not available
# in RAM image due to different compile flags
my @wrap = ();
my %wrap_i = ();
if ($fnwrap ne "nil") {
   open($fhwrap, "<$fnwrap") or die "Unable to open file $fnwrap: $!\n";
   map {
       push (@wrap, $1) if /^${idre}$/;
       $wrap_i{$1} = 1 if /^${idre}$/;
   } <$fhwrap>;
   close($fhwrap);
}

# Preprocessed ramfnptr wrappers based on compilation flags
if (@ARGV > 9) {
   my %wrap_cpp = ();
   my $fnwrap_i = $ARGV[9];

   open($fhwrap_i, "<$fnwrap_i") or die "Unable to open file $fnwrap_i: $!\n";
   map {
       $wrap_cpp{$1} = 1 if /^${idre}$/;
   } <$fhwrap_i>;
   close($fhwrap_i);

   foreach my $line (sort keys %wrap_i) {
     $wrap_i{$line} = 0 if (!$wrap_cpp{$line});

     if ($exclude_unused_func_stubs) {
        $wrap_i{$line} = 0 if (!$sym_exists{$line});
     }
   }
}

# read all lines from STDIN (redirected from nm -n and objdump -t outputs)
# and break them into nm -n and objdump -t portions.
my @parts = split(/SYMBOL TABLE:\n/, join('', <STDIN>));
my @nm = ();
my @objdump = ();
if (@parts > 0) {
    @nm = split(/\n/, $parts[0]);
}
if (@parts > 1) {
    @objdump = split(/\n/, $parts[1]);
}

my %g_fn_tbl = ();
my $fn;
for (my $od = 0; $od < @objdump; $od ++) {
    my @words = split(" ", $objdump[$od]);
    if ($words[1] =~ /^l$/) {
	if ($words[2] =~ /^df$/ && $words[3] =~ /^\*ABS\*$/) {
	    $fn = $words[5];
	}
 	# format 2
	elsif ($words[2] =~ /^\.bss|\.data$/) {
	    $g_fn_tbl{$words[4]} = $fn;
	}
	# format 1
	elsif ($words[3] =~ /^\.bss|\.data$/) {
	    $g_fn_tbl{$words[5]} = $fn;
	}
    }
}

# ROM func name suffix
my $g_romfn_suffix = "";
my $g_romdat_suffix = "__bcmromdat";
if ($jmptbl_full == 0) {
   $g_romfn_suffix = "__bcmromfn";
}

my %g_nm_tbl = ();
map {
   $g_nm_tbl{$2} = $1 if /${adr} . ${idre}$/;
} @nm;

my %g_od_tbl = ();
map {
   $g_od_tbl{$1} = $_ if /\b${idre}$/;
} @objdump;

sub nm_sym2addr {
    my $sym = shift;

    return -1 if (!$g_nm_tbl{$sym});

    return hex($g_nm_tbl{$sym});
}

# replace macros while copying input to output
open($fhldsin, "<$fnldsin") or die "Unable to open file $fnldsin: $!\n";
while (<$fhldsin>) {
    # replace DEL_MAP
    if (/DEL_MAP/) {
	printf("\t/DISCARD/ : {\n");
        if ($jmptbl_full == 1) {
           printf("\t\t*(.textini2.*)\n");
           printf("\t\t*(.dataini2.*)\n");
           printf("\t\t*(.textini3.*)\n");
           printf("\t\t*(.dataini3.*)\n");
        }
        printf("\t\t/* ROMXREF */\n");
	printf("\t}\n");
    }
    # replace ROMXREF
    elsif (/ROMXREF/) {
	for (my $d = 0; $d < @declare; $d ++) {
	   @words = split(" ", $declare[$d]);
	   if ($jmptbl_full == 0) {
		if ($declare[$d] =~ /\#\s*\.rodata\b/) {
			printf("\t\t*(.romdptr._bcmdatbl__%s)\n", $words[1]);
		} else {
			printf("\t\t*(.romfnptr._bcmjmptbl__%s)\n", $words[1]);
		}
	   } else {
		if ($declare[$d] =~ /\#\s*\.rodata\b/) {
			printf("\t\t*(.rodata.%s)\n", $words[1]);
		}
	   }
	}
    }
    # replace KEEP_MAP
    elsif (/KEEP_MAP/) {
	# print KEEP(*(.textrom.symbol)) for each symbol listed in romtable.S
	for (my $d = 0; $d < @declare; $d ++) {
	    if ($declare[$d] =~ /\#\s*\.rodata\b/) {
		next;
	    }
	    @words = split(" ", $declare[$d]);
	    if ($jmptbl_full == 0) {
	        printf("\t\tKEEP(*(.textrom.%s%s))\n", $words[1], $g_romfn_suffix);
	    } else {
	        printf("\t\tKEEP(*(.text.%s%s))\n", $words[1], $g_romfn_suffix);
	    }
	}
	# print KEEP(*(.datarom.symbol)) for each symbol listed in romtable.S
	for (my $d = 0; $d < @declare; $d ++) {
	    if ($declare[$d] =~ /\#\s*\.rodata\b/) {
		@words = split(" ", $declare[$d]);
		if ($jmptbl_full == 0) {
		   printf("\t\tKEEP(*(.datarom.%s%s))\n", $words[1], $g_romdat_suffix);
		} else {
		   printf("\t\tKEEP(*(.rodata.%s))\n", $words[1]);
		   printf("\t\tKEEP(*(.rodata.%s%s))\n", $words[1], $g_romdat_suffix);
		}
	    }
	}
    }
    # replace SHDAT_MAP macro */
    elsif (/SHDAT_MAP/) {
	# find shdat_start/shdat_end in nm file
	my $shdat_start = nm_sym2addr('shdat_start');
	my $shdat_end = nm_sym2addr('shdat_end');
	if ($shdat_start == -1 || $shdat_end == -1 || $shdat_start == $shdat_end) {
	    printf("\t/* SHARED DATA NOT FOUND IN ROM IMAGE */\n");
	    next;
	}
	my $addr_expected = -1;
	printf("\t. = 0x%x;\n", $shdat_start);
	printf("\t.shdat : {\n");
	printf("\t\tshdat_start = .;\n");
	# print input section for each symbol within shdat_start/shdat_end
	for (my $s = 0; $s < @nm; $s ++) {
	    # nm format: offset type symbol
	    @words = split(" ", $nm[$s]);
	    next if (@words != 3);

	    $offset = hex($words[0]);
	    next if ($offset < $shdat_start || $offset >= $shdat_end);

	    # ignore these symbols
	    $symbol = $words[2];
	    next if ($symbol =~ /(esc|shdat|ramfnptr|jmptblrom|datblrom)_(start|end)/);

	    # find the symbol in symtbl and print it as an input section
	    $found = 0;
	    my $keep_str = "";

	    if (!$g_od_tbl{$symbol}) {
		# unable to find symbol
		printf("\t\t/* SYMBOL %s NOT FOUND IN ROM IMAGE */\n", $symbol);
		next;
	    }

	    @words = split(" ", $g_od_tbl{$symbol});

	    # symtbl format 1: offset x y section size symbol
	    # symtbl format 2: offset x section size symbol
	    if (@words < 2 || !($words[1] =~ /^l|g\b/)) {
		next;
	    }
	    # format 2
	    if ($words[2] =~ /^\.bss|\.data\b/) {
		$sectpos = 2;
		$sizepos = 3;
		$sympos = 4;
	    }
	    # format 1
	    elsif ($words[3] =~ /^\.bss|\.data\b/) {
		$sectpos = 3;
		$sizepos = 4;
		$sympos = 5;
	    }
	    # static variables/symbols
	    # use the last file name seen before the symbol as the file name
	    if ($words[1] =~ /^l\b/) {
		if (hex($words[0]) == $offset && $words[$sectpos] =~ /^\.bss|\.data\b/ &&
		       $words[$sympos] =~ /^\Q$symbol\E\b/) {
		    $object = $g_fn_tbl{$symbol};
		    $object =~ s/\.c|\.S/\.o/;
		    @tokens = split(/\//, $object);
		    $object = $tokens[@tokens - 1];
		    # static variables in functions
		    if ($words[$sympos] =~ /\.[0-9]+/) {
			$value = 0;
			$comment = "/* $object $words[$sectpos] $words[$sympos] */";
			if (hex($words[$sizepos]) == 1) {
			    printf("\t\tBYTE(%u)\t%s\n", $value, $comment);
			}
			elsif (hex($words[$sizepos]) == 2) {
			    printf("\t\tSHORT(%u)\t%s\n", $value, $comment);
			}
			elsif (hex($words[$sizepos]) == 4) {
			    printf("\t\tLONG(%u)\t%s\n", $value, $comment);
			}
			else {
			    printf("\t\t. = . + %u;\t%s\n", hex($words[$sizepos]), $comment);
			}
		    }
		    # static variables in files
		    else {
			$keep_str = "KEEP($object(.*.$words[$sympos]))";
		    }
		    $found = 1;
		}
	    }
	    # global variables/symbols
	    elsif ($words[1] =~ /^g\b/) {
		if (hex($words[0]) == $offset && $words[$sectpos] =~ /^\.bss|\.data\b/ &&
		    $words[$sympos] =~ /^\Q$symbol\E\b/) {
		    $keep_str = "KEEP(*(.*.$words[$sympos]))";
		    $found = 1;
		}
	    }
	    if (($found == 1) && ($keep_str ne "")) {
		my $addr_curr = hex($words[0]);
		my $size_curr = hex($words[$sizepos]);
		printf("\t\t. = %d; /* e:%x a:%x p:%x s:%x */\n",
		       $addr_curr - $shdat_start, $addr_expected, $addr_curr,
		       $addr_curr - $addr_expected, $size_curr);

		# Next expected address
		$addr_expected = $addr_curr + $size_curr;
		printf("\t\t%s\n", $keep_str);
	    }
	}
	printf("\t\t. = %d;\n", $shdat_end - $shdat_start);
	printf("\t\tshdat_end = .;\n");
	printf("\t}\n");
    }
    # replace UNDEF_MAP
    elsif (/UNDEF_MAP/) {
	printf("\t\tKEEP(*(.text.hnd_unimpl_escfn))\n");
	if (@wrap == 0) {
	    printf("\t\t/* NO UNDEFINED SYMBOLS REFERENCED FROM ROM IMAGE */\n");
	    next;
	}
	# keep hnd_unimpl() in the ROM image if there is any undefined symbols
	printf("\t\tKEEP(*(.text.hnd_unimpl))\n");
	# redirect all undefined symbols to hnd_unimpl()
	for (my $w = 0; $w < @wrap; $w ++) {
	    if ($wrap_i{$wrap[$w]}) {
		printf("\t\tASSERT(DEFINED($wrap[$w]), \"ramfnptr UNDEF: $wrap[$w]!\");\n", $wrap[$w]);
            }
	    printf("\t\tPROVIDE(%s = hnd_unimpl);\n", $wrap[$w]);
	}
    }
    # replace ESC_TABLE macro */
    elsif (/ESC_TABLE/) {
	next if ($jmptbl_full == 0);
	next if (!(-e "$fnromesc_min"));

	# generate the escape table for roml_min functions  by outputting function list from $fnromesc_min
	open(my $fh_min, $fnromesc_min) or die "Unable to open file $fnromesc: $!\n";
	printf("\t.romesc_min : {\n");
	printf("\t\tesc_min_start = .;\n");
	my $tbl_offset = hex($DATA_START);
	while (<$fh_min>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym}) {
		    printf ("\t\tASSERT(DEFINED($sym), \"esc NULL: $sym!\");\n");
		    printf("\t\tLONG($sym | 1) /* [%08x] Abandoned */\n",
			   $tbl_offset);
		} else {
		    my $addr = nm_sym2addr("${sym}__bcmromfn");
		    if ($addr < 0) {
			print STDERR "Symbol ${sym}__bcmromfn not found in ROM library\n";
			printf ("\t\tASSERT(DEFINED($sym), \"esc NULL: $sym!\");\n");
			printf("\t\tLONG($sym | 1) /* [%08x] Missing from ROM library */\n",
			       $tbl_offset);
		    } else {
			printf ("\t\tASSERT(DEFINED(${sym}__bcmromfn), \"esc NULL: ${sym}__bcmromfn!\");\n");
			printf("\t\tLONG(${sym}__bcmromfn | 1) /* [%08x] 0x%x */\n",
			       $tbl_offset, $addr | 1);
		    }
		}
	    }
	    $tbl_offset += 4;
	}
	printf("\t\tesc_min_end = .;\n");
	
	printf("\t}\n");
#	printf ("\t ASSERT(SIZEOF(.romesc_min), \"romesc empty!\");\n");
#	printf ("\t. = 0x%x\n",$tbl_offset);
	close($fh_min);

	next if (!(-e "$fnromesc"));

	# generate the escape table by outputting function list from $fnromesc
	open(my $fh, $fnromesc) or die "Unable to open file $fnromesc: $!\n";
	if($minroml_build == 1) {
		printf("\t.romesc : {\n");
		printf("\t\tesc_start = .;\n");
		while (<$fh>) {
		    if (/\s+${idre}$/) {
				my $sym = $1;
				if ($sym_present_in_updated_romtable{$sym}) {
					# if symbol is added in xxxmin/romtable.S, use it as if it is from ROM.
					if ($abandoned{$sym}) {
					    printf ("\t\tASSERT(DEFINED($sym), \"esc NULL: $sym!\");\n");
					    printf("\t\tLONG($sym | 1) /* [%08x] Abandoned */\n",
						   $tbl_offset);
					} else {
					    my $addr = nm_sym2addr("${sym}__bcmromfn");
					    if ($addr < 0) {
							printf ("\t\tASSERT(DEFINED($sym), \"esc NULL: $sym!\");\n");
							printf("\t\tLONG($sym | 1) /* [%08x] Missing from ROM library */\n",
							       $tbl_offset);
					    } else {
							printf ("\t\tASSERT(DEFINED(${sym}__bcmromfn), \"esc NULL: ${sym}__bcmromfn!\");\n");
							printf("\t\tLONG(${sym}__bcmromfn | 1) /* [%08x] 0x%x */\n",
							       $tbl_offset, $addr | 1);
					    }
					}					
				} else {
					# if symbol NOT added in xxxmin/romtable.S, use it as if it is abandoned and is required in RAM,
					# provided it is defined. If it is not defined, use a blank_esc_handler to deal with, which is
					# nothing but an assert/trap.
				    printf("\t\tLONG(DEFINED($sym) ? ($sym  | 1) : (hnd_unimpl_escfn | 1)) /* [%08x] Abandoned */\n",
					   $tbl_offset);
				}
				
		    }
		    $tbl_offset += 4;
		}
		
		printf("\t\tesc_end = .;\n");
		printf("\t}\n");
		close($fh);
	} else {
	printf("\t.romesc : {\n");
	printf("\t\tesc_start = .;\n");
		#my $tbl_offset = hex($DATA_START);
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym}) {
			    printf ("\t\tASSERT(DEFINED($sym), \"esc NULL: $sym!\");\n");
			    printf("\t\tLONG($sym | 1) /* [%08x] Abandoned */\n",
			   $tbl_offset);
		} else {
		    my $addr = nm_sym2addr("${sym}__bcmromfn");
		    if ($addr < 0) {
			print STDERR "Symbol ${sym}__bcmromfn not found in ROM library\n";
				printf ("\t\tASSERT(DEFINED($sym), \"esc NULL: $sym!\");\n");
				printf("\t\tLONG($sym | 1) /* [%08x] Missing from ROM library */\n",
			       $tbl_offset);
		    } else {
				printf ("\t\tASSERT(DEFINED(${sym}__bcmromfn), \"esc NULL: ${sym}__bcmromfn!\");\n");
				printf("\t\tLONG(${sym}__bcmromfn | 1) /* [%08x] 0x%x */\n",
			       $tbl_offset, $addr | 1);
		    }
		}
	    }
	    $tbl_offset += 4;
	}
	printf("\t\tesc_end = .;\n");
	printf("\t}\n");
	printf ("\t. = ASSERT(SIZEOF(.romesc), \"romesc empty!\");\n");
	close($fh);
    }
    }
    # Replace ESC_SPACE macro */
    elsif (/ESC_SPACE/) {
	next if ($jmptbl_full == 0);
	next if (!(-e "$fnromesc"));

	open(my $fh, $fnromesc_min) or die "Unable to open file $fnromesc_min: $!\n";
	my @romesc_min_lines = <$fh>;
	close($fh);


	open($fh, $fnromesc) or die "Unable to open file $fnromesc: $!\n";
	my @romesc_lines = <$fh>;
	close($fh);
	
	my $romesc_count = scalar @romesc_min_lines + scalar @romesc_lines;
	printf("\tesc_start = .;\n");
	printf("\t. += 0x%x;\n", $romesc_count * 4);
	printf("\tesc_end = .;\n");
    }
    elsif (/ESC_KEEP/) {
	next if ($jmptbl_full == 0);

	# TCAM patching.
	# Each abandoned function needs a KEEP to pull in the RAM version.
	# Otherwise the link will succeed but the missing symbols are all zero!
	if (!(-e "$fnromesc") && $tcam_enab == 1) {
		foreach my $sym (sort keys %abandoned) {
			if ($ramsec0{$sym}) {
				# For manually patched functions, explicitly KEEP the version from
				# the patch file. Otherwise, wildcarding (KEEP(*(.*.$sym))) causes
				# the linker to pull in both RAM versions of the function, one from
				# the original (wlc_xxx.c) and one from the patch file (wlc_patch_43xx.c).
				# The original function is unused and doesn't even have a symbol.
				if ($g_manual_patch_funcs{$sym}) {
					printf("\t\tKEEP($g_fname_manual_patch_obj(.text.$sym))\n");
				}
				else {
					printf("\t\tKEEP(*(.*.$sym))\n");
				}
				printf ("\t\tASSERT(DEFINED($sym), \"NULL: $sym!\");\n");
			}
		}
		next;
	}

	# XXX TODO: Merge this while loop and the previous if/foreach block. They are essentially
	# the same. One is for chips that use TCAM patching, and the other is for chips that use
	# software patching.
	#
	# Software patch table.
	# Each abandoned function needs a KEEP to pull in the RAM version.
	# Otherwise the link will succeed but the missing symbols are all zero!
	open(my $fh, $fnromesc) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
		if (/\s+${idre}$/) {
			my $sym = $1;
			if ($abandoned{$sym} && $ramsec0{$sym}) {
				# For manually patched functions, explicitly KEEP the version from
				# the patch file. Otherwise, wildcarding (KEEP(*(.*.$sym))) causes
				# the linker to pull in both RAM versions of the function, one from
				# the original (wlc_xxx.c) and one from the patch file (wlc_patch_43xx.c).
				# The original function is unused and doesn't even have a symbol.
				if ($g_manual_patch_funcs{$sym}) {
					printf("\t\tKEEP($g_fname_manual_patch_obj(.text.$sym))\n");
				}
				else {
					printf("\t\tKEEP(*(.*.$sym))\n");
				}
				printf ("\t\tASSERT(DEFINED($sym), \"NULL: $sym!\");\n");
			}
		}
	}
	close($fh);

	# XXX: TODO: min-roml support is obsolete, and should be removed.
	open($fh, $fnromesc_min) or die "Unable to open file $fnromesc_min: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec0{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);
    }
    # XXX TODO: Multiple ESCx_KEEP sections are redundant. Should be merged.
    elsif (/ESC1_KEEP/) {
	next if ($jmptbl_full == 0);

	# Flag missing TCAM patching symbols
	if (!(-e "$fnromesc") && $tcam_enab == 1) {
		foreach my $sym (sort keys %abandoned) {
		  if ($ramsec1{$sym}) {
			printf("\t\tKEEP(*(.*.$sym))\n");
			printf ("\t\tASSERT(DEFINED($sym), \"tcam NULL: $sym!\");\n");
		  }
		}
		next;
	}

	# Each abandoned function needs a KEEP to pull in the RAM version.
	# Otherwise the link will succeed but the missing symbols are all zero!
	open(my $fh, $fnromesc) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec1{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);

	open($fh, $fnromesc_min) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec1{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);
    }
    # XXX TODO: Multiple ESCx_KEEP sections are redundant. Should be merged.
    elsif (/ESC2_KEEP/) {
	next if ($jmptbl_full == 0);

	# Flag missing TCAM patching symbols
	if (!(-e "$fnromesc") && $tcam_enab == 1) {
		foreach my $sym (sort keys %abandoned) {
		  if ($ramsec2{$sym}) {
			printf("\t\tKEEP(*(.*.$sym))\n");
			printf ("\t\tASSERT(DEFINED($sym), \"tcam NULL: $sym!\");\n");
		  }
		}
		next;
	}

	# Each abandoned function needs a KEEP to pull in the RAM version.
	# Otherwise the link will succeed but the missing symbols are all zero!
	open(my $fh, $fnromesc) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec2{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);

	open($fh, $fnromesc_min) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec2{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);
    }
    # XXX TODO: Multiple ESCx_KEEP sections are redundant. Should be merged.
    elsif (/ESC3_KEEP/) {
	next if ($jmptbl_full == 0);

	# Flag missing TCAM patching symbols
	if (!(-e "$fnromesc") && $tcam_enab == 1) {
		foreach my $sym (sort keys %abandoned) {
		  if ($ramsec3{$sym}) {
			printf("\t\tKEEP(*(.*.$sym))\n");
			printf ("\t\tASSERT(DEFINED($sym), \"tcam NULL: $sym!\");\n");
		  }
		}
		next;
	}

	# Each abandoned function needs a KEEP to pull in the RAM version.
	# Otherwise the link will succeed but the missing symbols are all zero!
	open(my $fh, $fnromesc) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec3{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);

	open($fh, $fnromesc_min) or die "Unable to open file $fnromesc: $!\n";
	while (<$fh>) {
	    if (/\s+${idre}$/) {
		my $sym = $1;
		if ($abandoned{$sym} && $ramsec3{$sym}) {
		    printf("\t\tKEEP(*(.*.$sym))\n");
		}
	    }
	}
	close($fh);
    }
    elsif (/PATCH_TBL/) {
	next if ($tcam_enab == 0);

	my $pentry_size = (1 << $tcam_pcnt) * 4;
	my $ptbl_size = $tcam_size;
	$ptbl_size = $ptbl_size - 1;
	# set all bits to 1 after the left most set bit
	$ptbl_size |= $ptbl_size >> 1;
	$ptbl_size |= $ptbl_size >> 2;
	$ptbl_size |= $ptbl_size >> 4;
	$ptbl_size |= $ptbl_size >> 8;
	$ptbl_size |= $ptbl_size >> 16;
	$ptbl_size = $ptbl_size + 1;
	$ptbl_size = $pentry_size * $ptbl_size;
	$tcam_size = $pentry_size * $tcam_size;

	printf("\t/* TCAM patch table */\n");
	printf("\t_patch_align_start = .;\n");
	printf("\t.patchentry : {\n");
	printf("\t\t. = ALIGN($ptbl_size);\n");
	printf("\t\t_patch_table_start = .;\n");
	printf("\t\tKEEP(*(.patchentry.*))\n");
	printf("\t\t_patch_table_last = .;\n");
	printf("\t\tASSERT(((_patch_table_last - _patch_table_start) %% $pentry_size) == 0, \"ERR: Unexpected TCAM Entry Size Last!\");\n");
	printf("\t\tASSERT((_patch_table_last - _patch_table_start) <= $tcam_size, \"ERR: TCAM Patches > $tcam_size!\");\n");
	printf("\t}\n");
	printf("\t/* Pre-allocate entire patch table */\n");
	printf("\t/* Then reclaim unused entries */\n");
	printf("\t. = . + ($tcam_size - (_patch_table_last - _patch_table_start));\n");
	printf("\t_patch_table_end = .;\n");
    }
    elsif (/PATCH_HDR/) {
	next if ($tcam_enab == 0);

	my $pentry_size = (1 << $tcam_pcnt) * 4;
	my $ptbl_size = $pentry_size * $tcam_size;
	my $phdr_total_size = $patch_hdr_size * $tcam_size;	# $patch_hdr_size is each patch header's size from Makerules.

	printf("\t/* Reclaim TCAM patch headers */\n");
	printf("\t.patchhdr : {\n");
	printf("\t\t_patch_hdr_start = .;\n");
	printf("\t\tKEEP(*(.patchhdr.*))\n");
	printf("\t\t_patch_hdr_end = .;\n");

	printf("\t\t/* Expects patch header size of $patch_hdr_size each */\n");
	printf("\t\tASSERT(((_patch_hdr_end - _patch_hdr_start) %% $patch_hdr_size) == 0, \"ERR: Unexpected TCAM Hdr Size!\");\n");
	printf("\t\tASSERT((_patch_hdr_end - _patch_hdr_start) <= $phdr_total_size, \"ERR: TCAM Headers > $tcam_size!\");\n");
	printf("\t}\n");
    }
    elsif (/PATCH_JMPT/) {
	next if ($tcam_enab == 0);

	my $fn = "jmptbl_tcam.S";
	open(JFIL,">$fn") or die "Unable to open file $fn: $!\n";

	printf JFIL ("\t.syntax unified\n");
	printf JFIL ("\n");
	printf JFIL ("\n");

	my %abandoned_addr = ();
	foreach my $sym (sort keys %abandoned) {
	   next if ($abandoned_rodata{$sym});

	   my $addr = nm_sym2addr($sym);
#	   die if $addr == -1;
	   $abandoned_addr{$sym} = $addr;
        }

	my $next = 1;
	#
	# Sort patchinstr by addr
	#
	foreach my $sym (sort { $abandoned_addr{$a} <=> $abandoned_addr{$b} } keys %abandoned_addr) {
	   my $addr = $abandoned_addr{$sym};

           printf("\t. = 0x%08x;\n", $addr);
           printf("\t.patchinstr_%d : {\n", $next);
           printf("\t\tKEEP(*(.patch%d.*))\n", $next);
           printf("\t}\n");

	   #
	   # Output to jmptbl_tcam.S
	   #
	   printf JFIL ("\t.section        .patch%d.__%s__tcpatched_%d,\"ax\",%%progbits\n", $next, $sym, $next);
	   printf JFIL ("\t.thumb\n");
	   printf JFIL ("\t.align  2\n");
	   printf JFIL ("\t.global __%s__tcpatched_%d\n", $sym, $next);
	   printf JFIL ("\t.type __%s__tcpatched_%d, %%function\n", $sym, $next);
	   printf JFIL ("__%s__tcpatched_%d:\n", $sym, $next);
	   printf JFIL ("\tb.w     %s\n", $sym);
	   printf JFIL ("\n");

	   $next++;
	}
	close(JFIL);
    } elsif (/BOOTLOADER_PATCH_MEM/) {
	   printf("\t\tbootloader_patch_start = .;\n");
	   printf("\t\t. += $BOOTLOADER_PATCH_SIZE;\n");
	   printf("\t\tbootloader_patch_end = .;\n");
    }
    # print the line as is
    else {
	print $_;
    }
}
close($fhldsin);
